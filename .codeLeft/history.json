[
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/main.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-01-14T18:49:19.632Z",
    "codeReview": {
      "review": "This code lacks proper error handling for `toolsFlag` being `nil` (line 48).  The `parseTools` function (line 120) while handling empty input, doesn't validate for invalid input (e.g., non-comma separated values).  The code's reliance on global variables (e.g., `history`) makes it harder to test and maintain, violating the Single Responsibility Principle.\n"
    },
    "gradingDetails": {},
    "hash": "6ad98f8c5d82a9c71af2a29fad81b88dab82bb996a0d6319cfeba66b0def6dfa"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/assessment/assessor.go",
    "grade": "C",
    "username": "Hlamb",
    "timestamp": "2025-01-14T18:49:19.706Z",
    "codeReview": {
      "review": "This code has three critical areas of concern.  First, `AccessorGrade`'s `Assess` method uses a `failed` boolean that is unnecessarily inverted.  Second, `AccessorAverageCoverage`'s `Assess` method has a potential division by zero error if `details` is empty.  Third, both `AccessorGrade` and `AccessorAverageCoverage` rely on external `ViolationCounter` which couples the assessment logic to a specific violation handling mechanism.  Example: `ag.ViolationCounter.AddViolation(detail)` in `AccessorGrade.Assess`.\n"
    },
    "gradingDetails": {},
    "hash": "f6d71c9e82f719472da60493dea48847920d6b22fab33d32012c68f10348eaae"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/pathFilter.go",
    "grade": "A",
    "username": "Hlamb",
    "timestamp": "2025-01-14T18:49:19.710Z",
    "codeReview": {
      "review": "The code lacks proper error handling.  `filepath.ToSlash` normalization is redundant and potentially inefficient.  The `isIgnored` function's nested loops are inefficient for large lists of ignored files and folders.  Example:  `filepath.ToSlash(path)` is called twice in `isIgnored`, which is unnecessary.\n"
    },
    "gradingDetails": {},
    "hash": "708540decf8323791340152f441e93bd4f315241b411275c56dfea95bde13b80"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/read/configReader.go",
    "grade": "C",
    "username": "Hlamb",
    "timestamp": "2025-01-14T18:49:19.735Z",
    "codeReview": {
      "review": "This code lacks proper error handling and could benefit from more robust checks.  The `NewConfigReader` function has a critical flaw: it doesn't validate that `.codeleft` exists *before* attempting to join it with `config.json`.  This can lead to `config.json` being searched in a non-existent directory.  The `ReadConfig` function also suffers from similar issues, failing to check if `cr.CodeleftPath` is valid before using it.  Finally, the use of `defer file.Close()` is not ideal, as it can cause issues if errors occur during decoding.  These issues make the code vulnerable to panics and incorrect results.\n"
    },
    "gradingDetails": {},
    "hash": "5a08105ed281bbb170cae918a1fc82c36d8b520c420e5f08543dc37337ac357a"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/filterTools.go",
    "grade": "C",
    "username": "Hlamb",
    "timestamp": "2025-01-14T18:49:19.910Z",
    "codeReview": {
      "review": "1. **String manipulation in a loop:**  `strings.TrimPrefix` and `strings.TrimSuffix` are called within the loop.  This creates unnecessary overhead.  Example: `strings.TrimPrefix(value, \" \")`.  These should be performed once on the input slice.\n\n2. **Inefficient filtering:**  The code iterates through the entire `histories` slice for each `value` in the `values` slice.  This is a quadratic time complexity issue.  Example: `for _, history := range histories`.  Consider using a map for faster lookups.\n\n3. **Unnecessary copies:**  `filteredHistories` is repeatedly appended to.  This creates unnecessary copies of `Histories` objects.  Example: `filteredHistories = append(filteredHistories, toolFilteredHistories...)`.  Consider using a slice or other data structure that avoids repeated copies.\n"
    },
    "gradingDetails": {},
    "hash": "28e68a8455ec366f5b6a51623a9a464cd02be7c57122c83f0cbd38992991901f"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/collectGrades.go",
    "grade": "A",
    "username": "Hlamb",
    "timestamp": "2025-01-14T18:49:19.930Z",
    "codeReview": {
      "review": "This code violates the Single Responsibility Principle (SRP) by having `GradeCollection` handle both collecting grades and calculating numerical values.  `GradeCollection` also has a tight coupling with `GradeCalculator`, making it hard to swap implementations.  Finally, the repeated calculation of `GradeNumericalValue` within the loop is inefficient.  For example, the line `newDetails.GetCoverage(g.GradeCalculator.GradeNumericalValue(threshold))` could be improved by calculating the threshold value once outside the loop.\n"
    },
    "gradingDetails": {},
    "hash": "f0157612170dcca0f720a208d072a555efa6d25a81e910c8056df44ed71b1593"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/read/fileReader.go",
    "grade": "A",
    "username": "Hlamb",
    "timestamp": "2025-01-14T18:49:19.969Z",
    "codeReview": {
      "review": "This code has three critical areas of concern.  First, error handling is overly verbose and repetitive.  Checking for file existence and type multiple times (e.g., lines 58-66) is inefficient. Second, the `NewHistoryReader` function could benefit from a more robust way to handle the `repoRoot` parameter.  Instead of relying on `os.Getwd()`, it should accept the `repoRoot` as an argument.  Third, the code lacks clear separation of concerns.  The `HistoryReader` struct combines file reading and error handling, which could be improved by separating these responsibilities.  For example, line 28 and 32 could be improved by using a single error check.\n"
    },
    "gradingDetails": {},
    "hash": "13e7d47b68bedd08062072d8bbed62cbacbfcbc9092e88ba6d327c75e70e38c3"
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/read/fileReader.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-01-14T18:49:20.039Z",
    "codeReview": {
      "review": "This code lacks robust error handling for potential file system issues.  The `NewHistoryReader` function doesn't check if `.codeleft` exists *before* attempting to join it with `history.json`.  If `.codeleft` is missing, the `ReadHistory` function will return an error, but the error message is not informative.  Finally, the code doesn't validate the JSON structure of `history.json`, potentially leading to unexpected behavior or crashes if the file is malformed.  Example:  `if hr.CodeleftPath == \"\" { ... }` in `ReadHistory` is a critical error that should be handled earlier.\n"
    },
    "gradingDetails": {},
    "hash": "db6ba4436810f9fd5b10c7fd72c803af2cf705c844e33896208bf8bcf67c2f96"
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/main.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-01-14T18:49:20.172Z",
    "codeReview": {
      "review": "OWASP TOP 10 Review:\n\nCritical areas of concern include:\n\n1.  **Missing Input Validation:**  The code lacks robust input validation for the `toolsFlag`.  While it trims spaces, it doesn't prevent malicious input.  (e.g., `tools=OWASP-Top-10,../../etc/passwd`).  Improper handling of potentially harmful data could lead to directory traversal vulnerabilities.\n\n2.  **Lack of Error Handling:**  While error checks exist for file reading and initialization, the code lacks comprehensive error handling for potentially problematic inputs like empty `toolsFlag` values.  This can lead to unexpected behavior or crashes.  (e.g., `if toolsFlag == nil`).\n\n3.  **Unclear Logic:** The code's logic for handling different assessment types (`assess-grade`, `assess-coverage`) is not immediately obvious.  The conditional checks could be more explicit and readable.  (e.g., the `if *assessGrade` and `if *assessCoverage` blocks).\n"
    },
    "gradingDetails": {},
    "hash": "584cdc3ba1fa9635bb18aac6f159a547a9833446b11802aecbe43d2a8436b5f2"
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/types/model.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-01-14T18:49:20.198Z",
    "codeReview": {
      "review": "**OWASP Top 10 Review (Summary)**\n\nThis code snippet, defining a configuration structure, presents no immediate critical vulnerabilities.  However,  a lack of input validation for the `Threshold` field is a potential concern (Injection).  Additionally, the absence of any security measures related to the `Config` loading process (e.g., preventing malicious JSON input) is a significant weakness (Injection).  Finally, the `Config` structure lacks any mechanism to prevent or detect tampering with the `Security` settings, which could lead to unintended behavior (Improper Authentication).  Example:  No validation of `Threshold` string.\n"
    },
    "gradingDetails": {},
    "hash": "dea209c268df3ee0a5e1e4910487a245dc3246f6da3d765a4f9429bcab86f6c1"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/assessment/violations.go",
    "grade": "A",
    "username": "Hlamb",
    "timestamp": "2025-01-14T18:49:20.220Z",
    "codeReview": {
      "review": "This code demonstrates a basic implementation of a `Violations` interface and a `Violation` struct.  However, three critical areas of concern exist:\n\n1.  **Lack of error handling:** The `Print` method handles potential `fmt.Fprintf` errors, but the `NewViolation` function lacks error handling, which could lead to unexpected behavior if `filter.GradeDetails` is nil.\n\n2.  **Inefficient `AddViolation`:**  Appending to a slice within a method is generally fine, but if `ListViolations` is expected to grow very large, consider using a `sync.Pool` or a different data structure to avoid excessive allocations.\n\n3.  **Missing `Print` method implementation:** The `Print` method is implemented, but the `Violations` interface requires a `Print` method.  The current implementation is correct, but it could be improved by using a more efficient way to print the data.  For example, using a buffer to collect the output before writing to `os.Stderr`.\n"
    },
    "gradingDetails": {},
    "hash": "c5360edeb8a9a92ee7434810f5a901ede92cadc78f53e8599c47cc34d664ef4f"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/model.go",
    "grade": "D",
    "username": "Hlamb",
    "timestamp": "2025-01-14T18:49:20.245Z",
    "codeReview": {
      "review": "The `GetCoverage` function uses a series of `if/else if` statements, making it hard to read and maintain.  The logic for calculating coverage based on score thresholds is overly complex and could be simplified using a lookup table or a more concise conditional expression.  Finally, the `Histories` struct's `Len`, `Less`, and `Swap` methods are not efficient for large datasets, as they require copying the entire slice on each swap.\n"
    },
    "gradingDetails": {},
    "hash": "dd7b16fbf79c554dc3775c23ca32223744000b6431321b89e5f919a92bdb78fb"
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/pathFilter.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-01-14T18:49:20.311Z",
    "codeReview": {
      "review": "**OWASP Top 10 Review (Short Summary)**\n\nThree critical areas of concern:\n\n1.  **Improper Input Validation:**  The code lacks validation of the input `ignoredFiles` and `ignoredFolders`.  Maliciously crafted paths could lead to directory traversal vulnerabilities.  Example:  `../../etc/passwd` in `ignoredFiles`.\n\n2.  **Path Traversal:**  `filepath.ToSlash` normalizes paths, but this doesn't prevent directory traversal if the input paths are manipulated.  Example:  `../` in `ignoredFolders` could bypass intended filtering.\n\n3.  **Insufficient Error Handling:**  No error handling is present for potential issues with file paths or input data.  Example:  `filepath.Join` could fail if the input is malformed.\n"
    },
    "gradingDetails": {},
    "hash": "d74296a8e94f35dc6166239601b792b3ac3944d50349a20d3db7ced18af6f668"
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/read/configReader.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-01-14T18:49:20.404Z",
    "codeReview": {
      "review": "This code lacks robust error handling for file access and potential directory traversal vulnerabilities.  The `NewConfigReader` function doesn't validate the `.codeleft` directory's contents, potentially allowing malicious files to be included.  The `ReadConfig` function doesn't validate the `config.json` file's contents, leaving the application vulnerable to unexpected data.  Finally, the code assumes a specific directory structure, which could be problematic in different environments.  Example:  `filepath.Join(repoRoot, \".codeleft\")` in `NewConfigReader` is a potential vulnerability.\n"
    },
    "gradingDetails": {},
    "hash": "c1bb555f214888fa6a3ded388a80663c4b0564e7dbd88794c775ec050f30fb08"
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/model.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-01-14T18:49:20.426Z",
    "codeReview": {
      "review": "OWASP TOP 10 Review:\n\nCritical areas of concern include:\n\n1.  **Improper Input Validation:**  The `GetCoverage` function lacks input validation for `thresholdAsNum`.  Negative or extremely large values could lead to unexpected behavior or crashes.  Example: `if g.Score > thresholdAsNum { ... }`  This function is vulnerable to integer overflow.\n\n2.  **Unclear Logic:** The `GetCoverage` function's logic for calculating coverage based on score thresholds is complex and hard to follow.  This makes it prone to errors and difficult to maintain. Example: `else if g.Score >= thresholdAsNum-1 { ... }`  This could be simplified.\n\n3.  **Missing Error Handling:**  The code lacks error handling for potential issues, such as invalid data types or missing fields in the input data.  This could lead to unexpected behavior or crashes.\n"
    },
    "gradingDetails": {},
    "hash": "efc1b00af57026905a1f4bd02b08f4dbcf0f0d93840c82f78f08636d0e287cc0"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/latestGrades.go",
    "grade": "A",
    "username": "Hlamb",
    "timestamp": "2025-01-14T18:49:20.621Z",
    "codeReview": {
      "review": "* **Performance:**  The nested `if` statement within the loop significantly impacts performance.  Repeatedly checking for existence and comparing timestamps is inefficient.  (Line 20-23)\n\n* **Readability:** The `generateCompositeKey` function is overly simple and lacks clarity.  A more descriptive name would improve readability. (Line 27)\n\n* **Maintainability:**  The `ConvertMapToSlice` function is a simple but unnecessary conversion.  It's better to directly return the map if possible. (Line 34-40)\n"
    },
    "gradingDetails": {},
    "hash": "d5ffb49b2193a6be4c04397c840f914a644b604a18d68e17495c71ac01e663f4"
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/latestGrades.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-01-14T18:49:20.651Z",
    "codeReview": {
      "review": "**OWASP Top 10 Review (Short Summary)**\n\nThree critical areas of concern:\n\n1.  **Insecure Deserialization:**  No input validation is performed on `filePath` and `assessingTool` before constructing the composite key (`filePath + \"|\" + assessingTool`).  This could lead to a deserialization vulnerability if malicious input is used to craft a key that triggers unexpected behavior or exploits.  Example:  `../../../../etc/passwd|malicious_tool`.\n\n2.  **Improper Input Handling:**  The code lacks input validation for `filePath` and `assessingTool`.  These inputs are directly concatenated without any sanitization, potentially leading to issues like SQL injection or directory traversal vulnerabilities.  Example:  `filePath` containing special characters or path manipulation.\n\n3.  **Insufficient Data Validation:**  The code assumes that `TimeStamp` is always comparable.  If `TimeStamp` is not properly validated or if it's possible for it to be manipulated, the logic for selecting the latest history could be compromised.  Example:  `TimeStamp` being a string instead of a time.Time type.\n"
    },
    "gradingDetails": {},
    "hash": "74c96ba52e1585c9f7642ff28a384c821980abc17c4ba4503f49d90dfae68f55"
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/collectGrades.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-01-14T18:49:20.698Z",
    "codeReview": {
      "review": "**OWASP Top 10 Review (Critical Areas)**\n\n1.  **Injection:**  The code lacks input validation for the `threshold` string.  A malicious user could potentially inject code into the `threshold` parameter, leading to unexpected behavior or data breaches.  Example:  `threshold=\"A'; DROP TABLE Grades; --\"`.\n\n\n2.  **Improper Neutralization of Special Elements used in an SQL Command:**  The code does not sanitize the input `threshold` before using it in any calculations.  This could lead to SQL injection vulnerabilities if the `threshold` value is used in a database query.\n\n\n3.  **Insecure Deserialization:**  While not directly present in the provided code, the potential for insecure deserialization exists if the `Histories` type is not properly validated.  If `Histories` contains serialized data, malicious data could be deserialized and executed.\n"
    },
    "gradingDetails": {},
    "hash": "fcc7fcac941501615b5ced60e8a51d0c1cf04c884aef0c15ca2efd6b33f73c02"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/types/model.go",
    "grade": "A",
    "username": "Hlamb",
    "timestamp": "2025-01-14T18:49:20.767Z",
    "codeReview": {
      "review": "The code defines a `Config` struct for configuration, which is good for organization.  However, three critical areas of concern are:\n\n1.  **Lack of validation:**  The `Config` struct lacks validation for the `Threshold` string, which could lead to unexpected behavior if the value isn't correctly formatted.  Example:  No check for empty or invalid threshold values.\n\n2.  **Overly verbose quality flags:** The `Quality` struct has multiple boolean flags (e.g., `solid`, `liteTest`).  This could be improved by using a single flag or enum for a more concise representation. Example:  Replace `solid`, `liteTest`, `prReady`, `cleanCode` with a single `QualityLevel` enum.\n\n3.  **Missing error handling:** The code doesn't handle potential errors during JSON decoding or configuration usage.  Example:  Add error handling to the function that parses the config file.\n"
    },
    "gradingDetails": {},
    "hash": "f59e5426afcd0bcf6bc550d2eb40285a0c3b28ea70d14d834c6557edf37c9994"
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/assessment/assessor.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-01-14T18:49:20.777Z",
    "codeReview": {
      "review": "**OWASP Top 10 Review (Summary)**\n\n**Critical Areas of Concern:**\n\n1.  **Missing Input Validation:**  The code lacks validation for the `threshold` string in `AccessorGrade.Assess`.  A malicious user could potentially supply a string that isn't a valid numerical representation of a grade, leading to unexpected behavior or crashes.  Example: `Assess(\"abc\", ...)`\n\n2.  **Integer Overflow/Underflow:** The `AccessorAverageCoverage.Assess` function calculates an average. If the number of `details` is very large, the `total` variable could overflow, leading to incorrect results.  Example: `total += detail.Coverage`\n\n3.  **Improper Error Handling:**  `AccessorAverageCoverage.Assess` handles the case of an empty `details` slice, but doesn't handle other potential errors, such as `detail.Coverage` being negative or exceeding the maximum integer value. Example: `if (len(details)) == 0`\n"
    },
    "gradingDetails": {},
    "hash": "a87940e8450711ab92ee359a48bf600012b5b0b3a53da8f9ec6c1afbc6cefbf0"
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/assessment/violations.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-01-14T18:49:20.807Z",
    "codeReview": {
      "review": "**OWASP Top 10 Review (Snippet)**\n\n**Critical Areas of Concern:**\n\n1.  **Injection:**  No input validation is present.  Maliciously crafted `FileName`, `Grade`, or `Coverage` values could lead to unexpected behavior or system compromise.  Example:  `FileName` could be crafted to execute arbitrary commands.\n\n\n2.  **Improper Authentication:**  No authentication mechanisms are implemented.  Any user could potentially add violations and manipulate the output.\n\n\n3.  **Sensitive Data Exposure:**  The code directly prints sensitive information (file names, grades, coverage percentages) to standard error.  This data should be handled with more care, potentially redacted or logged securely.  Example: `fmt.Fprintf(os.Stderr, \"File: %s ...\")` exposes file names directly.\n"
    },
    "gradingDetails": {},
    "hash": "e8660768cab04c82070375a2299855764a94940f3ba3bf24e1580ba07aa07696"
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/filterTools.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-01-14T18:49:21.072Z",
    "codeReview": {
      "review": "**OWASP Top 10 Review (Short Summary)**\n\n**Critical Areas of Concern:**\n\n1.  **Improper Input Validation:**  The code lacks robust input validation for the `tool` string.  A malicious user could potentially supply input that could lead to unexpected behavior or security vulnerabilities.  Example: `strings.ToUpper(tool)` is vulnerable to a variety of attacks if the input is not sanitized.\n\n\n2.  **Insufficient Data Sanitization:**  The code does not sanitize the `value` string before using it in `strings.TrimPrefix` and `strings.TrimSuffix`.  This could lead to issues if the input contains special characters or unexpected formatting. Example: `strings.TrimPrefix(value, \" \")`.\n\n\n3.  **Potential for Denial-of-Service (DoS):**  If the input `values` array is very large, the code could potentially lead to a DoS attack.  The nested loops and appending operations could consume significant resources.  Example: The `for` loops in `Filter` and `filterByTool` are inefficient and could be optimized.\n"
    },
    "gradingDetails": {},
    "hash": "9ed7f87fe74e9b4a93ad20538f0023325c768770c817fa2b3506771e316c5957"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/types/model.go",
    "grade": "A",
    "username": "Hlamb",
    "timestamp": "2025-01-14T18:50:49.474Z",
    "codeReview": {
      "review": "The code defines a `Config` struct for configuration, which is good for organization.  However, three critical areas of concern are:\n\n1.  **Lack of validation:**  The `Config` struct lacks validation for the `Threshold` string, which could lead to unexpected behavior if the value isn't correctly formatted.  Example:  No check for empty or invalid threshold values.\n\n2.  **Overly verbose quality flags:** The `Quality` struct has multiple boolean flags (e.g., `solid`, `liteTest`).  This could be improved by using a single flag or enum for a more concise representation. Example:  Replace `solid`, `liteTest`, `prReady`, `cleanCode` with a single `QualityLevel` enum.\n\n3.  **Missing error handling:** The code doesn't handle potential errors during JSON decoding or configuration usage.  Example:  Add error handling to the function that parses the config file.\n"
    },
    "gradingDetails": {},
    "hash": "f02ca9b36ff752cd83a296e9221d5b5ca616a3ebd57c9b25d04c8edfb9db4f84"
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/assessment/violations.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-01-14T18:50:57.197Z",
    "codeReview": {
      "review": "**OWASP Top 10 Review (Snippet)**\n\n**Critical Areas of Concern:**\n\n1.  **Injection:**  No input validation is present.  Maliciously crafted `FileName`, `Grade`, or `Coverage` values could lead to unexpected behavior or system compromise.  Example:  `FileName` could be crafted to execute arbitrary commands.\n\n\n2.  **Improper Authentication:**  No authentication mechanisms are implemented.  Any user could potentially add violations and manipulate the output.\n\n\n3.  **Sensitive Data Exposure:**  The code directly prints sensitive information (file names, grades, coverage percentages) to standard error.  This data should be handled with more care, potentially redacted or logged securely.  Example: `fmt.Fprintf(os.Stderr, \"File: %s ...\")` exposes file names directly.\n"
    },
    "gradingDetails": {},
    "hash": "0a6e4df8c89e0636f9029d8528e88fb9d260aafd3b32c79ee1a30317bec06498"
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/assessment/assessor.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-01-14T18:51:03.449Z",
    "codeReview": {
      "review": "**OWASP Top 10 Review (Summary)**\n\n**Critical Areas of Concern:**\n\n1.  **Missing Input Validation:**  The code lacks validation for the `threshold` string in `AccessorGrade.Assess`.  A malicious user could potentially supply a string that isn't a valid numerical representation of a grade, leading to unexpected behavior or crashes.  Example: `Assess(\"abc\", ...)`\n\n2.  **Integer Overflow/Underflow:** The `AccessorAverageCoverage.Assess` function calculates an average. If the number of `details` is very large, the `total` variable could overflow, leading to incorrect results.  Example: `total += detail.Coverage`\n\n3.  **Improper Error Handling:**  `AccessorAverageCoverage.Assess` handles the case of an empty `details` slice, but doesn't handle other potential errors, such as `detail.Coverage` being negative or exceeding the maximum integer value. Example: `if (len(details)) == 0`\n"
    },
    "gradingDetails": {},
    "hash": "c0aebd8e388e5aa56399f1c9f0048020274aaaa9cf5d1b1749e03420f482e12c"
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/assessment/violations.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-01-14T18:51:09.035Z",
    "codeReview": {
      "review": "**OWASP Top 10 Review (Snippet)**\n\n**Critical Areas of Concern:**\n\n1.  **Injection:**  No input validation is present.  Maliciously crafted `FileName`, `Grade`, or `Coverage` values could lead to unexpected behavior or system compromise.  Example:  `FileName` could be crafted to execute arbitrary commands.\n\n\n2.  **Improper Authentication:**  No authentication mechanisms are implemented.  Any user could potentially add violations and manipulate the output.\n\n\n3.  **Sensitive Data Exposure:**  The code directly prints sensitive information (file names, grades, coverage percentages) to standard error.  This data should be handled with more care, potentially redacted or logged securely.  Example: `fmt.Fprintf(os.Stderr, \"File: %s ...\")` exposes file names directly.\n"
    },
    "gradingDetails": {},
    "hash": "6b93f2e9eae5845ddc30f563f4516951242f2f1e39522530f9a29135d53cf735"
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/collectGrades.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-01-14T18:51:14.681Z",
    "codeReview": {
      "review": "**OWASP Top 10 Review (Critical Areas)**\n\n1.  **Injection:**  The code lacks input validation for the `threshold` string.  A malicious user could potentially inject code into the `threshold` parameter, leading to unexpected behavior or data breaches.  Example:  `threshold=\"A'; DROP TABLE Grades; --\"`.\n\n\n2.  **Improper Neutralization of Special Elements used in an SQL Command:**  The code does not sanitize the input `threshold` before using it in any calculations.  This could lead to SQL injection vulnerabilities if the `threshold` value is used in a database query.\n\n\n3.  **Insecure Deserialization:**  While not directly present in the provided code, the potential for insecure deserialization exists if the `Histories` type is not properly validated.  If `Histories` contains serialized data, malicious data could be deserialized and executed.\n"
    },
    "gradingDetails": {},
    "hash": "fb5dbda2ecfa790325fa422f3a87910b8cf79ea4595c76714d1091522e493633"
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/filterTools.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-01-14T18:51:19.855Z",
    "codeReview": {
      "review": "**OWASP Top 10 Review (Short Summary)**\n\n**Critical Areas of Concern:**\n\n1.  **Improper Input Validation:**  The code lacks robust input validation for the `tool` string.  A malicious user could potentially supply input that could lead to unexpected behavior or security vulnerabilities.  Example: `strings.ToUpper(tool)` is vulnerable to a variety of attacks if the input is not sanitized.\n\n\n2.  **Insufficient Data Sanitization:**  The code does not sanitize the `value` string before using it in `strings.TrimPrefix` and `strings.TrimSuffix`.  This could lead to issues if the input contains special characters or unexpected formatting. Example: `strings.TrimPrefix(value, \" \")`.\n\n\n3.  **Potential for Denial-of-Service (DoS):**  If the input `values` array is very large, the code could potentially lead to a DoS attack.  The nested loops and appending operations could consume significant resources.  Example: The `for` loops in `Filter` and `filterByTool` are inefficient and could be optimized.\n"
    },
    "gradingDetails": {},
    "hash": "2c241da1aa4453d1946824a8393394355c3a0afa424307f4bc589b1d794c4236"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/model.go",
    "grade": "C",
    "username": "Hlamb",
    "timestamp": "2025-01-14T18:53:18.710Z",
    "codeReview": {
      "review": "The code defines a `History` struct and a `Histories` slice.  Three critical areas of concern are:\n\n1.  **Lack of error handling:**  No error handling is present in any of the functions, which could lead to unexpected behavior if input data is invalid.\n\n2.  **Unclear purpose of `CodeReview` and `GradingDetails`:** The `map[string]any` types for these fields lack specific types, making it unclear what data they should contain.  This could lead to runtime errors or unexpected behavior.\n\n3.  **Missing sorting context:** The sorting logic only considers the `TimeStamp`.  Without additional context, it's unclear if this is the intended sorting criteria.  For example, sorting by `Grade` or `Username` might be more appropriate in some cases.\n"
    },
    "gradingDetails": {},
    "hash": "010166970c6bfcb789b6d1de077d12b61ef5e49ca70a993d28b3c068428cb37e"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/gradeDetails.go",
    "grade": "C",
    "username": "Hlamb",
    "timestamp": "2025-01-14T18:53:26.152Z",
    "codeReview": {
      "review": "The code violates the Single Responsibility Principle (SRP) as `GetCoverage` handles both calculating and setting coverage.  It also lacks flexibility;  the hardcoded coverage values (e.g., `120`, `100`) are tightly coupled to the logic.  Finally, the `GetCoverage` function's numerous `if/else if` statements are overly complex and could be improved with a more maintainable approach, such as a lookup table or a function that maps scores to coverage.  Example: `if g.Score > thresholdAsNum { g.Coverage = 120 }`\n"
    },
    "gradingDetails": {},
    "hash": "9b61ac03434f46da6c955cf8516b83f64df634881dd9b60d02cb523e76be643a"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/gradeDetails.go",
    "grade": "F",
    "username": "Hlamb",
    "timestamp": "2025-01-14T18:55:29.194Z",
    "codeReview": {
      "review": "The code lacks proper SOLID principles.  The `GetCoverage` function is overly complex, with numerous `if/else if` statements, making it hard to maintain and understand.  The use of magic numbers (e.g., `aboveThreshold`, `threshold`) for thresholds makes the code less readable and maintainable.  Finally, the `GetCoverage` function's parameter `thresholdAsNum` is not used consistently with the other constants, making the code less clear and potentially error-prone.  Example:  `if g.Score > thresholdAsNum`.\n"
    },
    "gradingDetails": {},
    "hash": "4ca9e02473995e341c2d18af0c92f31911753868b3bcec89e19f071ef10c90f4"
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/gradeDetails.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-01-14T18:55:54.564Z",
    "codeReview": {
      "review": "**OWASP Top 10 Review (Snippet)**\n\n**Critical Areas of Concern:**\n\n1.  **Insecure Data Handling:**  The `GetCoverage` function lacks input validation.  `thresholdAsNum` is not validated, allowing arbitrary values to affect the coverage calculation.  This could lead to unexpected results or vulnerabilities if malicious input is used.  Example: `g.GetCoverage(-100)`.\n\n2.  **Improper Error Handling:**  No error handling is present.  If `g.Score` is not an integer, the program will likely panic.\n\n3.  **Unclear Logic:** The nested `if-else if` structure for coverage calculation is complex and hard to reason about.  The thresholds are numerous and not clearly defined, making it difficult to understand the intended behavior and potentially introducing bugs.  Example: The logic around `thresholdAsNum-1`, `thresholdAsNum-2`, and `thresholdAsNum-3` is unclear and could be simplified.\n"
    },
    "gradingDetails": {},
    "hash": "d47e7a86d22e48ad3190c88c0bdb74496bfe421038ec25a8563fc8908e258248"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/gradeDetails.go",
    "grade": "F",
    "username": "Hlamb",
    "timestamp": "2025-01-14T18:55:55.507Z",
    "codeReview": {
      "review": "The code lacks proper SOLID principles.  The `GetCoverage` function is overly complex, with numerous `if/else if` statements, making it hard to maintain and understand.  The use of magic numbers (e.g., `aboveThreshold`, `threshold`) for thresholds makes the code less readable and maintainable.  Finally, the `GetCoverage` function's parameter `thresholdAsNum` is not used consistently with the other constants, making the code less clear and potentially error-prone.  Example:  `if g.Score > thresholdAsNum`.\n"
    },
    "gradingDetails": {},
    "hash": "044c41ec9db9d8305eb746a74c0d2d64a88fc5721c57ff0a84023f42e2d68e1c"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/gradeDetails.go",
    "grade": "C",
    "username": "Hlamb",
    "timestamp": "2025-01-14T18:56:24.489Z",
    "codeReview": {
      "review": "The code violates the Single Responsibility Principle (SRP) as `GetCoverage` handles both calculating and setting coverage.  It also lacks flexibility;  the hardcoded coverage values (e.g., `120`, `100`) are tightly coupled to the logic.  Finally, the `GetCoverage` function's numerous `if/else if` statements are overly complex and could be improved with a more maintainable approach, such as a lookup table or a function that maps scores to coverage.  Example: `if g.Score > thresholdAsNum { g.Coverage = 120 }`\n"
    },
    "gradingDetails": {},
    "hash": "5dc2f33b08d64f7a60ab75085003f845c9bf90a4aff407b702d428b40d84b30d"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/gradeDetails.go",
    "grade": "F",
    "username": "Hlamb",
    "timestamp": "2025-01-14T19:55:32.210Z",
    "codeReview": {
      "review": "The `GetCoverage` method lacks clarity and maintainability.  The numerous `if/else if` conditions make it hard to understand the coverage calculation logic.  The `thresholdAsNum` parameter is not descriptive.  The method modifies the `GradeDetails` struct directly, violating the principle of immutability.  Example:  `if g.Score > thresholdAsNum { g.Coverage = 120 }`  This could be improved by creating a separate function to calculate coverage based on score and threshold.  A more descriptive parameter name (e.g., `threshold`) would also improve readability.\n"
    },
    "gradingDetails": {},
    "hash": "78de013089b77002740ca68806844cbd11589f93a542bc62e6c5588d448b902e"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/gradeDetails.go",
    "grade": "D",
    "username": "Hlamb",
    "timestamp": "2025-01-14T19:55:39.166Z",
    "codeReview": {
      "review": "This code has three critical areas of concern.  First, the `GetCoverage` function uses a series of `if/else if` statements to determine coverage based on score thresholds.  This is overly complex and hard to maintain.  Second, the coverage values (120, 100, etc.) are arbitrary and lack clear rationale.  Third, the `GetCoverage` function modifies the `GradeDetails` struct directly, violating the principle of immutability.  Example: `if g.Score > thresholdAsNum { g.Coverage = 120 }`.  A more robust solution would use a function to calculate coverage based on a clear scoring system.\n"
    },
    "gradingDetails": {},
    "hash": "c9bb42a237797619d684e8b08e21bd7e2e6fc5ef955e0f3616377311dc876443"
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/gradeDetails.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-01-14T19:56:02.249Z",
    "codeReview": {
      "review": "**OWASP Top 10 Review (Critical Areas)**\n\nThis code lacks input validation, potentially leading to **Injection flaws**.  The `GetCoverage` function's conditional logic for calculating coverage based on score is **unclear and brittle**.  The `thresholdAsNum` parameter is not validated, making it susceptible to **Improper Neutralization of Data Leading to SQL Injection** if used in a database query.  For example, if `thresholdAsNum` is manipulated, the coverage calculation could produce unexpected results.  The `GetCoverage` function's logic is also overly complex and could be simplified.  Example: `if g.Score > thresholdAsNum { g.Coverage = 120 } else { g.Coverage = 0 }`\n"
    },
    "gradingDetails": {},
    "hash": "1bc98e160c5e47594ff68b83bcb647d49a5e3df4fd1efe5c391c094cf096832a"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/gradeDetails.go",
    "grade": "D",
    "username": "Hlamb",
    "timestamp": "2025-01-14T19:56:07.297Z",
    "codeReview": {
      "review": "This code has three critical areas of concern.  First, the `GetCoverage` function uses a series of `if/else if` statements to determine coverage based on score thresholds.  This is overly complex and hard to maintain.  Second, the coverage values (120, 100, etc.) are arbitrary and lack clear rationale.  Third, the `GetCoverage` function modifies the `GradeDetails` struct directly, violating the principle of immutability.  Example: `if g.Score > thresholdAsNum { g.Coverage = 120 }`.  A more robust solution would use a function to calculate coverage based on a clear scoring system.\n"
    },
    "gradingDetails": {},
    "hash": "23ccfaeaaf1560a004d286068b6bac038eed8c648e18ddc428f50dca41ec762e"
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/main.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-04-09T17:18:38.088Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "e3a95bb113a8d398f51ce8da3394b613ad6b21b92cf75ddff254d735950c1d0b",
    "id": "eJytV99P3DgQ/leGSK2yNJvAPa60D9xSWiR0oFvaeyBI+JLJrlXHjmwvV47yv5/Gdn4toS1398KGzMw334w/25PHiBmDxnC5uVZKRIvo8o+T9dX8+vJqfnwUJVGhSlwpaVHaaBE1rPjCNgg14zKXueR1o7SFOJe5zZ2vwMrOC8Ezj1ujtHk0Ya64sKgnTRpZ2RoqwTbdc91BKdM+Gau53Lh/Z8Qoy+AzasOVBFWB3SKsLs7BKiVyWShpbGdeQh4dp0fpLw6KAqkq4MZFobT6ARrFpYVKaXhQO91BpbmsdrJwAfEMHolKlsEpVlwiEGdDr+xWo9kqUX7QrERYLJ0pXTvKcR519vmGHPIogTzyf9doPQ9ngc4zzaPZCPoKdYHSduDn0o6QG28n1KMRcDDQaj5HV0qYM8E2E5zJNGS6UnXN5gYbppnFEgQ31rVeKcHlBmJMN2kC68uL89MkiEs18+OjZCWQyflKlZikaToLue/98oyy/6qUiPMomChvxYRBSn/KTSPYg6+p2GlNzbifVkBbnpfmeFFCCmfql6NLc+JCvrciHnSl7lFTTydxi2B9Cbq1P0P3+lrtjFU1/xud8864nYjG/VoFXBZiV2JXPZeV0jWz1DKZW0fnk3NeAsm3VW5uHdQ1fnUyuhtuxm633MG77vkd3BEnh7XIJcAo4kY1lNLcks+lf17k8s6nqmqbnjWaSytk7Cg5AcnygktML3e22dl4lkBHaRbiyPWK4k6xYjthTewsT113rpg21EKHNhejneijySHu2/mRyVL07XJHjcwtr+BwKMLHfeJVrEy6tiVqTes32a43Js+dUMOLUIUy6fuv3MZHe9xXSt6jtk6lBri0Chj4ow2M4AUGYv3GXC5BcvFDch6QSqODTXIR1NpTOe6o+G1/Qft3sYSGukV3gokPu7R9884lt5wJEuNHbqzSD78jK1GTeTt8kQBqTYB0rKe/4V8jd7+IvHJOBz9X03utlQbeEqAehYwuB+oFvLkP7UetX6zXF0I82vgB+Y72qJiUfkIB/546sRywfhXdk6YRD+BvTwNMltBftE7qglk01h1uZ87LHUXuibp/0ZvDDmp7t4Rnoan/GcUE96AEUsZUmuvu/X6SPiKgx53sEhiDZ1mhZMU3AZdLtz/9uxfEtRoY/ydtBQ6vklYg2dEbcnYa8jz/u4Q88M8riFchJD3fSKUxPVOiJCWF7N++7du5QLPHrWF2O7XoV937eAIkmc4c2PYC6dFbgQxUMTozhcDC+vt4uBXcFMGVcDffSu1kINpvFCL7ufVob4SCiWInmFV7VTnd+/ln1bn4lXOpA4/JsGCjLD18H3qKlnFhKHAMlYan8Z5L4HA8UgbmrCjQGKW7iWZc6cnQPOCRwH6XWjkeDiekt2/hYJQh9RNLvEcmgWFNsx8K+cN4joKKcYElLGJwUv6eils6w2lruuYT79A6xj+ouAMcFt2+fF53GL5fW/nq2Zj3muJfhD0RAootFl8MNFROedBjDQePp/C509/wYBrBbTuDjuf54QQR5hIaSGi2Dt9e7dfQYGLo5xTvM4Ob2zDOPE6NMvQx0bZNo91p2QU8PnWHapbBmoiCkp6m2/RW8xpMwwo03RBDgmjZuZCeEXUqCV2hDzvurg8m3QxNoYGG++eG30KPdK15vaZEcWvsD/zA2n8eUYujJKq4QDoTo0WUfTKoTbZFqR8Eq//M6p2wvBGYjT596YMy3ajo6R8Ca52J"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/main.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-04-09T17:18:39.990Z",
    "codeReview": {
      "review": "This code lacks proper error handling for `toolsFlag` being `nil` (line 48).  The `parseTools` function (line 118) while handling empty input, doesn't validate for invalid input (e.g., non-comma separated values).  The code's reliance on multiple filters (latest grades, tools, paths) could be improved by composing them into a single filter for better maintainability and readability.  For example, combining `latestGradeFilter`, `toolFilter`, and `pathFilter` into a single filter object.\n"
    },
    "gradingDetails": {
      "dependencyInversionScore": "B",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "B",
      "openClosedScore": "B",
      "singleResponsibilityScore": "B"
    },
    "hash": "dade0b9ad8822d22799abd5048ae2e035e87363af53f23836c71cc532c645506",
    "id": "eJytV01v3DYQ/SsTAQm0jlZyelxgD+46TgwYtdF10kMUwKw02iVCkQJJuXEd//diSOprLSdx24tX1sy8eTN8JEf3ETMGjeFyd62UiFbR9vLi/DRKokKVuFHSorTRKmpY8YXtEGrGZS5zyetGaQtxLnObO1+BlV0WgmcesEZp82jGXHFhUc+aNLKyM1SC7frnuodSpnsyVnO5c/8uiFGWwUfUhisJqgK7R9hcnINVSuSyUNLY3ryGPHqTHqe/OCgKpKqAGxeF0uo7aBSXFiql4U61uodKc1m1snAB8QLuiUqWwSlWXCIQZ0Ov7F6j2StRvtOsRFitnSndOspxHvX25Y4c8iiBPPJ/t2g9D2eB3jPNo8UE+gp1gdL24OfSTpAbbyfU4wlwMNBqPkZXSpgzwXYznMk0ZrpRdc2WBhummcUSBDfWtV4pweUOYkx3aQJOT8nlHyfbq+W1apZvjpONQCaXG1VikqbpIuS+9cszyf6rUiLOo2CivBUTBin9KTeNYHe+pqLVmppxO6+ArjwvzemihBTONCxHn+bEhXxvRTzoRt2ipp7O4hbB+hR0Z3+E7vW1aY1VNf8bnXNr3E5E436tAi4L0ZbYV89lpXTNLLVM5tbR+eCc10Dy7ZSbWwd1jV+djG7Gm7HfLTfwun9+DTfEyWGtcgkwifikGkppPpPPpX9e5fLGp6pqm541mksrZOwoOQHJ8oJLTC9b27Q2XiTQU1qEOHK9orhTrFgrrImd5aHvzhXThlro0JZishN9NDnEQzvfM1mKoV3uqJG55RUcjUV4f0i8ipVJt7ZErWn9Ztv10uS5E2p4EapQJn37ldv4+ID7Rslb1Nap1ACXVgEDf7SBEbzAQGzYmOs1SC5+SM4DUml0sEkugloHKm96Kn7bX9D+Xa2hoW7RZWDioz7t0LxzyS1ngsT4nhur9N3vyErUZN6PXySAWhMgHevpb/jXxN0vIq+c04ufq+mt1koD7whQj0JGlwP1Cl7ehvaj1k/W6wshHl38iHxPe1JMSj+hgH9PnViOWD+L7knTiDvwt6cBJksYLlondcEsGusOtzPn5Y4i90TdvxjMYQd1vVvDo9DU/0xigntQAiljLs11//4wyRAR0ONedglMwbOsULLiu4DLpduf/t0T4tqMjP+TtgKHZ0krkOzpjTk7DXme/11CHvjnFcSrEJKe76TSmJ4pUZKSQvZv3w7tXKA54NYwu59b9Kv+fTwDksxnDmwHgQzonUBGqpicmUJgYf19PN4KborgSribb6NaGYgOG4XIfuw8uhuhYKJoBbPqoCqnez//bHoXv3IudeAxGxZslGWAH0JP0TIuDAVOodLwNN1zCRxNR8rAnBUFGqN0P9FMKz0Zm0c8EjjsUifHo/GE9OoVvJhkSP3EEh+QSWBc0+KHQn43naOgYlxgCasYnJS/p+KOznjamq/5xDt0jvEPKu4Bx0V3Lx/XHYbv51a+eTTmPaf4J2FPhIBij8UXAw2VU74YsMaDx0P43BlueDCN4LabQafz/HiCCHMJDSQ0W4dvr+5raDQxDHOK91nAp89hnLmfG2XoY6Jrm0bbatkH3D/0h2qWwZaIgpKeptv0VvMaTMMKNP0QQ4Lo2LmQgRF1KgldoQ877q4PJt0MTaGBhvvnE/8MA9K15vWWEsWdcTjwA2v/eUQtjpKo4gLpTIxWUfbBoDbZHqW+E6z+M6tbYXkjMJt8+tIHZbpT0cM/2gebzA=="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/filterTools.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-04-09T17:18:41.348Z",
    "codeReview": {
      "review": "**OWASP Top 10 Review (Short)**\n\n**Critical Areas of Concern:**\n\n1.  **Improper Input Validation:**  The code lacks robust input validation for the `tool` string.  A malicious user could potentially inject harmful characters or exploit the code.  Example: `strings.ToUpper(tool)` is vulnerable to command injection if `tool` is user-supplied.\n\n\n2.  **Insufficient Data Sanitization:**  The code doesn't sanitize the `value` string before using `strings.TrimPrefix` and `strings.TrimSuffix`.  This could lead to unexpected behavior or vulnerabilities if the input contains special characters. Example: `strings.TrimPrefix(value, \" \")`.\n\n\n3.  **Potential for Denial-of-Service (DoS):**  If the input `values` array is very large, the code could potentially lead to a DoS attack.  The nested loops and appending operations could consume significant resources.  Example: The `for` loop iterating over `values` and appending to `filteredHistories` in the `Filter` method.\n"
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 1,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "b6b690dd9e55ab2717958315d362310cf8324456ef9b81222fc70dc13d38aa99",
    "id": "eJytlEFvnDAQhf/KyIcKKhba60oc0lRtT82q2aiHOKpcGMCqsZE9JEWr/e+VMSy7JW0VqScs3rxvxn6GAxPOoXNS13tjFNuym69Xt7vN/ma3efuGJawwJV4bTaiJbVknih+iRqikIrRccy3bzliCiGtOnDmyUteOM65jr9LQIXwYiz3egdSEthIFwsE7ghQ9CtWjg/uH4E+gkY6Mlejg07yKlyXXxxPcYwMFHNm+oMOoVb0u4DM+LXIUXwwytrdIvdXwaqny7gUQEbxetBnw0nFDr3BkWC6vt/lSM05NlbHwLYGR72UrdI0wtRspnKYjTvdWtjuLlfwZ5kmAM+AsXlfd9tUfqui0t9/mojSM+27w25+tp21O9vWWchBdh7qMVlICzzZL03SEHc/iWHn/FsnFnL4F/OdQllgCcFiCaS5hnGQFp4M3d12HNppM6dX5ZxZDnq8qaRQmEqcss1j2BQI1CKUgAcqIclZn7LUp8Qs+SnyCHFrR3Qfqg9BDuFLnxR+tKKWu3yMJqdzzhsnysminBtO1OM6B/itSlrBKKtwJatiWZXcOrcsa1HZQov2etb0i2SnM/D9IYUWbQsksoKbH+C2ntWHHXy4FzQw="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/filterTools.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-04-09T17:18:41.750Z",
    "codeReview": {
      "review": "1. **String manipulation in a loop:**  `strings.TrimPrefix` and `strings.TrimSuffix` are called within the loop.  This creates unnecessary repeated string allocations and copies.  Example: `strings.TrimPrefix(value, \" \")`.  Should be done once outside the loop.\n\n2. **Unnecessary `ToUpper`:** Converting to uppercase for comparison (`strings.ToUpper`) is inefficient and potentially problematic if case-insensitive matching is not the intended behavior.  Example: `strings.ToUpper(history.AssessingTool)`.\n\n3. **Mutable `Histories`:** The `Filter` method modifies the input `histories` object. This violates the principle of immutability, making the code harder to reason about and potentially leading to unexpected side effects.  Example: `filteredHistories = append(filteredHistories, history)`.\n"
    },
    "gradingDetails": {
      "dependencyInversionScore": "A*",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "B",
      "openClosedScore": "B",
      "singleResponsibilityScore": "B"
    },
    "hash": "9a02da4fc060678cdfa7209d1e24146d311ea0ab74b74a4b8d580ab4e0e4e389",
    "id": "eJytlE9vnDAQxb/KyIcKKgr3lTi0ifpHqtqoSU5xFLkwBqvGtuwhKVrtd6/AsOyWtFWknrB4834z9jPsmQgBQ1CmubFWsx27/vr50yXLWGVrvLCG0BDbMSeqH6JBkEoTem64UZ2zniDhhhNngbwyTeCMm3RUaXAI76fikRtAGUIvRYWwHx1RSh6F7jHA3X30Z9CqQNYrDPBxWaXrkpvDET5iIwUC+b6i/aTJ3lTwBZ9WOUnPBpnae6TeG3i1Vo3uFZAQvF61BfDScWOveGRYr6935VozTU3SenjIYOKPshemQZjbTRRO8xHnN151Vx6l+hnnyYAz4CzdVl338g9VdNzbb3NRHsd9N4zbX6zHbc727ZZKEM6hqZONlMGzzfI8n2CHkzg23r9Fcjbn2AL+cyhrLBE4rMG05zBOSsLx4O2tc+iT2ZS/Pf2+UijLTSVNwkziVBQe675CoBahFiRAW1Ev6oK9sDV+w0eFT1BCJ9xdpN4LM8QrdVr8wYtameYSSSgdnjfMlpdFOzeYr8VhCfRfkbKMSaXxSlDLdqy4DehD0aLxgxbd96LrNSmnsRj/QRolvam0KiJqfkzfct5YdvgF0JHLTw=="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/gradeDetails.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-04-09T17:18:42.468Z",
    "codeReview": {
      "review": "**OWASP Top 10 Review (Snippet)**\n\n**Critical Areas of Concern:**\n\n1.  **Insecure Data Handling:**  The `GetCoverage` function's logic for calculating coverage based on score thresholds is overly complex and lacks clear justification.  This makes it hard to understand and maintain, potentially introducing vulnerabilities.  Example: `if g.Score > thresholdAsNum { g.Coverage = 120 }`.  This arbitrary value (120) could lead to unexpected behavior.\n\n2.  **Improper Input Validation:**  The `GetCoverage` function doesn't validate the `thresholdAsNum` input.  A malicious or unexpected input could lead to unexpected results or crashes.\n\n3.  **Lack of Error Handling:**  The `GetCoverage` function doesn't handle potential errors (e.g., negative scores).  This could lead to unexpected behavior or crashes.\n"
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 1,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "c7a118a1a943a50363f3cae64e346b3a06403ecf8cabda04eb3c58c8ea34efe5",
    "id": "eJyNU8Fq4zAQ/ZVBp2Rx4qRlWTCkULpsb2mgXfbiiyqPZbHKKEjjllLy74tkJ6sWF3LzvJk3b96M9S5kCBiCIf3knBWVePhz+7hbPD3sFuuVKIRyDd45YiQWlThI9VdqhNZYRl9TTfx2QLj3ssGfyNJYMMToW6kQ3muq+R75zr2glxpnhnhe03GKFiCw7xWPpJgAgAga0hF6VM4nyBDH+NT0FP8yFrdyjxklGoK8S1Jue1KwxddcfKaT4FBXQEhahriIRvO2BXBsOgTzjwbS5B659/QhkfDRUxXHSWLFgCZbCU2iI3oyU531x0S0lKrTHAk8jr7KErJdg5JW9VYyBuAOQZ3wA3qFxPHzWQZswFEqGDxLaoA7j6Fzthl3NdPwLfczz3Vm5+rbsO33cWnzYROmBb0crnYDn6rGlejledwNrK9WyQ6gDQgZe7O5iL76gn7zmb5YTzb4cTH/apL//WL+9ST/OudPO/x/blGI+GfsJHeiEuXvgD6UHZJ/s3L/XO57y+ZgsYyv12LLC2VNOTzaUme3XGonjv8Ap4NutA=="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/model.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-04-09T17:18:42.478Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "50c2022b2957e23982b2d36831f70989015a3ce4dbc233454ad4e0b506780738",
    "id": "eJyFk8Fu2zAMhl9F0MkGnHi7Btih7bD1MKDBkqKHKEBVh7aZSZQh0SuCou9eyFFdp1gyXQyQ//dTJqkXqUOAEJCatXNGLuTdw9VqOVvfLWdfv8hCVm4HN44YiOVCdrr6oxsQNRoGr0gR2s55FpkixUoyWlBSUR5TfOhA3GJg5w8isO8rFi9RdzUtKWIKqRHv53EfHC3U6cWUfIzkDzSw1Nwm6RmyTqoE/fR6B6PoHNREVSLuA3jSFi4TfVIlaI0WVqxtd1TFVsxj7BTid1WibtwOfsNfhOdBZnW3OZbbajqMVDWqJv+E1HwH1mjCOaw5USX0VodW/LcdrQ7H/r1+GiVCEJttGmvM1T1VIms/0rn4BZTlAinN2wP3noQByto8Of6TCiHDQuwjmYunuBxTvt3gdj52eX4NtfOQtZv9JHrBfvWsu4n94BwtCxEtxLfhUwxVBhNZjIskF7KMOxHKFsgfjLZPpe0NY2egjLMxUPOsMlgeH0ZpY2zeOPn6BvclJv4="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/gradeDetails.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-04-09T17:18:42.686Z",
    "codeReview": {
      "review": "The code violates the Single Responsibility Principle (SRP) as `GetCoverage` calculates coverage *and* sets the `Coverage` field.  It also lacks flexibility;  coverage is hardcoded to specific score ranges.  Finally, the `GetCoverage` function's logic is overly complex and could be simplified using a lookup table or a more structured approach.  Example: `if g.Score > thresholdAsNum { g.Coverage = 120 }`  should be replaced with a more maintainable approach.\n"
    },
    "gradingDetails": {
      "dependencyInversionScore": "B",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "B",
      "openClosedScore": "B",
      "singleResponsibilityScore": "B"
    },
    "hash": "a40a0fb3453dfbeaef8394637903bcaaf2f8cac00294528f55dc95ea3243940f",
    "id": "eJyNU11L7DAQ/StDnnYvdesHIhRWEOXKBVkF9a0vMZ2m4WYnSzJVRPa/S9LuGqXCvnXOzJkzZ6b5EDIEDMGQfnLOiko83t/9uxGFUK7Ba0eMxKISG6n+S43QGsvoa6qJ3zcIt142eIMsjQVDjL6VCuGjpppvka/dK3qpcWaI5zVtp2gBAvte8UiKCQCIoCEdoUflfIIMcYx3TXfxX2NxJdeYUaITyLsk5bYnBSt8y8VnOgkOdQWEpGWIi2g0b1sAx6ZDMP9uIE3ukXtP3xIJHz1VcZwkVgxospXQJDqiOzPVXn9MREupOs2RwO3oqywh2zUoaVVvJWMA7hDUDt+gV0gcP19kwAYcpYLBs6QGuPMYOmebcVczDX9yP/NcZ7avvgqrfh2XNh82YVrQi+Fql/CjalyJXuzHXcLJ6XGyA2gDQsZeLg+iH/9Cv/xJPzqZbHBxMP90kn9+MP9skn+W86cdfp1bFCL+GQ+SO1GJ8jmgD2WH5N+tXL+U696y2Vgs4+u12PKRsqYcHm2ps1sutBPbT6CebPc="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/pathFilter.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-04-09T17:18:44.215Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "f358e5f04c73f0dec1c458d3092bd49ea85b0d9faee331285bd5c700e33d9df1",
    "id": "eJx9VU1v3DYQ/SsTHZpVsRaT6wI+BEGDpIfEgF30YBkBVxpJ01BDgZy1sw383wuS+vRHbxQ5nPfmvRnqV6a9R++J2xtrTXbIvv394frq4ubb1cX7d9k+q2yNHy0LsmSHbNDVD90iNGQEXcklUz9YJ7AruZQyRhts5KIypOQ8oC+zdDJo6VRDBsNi2vTiiNsYk4dkSsGVlu5TzA7kwaEfLHs6GoTGuhGXuA0rhJDLw1F7rMEyUMvWYR3PPGiuobGmRueLkgOZdXIv7lQJ/ApExnuf4jWA27vIvAjf6+OUC27vEu2SH0fOX/FhlblyqCXgA+MDEHvRXCHYZg3/QNKBdAiDs/dUY/2/5JsTV1uU3YbzmvEeXuGbw+8rArFwh3JyDL8t+3F7q8gBANbf+21IQjk8QY1Bj4tEI2ryz4M9Sax+5aJ0WqDXUnWg+RzkCgFbVawLHUE1Rv1o5fgslVLwRSAVNnngDVUIlWXRxKF5LJvzi/jaIbCVKe8k/W5o1uLlYzm7jrxYR+jh87TKl2XS+F67QOLz89AgTSmhrb/vIaU6w+ESnOYWodumKYUaeDM0BfkvidyIfo6uB3L5FFnKBvAS9DAg17v17oyYpzuPo2GrtliHL07O+FB1WP3w8NChdOhAQ0v3yIumyc3YzOeNkcFH8pOHm9Po46uyL7XH/FNfH601qfYwjNb12tC/mMYrxAWJq/CM+PCMQWX7QTvyNhbLU3wdkIL+0ytV3Nhro30XwfIkjVLwMZQNutVhtLcNuvIz1jmbGXxbD+xolFLwpyXetmKcfdY97sM+w0zw2Wi+SnjeCNnjVxFiE6viq+4xz+emeiLA5SU8hZjbamwMcSd83jVKwfVgSBbdicVCTQ6rueGlJucD5/HpL+KV3ZbDHspMldki+R8/K3Oqk6NGewE02AcrqQGSt2HOm/GxVgpuOvKgvT/1OI71zAi5Tn033og6F/Ch/ufkY7YVW6g0gzbewhGBeBnIYmVzTW5xOdR2ezDIu7DKL97fTdKN0Zs38sXuGN/sWfFEaW1KujsHvGDKaMuLM91o4zEOc7bPmtHg7JCpvzw6rzpkdza6P6r+ZIQGg2rzS0/vtxrmmSxamz3+B+NvCTM="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/model.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-04-09T17:18:44.501Z",
    "codeReview": {
      "review": "The code defines a `History` struct and a `Histories` slice.  Three critical areas of concern are:\n\n1.  **Lack of validation:**  The `History` struct lacks validation for fields like `AssessingTool`, `FilePath`, `Grade`, and `Username`.  This could lead to unexpected behavior or errors later on.  Example:  No check for empty strings or invalid characters.\n\n2.  **Unclear use of `map[string]any`:**  Using `map[string]any` for `CodeReview` and `GradingDetails` is problematic.  It makes type checking and maintainability difficult.  Example:  `CodeReview[\"complexity\"]` might be an integer or a string, leading to runtime errors.\n\n3.  **Missing sorting context:** The sorting logic (`Less`) only considers `TimeStamp`.  If other criteria are needed for sorting (e.g., `Username` or `Grade`), the current implementation is insufficient.  Example:  No way to sort by `Grade` in ascending or descending order.\n"
    },
    "gradingDetails": {
      "dependencyInversionScore": "B",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "A*",
      "openClosedScore": "B",
      "singleResponsibilityScore": "B"
    },
    "hash": "7e32ff0dab2983d2078ac8697a5079b84d8da1b320c8f6c0a47b9d0c19629d04",
    "id": "eJyFk8Fu2zAMhl+F0MkGvPgeYIetxdYBBVos3SkKUNWhbWYSZUj0iqDouw9yVM8Zlk4XA+T//ZRJ6kWZGDFG4u7Be6vWanN3++1aVarxe7zyLMii1mowzU/TIbRkBYNmzeQGHwQKzVq0EnKoleYypeQ4INxQFB+OECWMjcBL0n1a1oKUIu7g7Tweoue1Pr+RVo+J/EIW7430WXqBbLMqQ1+D2eMsugR1SZWJHxEDG4fvE2NWZeiBHG7EuOGkSq1Ypdg5JG+qTF35PX7HX4TPk8yZYXsqtzN8nKlmVi3+ibi7RjFk4yWsO1Nl9MbEHv7bjt7EU/9e/xolYYTtLo815dqRGyj6P+kSbpGLEojzvAPKGBgsctGX2fGfVIwFVXBIZAlPaTmWfL+l3Wru8uoztj5g0W8Pi+g79ptnMyzsJ+dkWUGygI/Tp5qqTCaqmhdJrVWddiLWPXI4WuOeajdaocFinWZjsZUPjaX69DBql2KrzqvX3wu1JUE="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/collectGrades.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-04-09T17:18:45.748Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "3d15178e0113e6b9f3cfb5978a8e14a9455aea70ff50c9f557f94651846aeb38",
    "id": "eJydVE1vnDAQ/SuWDxVELCT9uCDlsN2o6SlZKWl6KFXlmgGsem1kD12tVvvfKzABr0k/1BueN/Pe83iGI2XWgrVC1Y9aS5rT+8/rh+3q8X67urqkCeW6hI1WCAppTlvGf7AaSCUkgilUofDQAtloKYHjrWElWCIUgqkYB3IsVIFnYNQIi9oIsOTj81dCsDFgGy1LYtEIVcfky9ch/waQCWkLdZq0hvjIKbTqKzqOTsphTPJOMtSGBOeRpuoUJ3ewD5gi/tvCOLjhIGYAO6PIq4BmwBZWcjKzJ33GyTcT1eQioAkk/69vzmjtR/LrIOfY28BKG/ItIU7l0GcZpmogs+x4LwV7j+q5i2NodHlIh2BC6jRogzvfdTswgjP5xGQH50XxZCL9ICRsGTZzZO3PahwaSm8BN/onGFZD9G/SUwPjke2sV9eEtS2oMvKjCZkV+yL3ltM41H8c23nCgiV5ydxANb2sULjgexgwj9Utw3E55mFmFC8cLYc6LDq+PLRh2kj9t9s4QbsXyBvXNhfhzAIp6PqioLl7lNHUOx8Nwbce+D4E33jgJgRfe+BNCF71pxIq1kk8Ry7nLaYJrcZZpTnNPlkwNmtAmYNku+/ZrpMoWglZ/y+VUOGKS5G5X2jG/S1Pa01PvwDXZBWX"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/pathFilter.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-04-09T17:18:46.257Z",
    "codeReview": {
      "review": "The `PathFilter` implementation has three critical areas of concern:\n\n1.  **Inefficient `isIgnored` function:**  The nested loops in `isIgnored` (checking ignored files and folders) have a time complexity of O(n*m), where n is the number of ignored files and m is the number of ignored folders.  This is inefficient for large lists of ignored items.  Consider using a Trie or a similar data structure to speed up the lookup.  Example:  Replace the `for` loops with a more optimized approach.\n\n2.  **Assumes file path structure:** The `isIgnored` function assumes that the `path` always ends with a file name.  If the `histories` can contain directory paths, this will lead to incorrect filtering.  Example: Modify the `isIgnored` function to handle directory paths correctly.\n\n3.  **Lack of error handling:** The code lacks error handling.  `filepath.Join` or `filepath.ToSlash` could potentially return errors.  Example: Add error handling to `filepath.Join` and `filepath.ToSlash` calls.\n"
    },
    "gradingDetails": {
      "dependencyInversionScore": "B",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "B",
      "openClosedScore": "B",
      "singleResponsibilityScore": "A"
    },
    "hash": "80dd796ba0e760c4809d87f253552d6931326a4fea56173df4ddaa3c6489f632",
    "id": "eJx9VU2P3DYM/SusD+m4mFjodYA9BGmCbFGkBXZ7Wi8KjU3bbGTKkOjdToP974Ukf+5Hb7JE8T2+R8rfM+09ek/c3lprslN28/tv179kx6yyNX60LMiSnbJBV990i9CQEXQll0z9YJ3AoeRSyhhtsJH3lSEllwF9maWTQUunGjIYFvOmF0fcxpg8JFMK/tDSfY7ZgTw49INlT2eD0Fg34RK3YYUQcnk4a481WAZq2Tqs45kHzTU01tTofFFyILNN7sWNlcD3QGS69zleA7i7j8yL8L09Trng7j7RLvlp4vwVHzeZK4daAj4wPgKxF80Vgm228I8kHUiHMDj7QDXW/0u+Gbnaoxx2nLeMj/AG3xx+2hCIhTuU0TG8W/fj9l6REwBsv4/7kIRyeoYag55WiSbU5J8HO0qsfuOidFqg11J1oPkS5AoBe1WsCx1BNUb9aOP4IpVScC2QCps98IYqhMqyaOLQPJbN5VV87RDYypx3lv4wNFvx8qmcQ0derCP08GVe5esyafygXSDx5WVokKaU0NZ/HSGlusDpCpzmFqHbpymFGvhhaAry14nchH6Jrgdy+RxZyg7wCvQwINeH7e6CmKc7T5Nhm7bYhq9OLvhQdVh98/DYoXToQENLD8irpsnN2MyXnZHBR/Kzh7vT6OObsq+1x/xzX5+tNan2MIzW9drQv5jGK8QFiavwjPjwjEFl+0E78jYWy3N8HZCC/vMrVdzaG6N9F8HyJI1S8DGUDbrVYbT3DbrxM9a5mBl82w7sZJRS8Ksl3rdinH3WPR7DPsNC8MVovkl42QjZ41cRYhOr4qvuMc+XpnomwNUVPIdY2mpqDHEjvuwapeBmMCSr7sRioSaH1dLwUpPzgfP09BfxymHP4QhlpspslfzTP5UZ6+So0V4ADfbBSmqA5Mcw5830WCsFtx150N6PPU5jvTBCrlPfTTeizgV8qP8efcy2YQuVZtDGWzgjEK8DWWxsrsmtLofa7k4G+RBW+fuf72fppujdG/lqd0xv9qJ4orQ1Jd1dAl4xZbLl1ZlutPEYhzk7Zs1kcHbK1J8enVcdsrsY3Z9VPxqhwaDa/dLT+62GZSaL1mZP/wF3JAd2"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/collectGrades.go",
    "grade": "A",
    "username": "Hlamb",
    "timestamp": "2025-04-09T17:18:46.320Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "dependencyInversionScore": "A*",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "A*",
      "openClosedScore": "A",
      "singleResponsibilityScore": "B"
    },
    "hash": "094d1274ce8c2753f20cf5b1d21cbf90117fee9ebf95da3b09e6a72ac8adc6ce",
    "id": "eJydVE1v1DAQ/SuWDyipwobPS6Qeyq4oSKggFbiQChln4lh47ciesFpF+99R4jTxOqUgbvG8mfeexzPpKXMOnJNafDZG0YLefvzwfkczyk0FW6MRNNKCtoz/ZAJILRWCLXWp8dgC2RqlgOO1ZRU4IjWCrRkH0pe6xDMwaaRDYyU48u7+KyPYWHCNURVxaKUWKfl2N+bvAJlUrtSnWWuMT5zS6KGi4+ilPMYU7xRDY0l0nmjqTnNyA4eIKeF/LEyjG45iFrCzmjyJaEZsZaUgC3s2ZJxCM4kgFxFNJPl/ffNGRRgpLqOcfrCBtbHke0a8ynHIskwLIIvsdC8Nh4DqvotTaHJ53IzBjIhN1AZ/vun2YCVn6itTHZwXpbOJzVup4BPDZolchUOaxoY214Bb8wssE5D8m/TcwHRiO+vVJWFtC7pKwmhGFsWhyL/lPA7i0bFdJixakofMjVTzy0qNK77bEQtY/TL06zGPM5N05Wg91HFR//DQxmkT9d9u4wXdQSJvfNt8hDMHpKRXFyUt/KNMpl6HaAy+CsA3MfgyALcx+CIAdzH4fDhVULNO4TnybNlimtF6mlVa0PyLA+vyBrQ9Krb/ke87hbJVkA//UgU1PuVK5v4XmvNwyzfC0NNvGs4T2g=="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/latestGrades.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-04-09T17:18:46.942Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "dbd7413890d34287d7e52c2bb4bba9b9e51919bc1375df3e750e3985e200ca44",
    "id": "eJyVVE1v2zAM/SuEDkO8unZ3zZBDFyAbsHUNkBQ7VMWg2rQjRJY8idlmpPnvgz/kjyZAsZMFkXx8fH7UkQnn0Dmp860xis3Z/Y/bzfp6e7++/nDDQpaYFJdGE2pic1aKZC9yhEwqQss111SVCCup02+C0NFnK1J0IDWhzUSCcOSa06pJH2fMdtKRsRIdfPGnYDhyferBJ8CO7CGhYxPNDjqB7/hnghuck2koWKSD1fBuHKlhBqSZyuH9OFxD/Sfvtlccw4NDEJCYojROEsIeqzlwtpIK14J2L7dj1Tmrq1TTpoWqYL6AQuxxVojy0ZGVOn/qQkHNmFNmLPwMYTfkW6FzhN2UC6c9NtEcNVpBuPScvmLVTVNFnlePF00Idi05yQzqMKYdlxDwr3Tk6gYT/o97rJ4++mjH5Lw+2soCNySKMvqEmbHYM+oDwVD9SqOmByw8ZZ91ag8nQOVwKH67tCk8taN2dlka/Rst3YlyazZKJjibwASdf+L4oryQWKzTQcBBy1+HxgbwLBymYDR40UHoFKaGaB158Zdl/a+abC60Jgm678T0vgSugLMXzuBqWjtMcTYvJO1NPUMhSjAZeIeSAQGuSRpuo476uXCd1HeihAuefr1CXXbLwe9CnxPCTQgK9Qg0CN5eiqZ5Z4hJgwWIskSdzsa3PUzgfeH1HGc12rGQeY3ZnMUPDq2Ld6htpUTxHBcHRbJUGNePqcKMrhMl4/YNjdXodYlyw07/ABd4GCw="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/latestGrades.go",
    "grade": "A",
    "username": "Hlamb",
    "timestamp": "2025-04-09T17:18:47.512Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "dependencyInversionScore": "A*",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "A*",
      "openClosedScore": "B",
      "singleResponsibilityScore": "A"
    },
    "hash": "0deeead86ae5c9dece5fdc93cf3aa152367b8e2996c4ac13abfa9c56e85cc237",
    "id": "eJyVVE2P0zAQ/SsjH1DDhoRzUQ9QVEDsAlJ3T+sV8iaT1KpjB3sKRN3+d5TEzse20opTLM/Mmzcvb3xkwjl0Tury1hjFlmz7/frLRxazzOS4NppQE1uyWmR7USIUUhFarrmmpkbYSJ1fC0JHn6zI0YHUhLYQGcKRa06bLn2asdhJR8ZKdPA5nKLxyPVpAJ8BO7KHjI5dtDjoDL7hnxludE6mo2CRDlbDq2mkhRmRFqqE19NwC/WfvPteaQp3DkFAZqraOEkIe2yWwNlGKvwhaPf0fio3Z22V6tr0UA0sV1CJPS4qUd87slKXDz4UtYw5FcbCzxh2Y74VukTYzblw2mMXLVGjFYTrwOkrNn6aJgm8BrxkRtC35CQLaMOYey4x4F/pyLUNZvzv99g8vAtRz+S8PrmVFW5JVHXyAQtjcWA0BKKx+plGXQ9YBcoh69QfToDK4Vj8cmlXeOpH9XZZG/0bLd2I+tZslcxwMYOJvH/S9KK8kFls00HAQctfh84G8Cgc5mA0BNFB6BzmhugdefGXFcOvmq0s9CaJ/Hdm+lACV8DZE2dwNa8dpzibF7L+pp2hEjWYAoJDyYAA1yWNt4mnfi6cl/pG1HDB089XyGf3HMIuDDkxvI1BoZ6ARtHLS9E194aYNViBqGvU+WJ6O8BEwRdBz2lWpx2LWdCYLVl659C6dIfaNkpUj2l1UCRrhWn7mCos6E2mZNq/oamavC5JadjpH1rTFm8="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/assessment/violations.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-04-09T17:18:48.249Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "64b726403c63f534efe1e069d284778b467cfe2e4e87a57cf6147755528b0e34",
    "id": "eJyNk1Fv1DAMx7+KiTTUol4Lr5XuYRqMF7SdtAEPBE2hdW8RqVM5vkPT6b47SrJ2x4YQb3Zs//x34hyUCQFDsLS99d6pVl1/Pb/ZrG6vN6t3b1WlOt/jhSdBEtWqyXQ/zRYhF41IokmTHSfPAoUmLTpVOBxk1TnbDNYJslY5NIwymz5Eq4zl8jAhfLHeGbGeAlgS5MF0CIeYu2FLUsRMOe/7Ja/oUYx1kDvUH9n0+D4dhVLT8SUYgvCukwz9ZIOctPz2/S+YR8qwow6u8NdT5/JUbcIxyo4JXi/nh+NpdbGHN0uohP8dI7P39TOxazDThNQXzyMVZFj5j96Pt5nRg2e4m6ugXQMb2iK86JiStdxVgMwxbxilvpwiaih8qG+kR+YKtLq0Dls4CxC3KRlpomRd+D1y3J5ig9whSdnCWQ9ak1aziDoCrsyIy0EELU6CLd4MLLM8OyR5r9ZA1s2atUStaWpHhVYfmD1Dkm5pC/t5SK3KuSA/ZvbiPUp+S1WpwTrcGLlXrWo+B+TQ3CPxgzPjj2bcObGTw+aP/X/6KM3SKtRbr46/AcSoQ5o="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/assessment/violations.go",
    "grade": "A",
    "username": "Hlamb",
    "timestamp": "2025-04-09T17:18:48.818Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "dependencyInversionScore": "B",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "A*",
      "openClosedScore": "A",
      "singleResponsibilityScore": "A"
    },
    "hash": "bb28fd78b64c183cd65c4324711e3df8783460d0819ac67e50667e623f32c56d",
    "id": "eJyNk1Fr3DAMx7+KZuhISpa8B+5htOsYlO6g217mUbxESc0cOci6G+W47z5sN+mtHaNvkiX99JctH5QJAUOwNH7x3qlW3X6+/nSpKtX5Hi88CZKoVs2m+2VGhJw9IYkmTXaaPQsUmrToVOFwkHeds81gnSBrlUPDJIvpQ7TKWC4PM8I3650R6ymAJUEeTIdwiLlbtiRFzJT3fb/mFT2KsQ5yh/ojmx4v01EoNR1fgiEI7zrJ0Gsb5KTl9x//wDxShh11cIO/nzqXp2oTjlF2TPB2PT8cT6uLPZyvoRJeO0Zm7+tnYjdg5hmpL55HKsiw8j+9H28zowfPcLdUQbsBNjQivOiYkrXcVYDMMW+YpL6aI2oofKhvpUfmCrS6sg5bOAsQ1ygZaaJkXfg9ctyeYovcIUnZwlkPWpNWi4g6Am7MhOtBBK1Ogq3eAiyzPDskeW82QNYtmrVErWlqR4VWH5g9Q5JuaYT9MqRW5VKQHzN78R4lv6Wq1GAdbo3cq1Y1XwNyaO6R+MGZ6Wcz7ZzY2WHz1/4/fZRmbRXq0avjH620Qd0="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/assessment/assessor.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-04-09T17:18:49.625Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "d8cb197188d94217a91923a55f3e22a24f518a9107e58e70eaa028b762c04231",
    "id": "eJylVV1v2zAM/CucgA725jpd92Y0A4IM21sboF33MA+DKtOOMVkKJLpDUeS/D7JkO3EyrB95EijeHUkfo0fGrUVra1XdaC1Zxq6+L65XpzdXq9MPZyxhQhe41IpQEcvYhovfvELwoAYV5SpXdbPRhiDKVU55h5BY0qmQ9aysJaHJmb8qG+qP2rpT7OD0sEFYCIHWagO1IjQlFwiPLnPRKUW0NmjXWhZgydSqSqBA4rW08OOn10i/Gl7gZx+N4U5rmavtAX+X5UhaQV5hyaVoJSdtwP92+cZLl3pba8mp1mqpW1cmDAEbtMpWCbjEP3tykRgljpMncP9v6ngcTlewQWqNgrd7Gt3NbjNZ6GbUTnzKtInsQLtL3O52FPEK3u3pxfCaL+MbKXktsYBsDmRa7CLawK+ewV0YriocGEOTdQm8SsdWvcBl26CpBZe3XLYYeUwair14AmLoJO6FhhLnUHJpsY/yKp1OMV0UxRAL4rHP34ZxdoW/CYxB4RjTytSKonhAhe/tgcc8vdT3aNxa/md3VmgEKnJpL96fhZcaJHc36fnrMWGLnrQFg/bRbZhQPr7G9FyMrp/wHvr/udP15ZMm3jn97On+95j38xBP+5qG7ZjE4QIOqhwczrl4sZkjif21jWOYz+GsJy4b8kaWKsrZpXZ/fGiBdHg7chYIB3eH/ermnxMPpWdzKKXm9PE86tqOYTYE9tQdaMOtdYge/GkHPBlA7GXcRnaofh+PTWO6kK63LxsXLCNt02sq0JgEchY8AiIMPoOT9Lw8OclzlbOkLyvesa3T7jzHEuYmtOK0ZhmbfbNo7GyNyjxI3tzNmlZSvZE423tdx2c4HLVJK822fwFzm+nf"
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/read/fileReader.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-04-09T17:18:51.445Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "8a949490c2520986e31f561736c71aec1d866bae5321112f4ce842e3878d5c64",
    "id": "eJydVlFv20YM/iucgBby4Mjbqwc/DG6xpSiSIGmxF71cJJ51i3Qn8Kh4RtH/PvBOZ0uZ0xjLS2SKR378+JG6b5nyHr03dvfFuTZbZ7d//f5wd/Xl9u7q11+yZVa5GrfOMlrO1lmvqie1QyBUdWlLa7reEUNe2pLL4Nui5quqNSttWkYqs/gKbeVqY3erv72zyag7To/Op6decSOHUR7EuJBEqxVsXY2fUfM9qhoJjGUkrSoB0yljPXCD4FWHpeVDj6/7f5NEYv3TeHZ0yBeQR7RFtBj0S0AiR4vSfh/Tj84pmgdC3zvrzWOLoB0FTozdBRhNdC6kWpBiihHUPIpnGipOgHp37xyD/HkmY3di3o6c3ilujuaE6Qb384AVoWL0oMDiHoz1rGyF4PQ8cRFOXzPsVfsUiTumrw1hJa7AhAjsQBtbBx9tyDMUqc2gXRu4YJD2DkKwH0NroBTQeMCu58NSHGvUamjZS1wJWQ1EaBn2jp6EvGP2GOceeSDrQdnYDzB6kt94sE5gDLYGZQ/7BgnB2BBZ8hel1YOt/sOTdHwuj9Tv2IuEPVhhvQHniz+Q93UuYmSjg/2nDVjTxhNyRqCKZQm64+KjxNN5mWllWqyl4B3y6wWv4d2+zELGkCT0uORAQjWQN8/YHmIvjgyIQzURyBGvuCXlHI/nqazLikCiCY4mxH0/o3E8lKSzDtI9chdfTvW7hhnYFD1lbWgpmU/ynsxomC5/frZAk+vCq9r4yj0j4YSjSyR1PuxMXo6gUlZ+P8b1l7SVNwQ/z2hZwIXLJbIex+WEd68meZcwkpPgjq1rqJhths0GyqzM3hRjSPN5MrynCidz403kPDT1nRdZNlTcT+WTZBGrDBiC7uLeLj45Y/MXIJdQZlOWy2xx1Pi2wepJWjFrA/5jPPtQstVuOo0PrDifJH9d0kaL/7W/cfxRwuUyYOnlD5iaAakdxqYERKAY+qDnkZsXOEZZ/yB4VJ6qqvjpnVX9yiIwGoSE4tp/MLLA3ur0GSLhcQhLU822ztkSTtvntkd7fkDEQf5P+yLel/Xlgn3pJPVb1HCNGil+ZLet85ifVPUBRe4B/aeH2xu5AzhQ4Fsz+yiK97OilApezmvMIqFCmYKkuMF9jE4y3jitc72B0buILvn7MfLit/9HRAx3iUrSKo2ep32aLTOBKS3J1tnqq0fyqwYtHVrVPa66oWXTt7iaXeFkzYWr2Hhr2Lns+7/Pd642"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/assessment/assessor.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-04-09T17:18:51.719Z",
    "codeReview": {
      "review": "This code has three critical areas of concern.  First, `AccessorGrade`'s `Assess` method uses a boolean (`failed`) that is unnecessarily inverted.  Second, `AccessorAverageCoverage`'s `Assess` method has a potential division by zero error if `details` is empty.  Third, both `Assess` methods lack clear error handling;  if `GradeNumericalValue` or `threshold` are invalid types, the program will panic.  For example, in `AccessorGrade`,  `ag.Calculator.GradeNumericalValue(detail.Grade)` and `ag.Calculator.GradeNumericalValue(threshold)` could fail if the input types are incorrect.\n"
    },
    "gradingDetails": {
      "dependencyInversionScore": "A*",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "B",
      "openClosedScore": "A",
      "singleResponsibilityScore": "B"
    },
    "hash": "aafb80f2fe9b28dfaa6b94e980efc896655149eb4bb37d6d82d13f45808ae7ea",
    "id": "eJylVe9r2zAQ/Vdugg5785zSfTPNIKRsDEZX6NYv0xiqfHbMZClI545S8r8PWbKTOBnrj3wSp3vv3Z3fRQ9MOIfONbr+ZoxiBbv++uXzBcuYNCUujSbUxAq2FvK3qBFCdouauOa6adfGEiRcc+I9QmFF76RqZlWjCC1n4apqaTga50+ph9P9GmEhJTpnLDSa0FZCIjz4zEWvlNDKolsZVYIj2+g6gxJJNMrBj59BI/9kRYkXIZrCrTGK680Bf5/lSTpJQWEplOyUIGMh/Hb5tpc+9aYxSlBj9NJ0vkwYAy5qVZ2WcIl/9uQSuZU4Tp7B3b+p0+1w+oItUmc1vN7T6G92myliN1vtLKRMmygOtPvEzW5HiajhzZ5eCi/5MqGRSjQKSyjmQLbDPmIs/BoY/IUVusaRMTbZVCDqfNtqELjsWrSNFOpGqA6TgMljseePQIydpIPQWOIcKqEcDlFR59Mp5ouyHGNRPA35mzjOvvBXkTEqHGO6so2mJB1R8XsH4DFPL80dWr+W/9mdK7QSNfm0Z+/PIkiNkrub9PT1mLAlj9qCUfvoNkwoH15ieiG3rp/wHvr/qdMN5ZMh0Tv99PH+D5i38xjPh5rG7ZjE4RwOqhwdLoR8tpkThcO1S1OYz+F0IK5aCkZWOuHs0vg/PnRAJr4dnEXC0d1xv/r5cxKx9GIOlTKC3p8lfdspzMbAnroHrYVzHjGAP+yAJwNIg4zfyB417OOxaUwX0vf2ce2DVWJcfk0lWpsBZ9EjIOPgCzjJz6qTE841Z9lQVrpjW6/de45lzE/oStCKFWz23aF1sxVqe69EeztrO0XNWuFs73XdPsPxaGxeG7b5C8hD6CI="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/read/findCodeLeft.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-04-09T17:18:52.818Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "3f2c264b9e0d6237aac81438d407b0640050e2df82277f8604b5a15a7a97b90b",
    "id": "eJx1U01v2zAM/SucgHU24FjbNUAOW9oBBQa0WDv0oosqU7EQmQooOVlQ5L8PsuN8bN1JND/fe6TfhI4RY3S0eg7Bi7l4ePn69Dh7fnicffksKmFCg8tACSmJudhos9YrBEbdKFLkuk3gBIUilZSwXVJiNEOcrI1OrbTOYzays8yFUoJ11CxDgx5t+omm5+i2CBE1mxYj8OTye7CBQUPjGE0KvAfSHTagRG2O9UpATw0yKMEhJCVqRbYn8/6QIudATOxoVUIxGhUgc+AS3jLurWaYmj/q1B6zM3SVkBnmC5hI1S/ar4eeFeShxeZcUIEjGyDE+rvzeE82VLDTfn3HPM0bnnGqSs6ewh8WQM5PAZUYU880hUfvYXykhGWLZg3OgumZkRIMIFz8v24/Bt1OYzPO+j7eOi5KuLk5s/umIw6USlgsrovP4K60WgzDp5CU8LR2G2gwGqTG0Qpsz6lFhkAGYYeftgg29NSAhk4n0/5F+QQl97l119yPOeR8/j7k68p08B8Fj4lKKDHsekgfF5pluyKwGNLerbRdqu/yymxxocWFyE3ACBQS4G8XE2ja71pkHA90Dh9j7pKvpbxAcBxxiaIaOR0UiUpkCbJTzIX8FZGjbJF473X3KrveJ7fxKKfqmfFO5l9UTuefIdarIA5/ACNda2o="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/read/fileReader.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-04-09T17:18:52.948Z",
    "codeReview": {
      "review": "This code has three critical areas of concern.  First, `NewHistoryReader` relies on `os.Getwd()`, which is not ideal for a reusable component.  Second, the error handling for `os.Stat` could be improved by checking for `os.IsNotExist` more explicitly.  Third, the code lacks clear separation of concerns; the `HistoryReader` handles both finding the `.codeleft` folder and reading the file, which blurs responsibilities.\n"
    },
    "gradingDetails": {
      "dependencyInversionScore": "A*",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "A",
      "openClosedScore": "B",
      "singleResponsibilityScore": "B"
    },
    "hash": "fa5ab27c5ac410bee67febbffc6a623635f6f428d0876abad3cfab0dcf4ede82",
    "id": "eJydVlFv4zYM/iucgDs4Q+a8Z8hTeth6KNqh3d78otpUrNWRDIpuFhzuvw+UrMTu0muwvtShKfLjx4+0vikdAoZg3e5P7zu1Vk8Pd7c3aqlq3+DWO0bHaq16Xb/oHQKhbipXObvvPTEUlau4ir4dGv6l7uzK2I6RKpVeoat9Y91u9XfwLhvNnvOjD/mp19zKYZQHMS4k0WoFW9/gHRp+RN0ggXWMZHQtYPbaugDcIgS9x8rxscf3/b9JIrH+bgN7OhYLKBLaMlkshiUgkadF5b6P6UfnHC0AYei9C/a5QzCeIifW7SKMNjmXUi1IMeUIah4lMA01Z0C9f/SeQf4Ck3U7MW9HTv/Q3J7MGdM9HuYBa0LNGECDwwNYF1i7GsGbeeIynr5lOOjuJRF3St9YwlpcgQkR2IOxrok+xlJgKHObwfgucsEg7R2E4DCGNkA5oA2A+56PS3Fs0Oih4yBxJWQ9EKFjOHh6EfJO2VOcR+SBXADtUj/Amkl+G8B5gTG4BrQ7HlokBOtiZMlfVs4Mrv4PT9LxuTxyv1MvMvZohfUGfCh/Qz40hYiRrYn2nzbgbJdOyBmBKpYlmD2XXySeKSpltO2wkYJ3yO8XvIZPh0rFjDFJ7HHFkYR6oGBfsTumXpwYEId6IpATXnHLyjkdL3JZ1xWBRBMcbYz7eUbjeChLZx2le+IuvZzqdw0zsDl6ztrSUjKf5T2Z0Thd4fJsgSG/j68aG2r/ioQTjq6R1OWwM3l5glo7+f2c1l/WVtES/DyjZQFXLpfEehqXM96DnuRdwkhOhju2rqVythk2G6hUpT4UY0xzNxnec4WTuQk2cR6b+imILFsqH6fyybJIVUYMUXdpb5dfvXXFG5BLqNSU5UotThrftli/SCtmbcB/bOAQS3bGT6fxiTUXk+TvS9oa8b8N956/SLhCBiy//AFTMyCNx9SUiAg0Qx/1PHLzBsco6x8ET8rTdZ2+ubOq31kE1oCQUN6GGysL7KNOXyASnoe4NPVs61ws4bx9Hnp0lwdEHOT/tC/ifV1frtiXXlJ/RA03aJDSR3bb+YDFWVU3KHKP6L8+PdzLHcCDhtDZ2UdRvF815VTwdl5TFgkVyxQk5T0eUnSS8cZpnesNjN5lcik+j5EXv/4/IlK4a1SSV2nyPO9TtVQCU1qi1mr1V0AKqxYdHTu9f17th45t3+FqdoWTNRevYuOtYefV938BC8OseQ=="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/read/configReader.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-04-09T17:18:54.550Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "4604575174e0b320e5e43c9bd21a1dc6f67065902e04db78c4490b6992259770",
    "id": "eJydVk1v2zgQ/StTAS3khSPtXl34ULjBIkWRBE6LXnRhqKHNjUwaw1G9RtH/vhhSn9mkCZpLbGr43puZNyP/yFQIGIJ1uy/eN9kqu/n24e724svN7cVff2bLTPsaN94xOs5W2VHpB7VDIFR15SpnD0dPDHnlKq5ibIOGL3RjSz4fMVRZeoJO+9q6XflP8K4/NAfuP/oh8qh4XxrboHyQw4XwlCVsvDN2t0VVI4ENQBiO3gV73yAYT1GSdTvgPYKOsYWQgWAVlRM5c4zA1GqGH8K7xaPfes8gf4HJup0cb7qEbhXvh+OfnaBrPM3wNKFiDKDA4QmsC6ycRvBmRlvEu1cMJ9U8hKh2IK8toWZPZ2BCBPZgrKtjjLEUGIq+wmB8E+vAIKVtHSOFDtoA9YA2AB6OfF5KYI1GtQ0HwY1FaonQMZw8PUjhBvaEs0VuyQVQDpDIE1gz4bcBnBcZratBufNpj4RgXUQW/qJypnX6cZXyBeR/TA+WCX2R+tArj6ewWoMPxd/IpzoXG7A18fzNGpxt0g25I0LlZAnmwMWl4Jm8yoyyDdaS7g75+XRX8PZUZZExksT+VhxLoFsK9js259SJIX8J0BNzDHolrHfNcD3v03pdEkg00aEj7rtpzbo7vW9W0bVD6dLDqXVXMNPag/ekmpZCPDpbWBJfnKrw5EyBIX+IT0ZXPGehbgLGoVDRNaOxniSYecwTaOXk+31aP73Bck0wc9Rioj/aLW6iIh3M7VaWcOlCS/goD9k9Qh+Qu45pKmbLYL2GKquyFz0YMT9PJnbMaDIswcapp9jMt0HcqKnYTl3TuyFmESVEt6U9WXzy1uWPNC5BNvJQ0ypbDMbe7FE/SN2nNcd/beAQ83XGTyfwjhXnI/PzLrZGwq/CtedLQctlpvqHv6jSVEbtMfU96gGVujGUZa6iM/IvoJPFlNbpJTfN+JnBtwakAMVV+GhlX73U4v/XEO7buCHVbMk8pX/cNTdHdE+OgTyX/9OGSPCrGvKK3eiF+IWqcI0GKb1KN40PmI9e+ohi8Sj9093NNVjHfpz49JKV0O+KOhqYDmRCF4iYnCgorvGUUCkXyml6qzV00UUKyd8l0MX730s/ob3CFh1WRzduzGyZiUjpQ7bKyq8BKZR7dHRu1OG+PLQN22OD5ezHkSywUk9/Fux89vM/1K9prA=="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/read/findCodeLeft.go",
    "grade": "C",
    "username": "Hlamb",
    "timestamp": "2025-04-09T17:18:54.743Z",
    "codeReview": {
      "review": "1. **Missing Error Handling:** The `filepath.Walk` function's error is not checked within the loop.  This could lead to silent failures if there's an issue during traversal.  Example:  `if walkErr != nil { return walkErr }` should be outside the loop.\n\n\n2. **Inconsistent Naming:**  `.codeLeft` in the code and `.codeleft` in the function signature.  This inconsistency should be fixed for better readability and maintainability.\n\n\n3. **Unnecessary Variable:** The `codeleftPath` variable is assigned within the loop but not used until after the loop.  This is unnecessary and can be simplified.\n"
    },
    "gradingDetails": {
      "dependencyInversionScore": "F",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "B",
      "openClosedScore": "F",
      "singleResponsibilityScore": "A*"
    },
    "hash": "56aade082dc40cf6f9d0f65cd4eb959577f3002870ca343cdf1bf64254733b75",
    "id": "eJx1U02L2zAQ/StTQbc2uNY94EuTLQQWWrotveiiyqNYRB6ZkZw0LPnvRXacTdrtSeP5fO/N+EXoGDFGR7vvIXixEs9fnrYbUQkTWlwHSkhJrMSgzV7vEBh1q0iR64fACQpFKilh+6TEbIa4WINOnbTOYzays8yFUoJ11K5Dix5t+oZm5OgOCBE1mw4j8OLyJ7CBQUPrGE0KfALSPbagRG0u9UrASC0yKMEhJCVqRXYk8/aQIudATOxoV0IxGxUgc+ASXjLug2ZYmn/VqbtkZ+gqITOsGlhI1T+13089K8hDi+G1oAJHNkCI9WfncUs2VHDUfv/IvMybnnmqSs5ew+8aIOeXgEqMaWRawrP3PD9SwrpDswdnwYzMSAkmEC7+X7enSbfr2Iyz3saN46KEh4dXdp90xIlSCU1zX/wK7k6rZhq+hKSE570boMVokFpHO7Ajpw4ZAhmEI344INgwUgsaep1M9xflK5TcZ+PuuV9yyPn8fc7XlengPwpeEpVQYtr1lD4vNMt2R6CZ0t6stH2qH/PKbHGjxY3IbcAIFBLgbxcTaDodO2ScD3QF72Pukq+lvEFwGXGLopo5nRWJSmQJslOshPwRkaPskPjkdf9L9qNPbvAol+qPxjuZf1G5nH+GWO+COP8BPzxprQ=="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/types/model.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-04-09T17:18:55.934Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "0a4103f249f2ea8d7289bbbbba73d28d453cc772d47ba9da254701dca2984213",
    "id": "eJxlUk1PwzAM/StWzmyF625oEhISYoMNcSBIZK3bBtK4xK7QhPbfUdIPbSWn6Pm9Zzt5v8owI7P11Z7IqZXavN7utov9Zru4uVZXKqcC1+QFvaiVak3+ZSoEObbI2mufZbAmX9oKArYBGb0wSI3AErpcuoBAZQLyRFt+MnkorcOl9tFllPd8+NVey74OyDW5IqLWV/ARVSutZCxo9RGJO8y7YOUIF3Itmx/DLRyI3CSlCA2y04TyYDAUnjrjot2l246cLSCeC0eO8CDU8mAF98gyI7kBnnjb8IymOM7N2h6eaGuHxq+pwEtaPsL/NvnuRx/w+8pTwNked9YhA8Dbe7wBTNr4HTy1viNXYGB4e5+9ftkX/rW2qVmCT0MmUoOzRJj05SAEB4SeX4D158EY4pCU53M/mgbnOfCmGV9ga6Sel1sj9TiOukrrRZpaqeyFMXBWow9HZ5pD1nRObOswizl3WMoidzZL8c6aCC0rUqc/1DUlSw=="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/read/configReader.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-04-09T17:18:56.198Z",
    "codeReview": {
      "review": "This code has three critical areas of concern.  First, `NewConfigReader` relies on a recursive function (`findCodeleftRecursive`) which is not ideal for large repositories.  Second, error handling is not consistent; some errors are wrapped, others are not.  Third, the code lacks clear separation of concerns; the `ConfigReader` handles both finding the `.codeleft` folder and reading the config file.  Example: `findCodeleftRecursive` function should be extracted.  Example:  Error handling in `ReadConfig` should be more consistent. Example:  Create a separate function to handle finding the `.codeleft` folder.\n"
    },
    "gradingDetails": {
      "dependencyInversionScore": "B",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "B",
      "openClosedScore": "B",
      "singleResponsibilityScore": "A"
    },
    "hash": "79764b3a59c6eee5755fddfa57cff06c36100cec22970c2abf328a7958947afc",
    "id": "eJydVk1v2zgQ/SuzAlrIC69098InJyhSFEnhdG+6MNTQZiOTwnBU1yj634sh9ZkmTbC5xKaG772ZeTPyj0yFgCFYd/jifZNtsvu7TzdX2TrTvsadd4yOs03WKv2oDgiEqq5c5eyp9cSQV67iKsY2aPgf3diSLy2GKktP0GlfW3covwbvhkNz4uGjHyNbxcfS2AblgxyuhKcsYeedsYc9qhoJbADC0HoX7EODYDxFSdYdgI8IOsYWQgaCVVRO5CwxAlOnGX4I7x5bv/eeQf4Ck3UHOd71CX1WfByPf/aCbvG8wNOEijGAAodnsC6wchrBmwVtEe/eMJxV8xii2pG8toSaPV2ACRHYg7GujjHGUmAohgqD8U2sA4OUtnOMFHpoAzQA2gB4avmylsAajeoaDoIbi9QRoWM4e3qUwo3sCWeP3JELoBwgkSewZsZvAzgvMjpXg3KX8xEJwbqILPxF5Uzn9NMq5SvI/54frBP6KvVhUB5PYbMFH4oPyOc6FxuwNfH8ry0426QbckeEyskazImLa8EzeZUZZRusJd0D8svpbuDducoiYySJ/a04lkB3FOw3bC6pE2P+EqBn5hj1StjgmvF6PqT1tiSQaKZDR9z385r1dwbfbKJrx9Klh3PrbmChdQAfSDWthXhytrAkvjhV4dmZAkP+FJ9MrnjJQv0ETEOhomsmYz1LsPCYJ9DKyfeHtH4Gg+WaYOGo1Ux/tFvcREU6WNqtLOHahY7wSR6ye4Q+IPcd01QslsF2C1VWZa96MGJ+mk3slNFsWIKNU0+xme+CuFFTsZ+7ZnBDzCJKiG5Le7L46K3Ln2hcg2zksaZVthqNvTuifpS6z2uO323gEPN1xs8n8J4V5xPzyy62RsJvwq3na0HLZaaGh3+o0lxG7TH1PeoBlboxlmWpojfyH6CTxZTW6e02z/iFwbcGpADFTbiysq9ea/HvNYSHLm5ItVgyz+mfds1di+7ZMZDn8n/eEAl+U0PesBu9EL9SFa7RIKVX6a7xAfPJS1coFo/SP97f3YJ17KeJTy9ZCf2mqKeB+UAmdIGIyYmC4hbPCZVyoZynt9lCH12kkPx9Al39+//ST2hvsEWP1dNNGzNbZyJS+pBtsvK/gBTKIzq6NOr0UJ66hm3bYLn4cSQLrNTznwUHn/38BS4eZ+8="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/types/model.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-04-09T17:18:58.099Z",
    "codeReview": {
      "review": "The code defines a `Config` struct for configuration, which is good for organization.  However, three critical areas of concern are:\n\n1.  **Lack of validation:**  The `Config` struct lacks validation for the `Threshold` string, which could lead to unexpected behavior if the value isn't correctly formatted.  Example:  No check for `Threshold` being a valid number.\n\n2.  **Overly verbose `Quality` struct:**  The `Quality` struct contains multiple boolean flags, which could be simplified into a single, more descriptive field.  Example:  Instead of `Solid`, `LiteTest`, `PrReady`, `CleanCode`, consider a `QualityLevel` enum or a single `QualityScore` field.\n\n3.  **Missing error handling:**  The code doesn't handle potential errors during JSON decoding or configuration usage.  Example:  No `if err != nil` checks after decoding `config.json`.\n"
    },
    "gradingDetails": {
      "dependencyInversionScore": "A",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "A",
      "openClosedScore": "B",
      "singleResponsibilityScore": "A*"
    },
    "hash": "465ccd1135903488339c07dfa043c460c5152a236992c2d4aa13e4793cd763ac",
    "id": "eJxlUstqwzAQ/JVF5za+55oSCJS+kp6iQBR7bauVta52TQkh/14kP0hcncTszOyuNBdlmJHZ+mpH5NRSbV+fN0/qQeVU4Iq8oBe1VK3Jv02FIOcWWXvtswxW5EtbQcA2IKMXBqkRWEKXSxcQqExAnmiLLyYPpXW40D66jPKeDxfttezqgFyTKyJqfQXHqFpqJWNBq2MkbjHvgpUz3Mm1vP4abuFE5CYpRWiQXSeUB4Oh8N4ZF+3u3bbkbAHx3DlyhAehlmcruEOWGckN8MR7Cx9oivPcrO3hibZyaPyKCryn5SP8b5OffvQB31SeAs72WFuHDAD7Q7wBTNr4HTy1XpMrMDDsD7PXL/vCv9Y2NUvwdchEanCTCJO+HITghNDzC7D+NhhDHJLydu4X0+A8B9404wu8Gann5dZIPY6jHtJ6kaaWKvtkDJzV6MPZmeaUNZ0T2zrMYs4dlvKYO5uleGdNhBYVqesfT1Qjjg=="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/html.go",
    "grade": "A",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:03:28.628Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "dependencyInversionScore": "B",
      "interfaceSegregationScore": "A*",
      "liskovSubstitutionScore": "A*",
      "openClosedScore": "B",
      "singleResponsibilityScore": "B"
    },
    "hash": "4fc054b64feb4b57521ca15237782f7f6a553f50a29aa7854d6d270e903dd268",
    "id": "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"
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/assessment/violations.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:19:14.216Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "77b1d903effbd9115ee9da262c502599802b5e2730cf39f401e98ca15b8f6098",
    "id": "eJyNk1Fv1DAMx7+KiTTUol4Lr5XuYRqMF7SdtAEPBE2hdW8RqVM5vkPT6b47SrJ2x4YQb3Zs//x34hyUCQFDsLS99d6pVl1/Pb/ZrG6vN6t3b1WlOt/jhSdBEtWqyXQ/zRYhF41IokmTHSfPAoUmLTpVOBxk1TnbDNYJslY5NIwymz5Eq4zl8jAhfLHeGbGeAlgS5MF0CIeYu2FLUsRMOe/7Ja/oUYx1kDvUH9n0+D4dhVLT8SUYgvCukwz9ZIOctPz2/S+YR8qwow6u8NdT5/JUbcIxyo4JXi/nh+NpdbGHN0uohP8dI7P39TOxazDThNQXzyMVZFj5j96Pt5nRg2e4m6ugXQMb2iK86JiStdxVgMwxbxilvpwiaih8qG+kR+YKtLq0Dls4CxC3KRlpomRd+D1y3J5ig9whSdnCWQ9ak1aziDoCrsyIy0EELU6CLd4MLLM8OyR5r9ZA1s2atUStaWpHhVYfmD1Dkm5pC/t5SK3KuSA/ZvbiPUp+S1WpwTrcGLlXrWo+B+TQ3CPxgzPjj2bcObGTw+aP/X/6KM3SKtRbr46/AcSoQ5o="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/assessment/violations.go",
    "grade": "A",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:19:14.263Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "dependencyInversionScore": "B",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "A*",
      "openClosedScore": "A",
      "singleResponsibilityScore": "A"
    },
    "hash": "30dc7be84c3fa50e30de5fb7a9fc6ba323847e82c7c66b170c5da9e79307163e",
    "id": "eJyNk1Fr3DAMx7+KZuhISpa8B+5htOsYlO6g217mUbxESc0cOci6G+W47z5sN+mtHaNvkiX99JctH5QJAUOwNH7x3qlW3X6+/nSpKtX5Hi88CZKoVs2m+2VGhJw9IYkmTXaaPQsUmrToVOFwkHeds81gnSBrlUPDJIvpQ7TKWC4PM8I3650R6ymAJUEeTIdwiLlbtiRFzJT3fb/mFT2KsQ5yh/ojmx4v01EoNR1fgiEI7zrJ0Gsb5KTl9x//wDxShh11cIO/nzqXp2oTjlF2TPB2PT8cT6uLPZyvoRJeO0Zm7+tnYjdg5hmpL55HKsiw8j+9H28zowfPcLdUQbsBNjQivOiYkrXcVYDMMW+YpL6aI2oofKhvpUfmCrS6sg5bOAsQ1ygZaaJkXfg9ctyeYovcIUnZwlkPWpNWi4g6Am7MhOtBBK1Ogq3eAiyzPDskeW82QNYtmrVErWlqR4VWH5g9Q5JuaYT9MqRW5VKQHzN78R4lv6Wq1GAdbo3cq1Y1XwNyaO6R+MGZ6Wcz7ZzY2WHz1/4/fZRmbRXq0avjH620Qd0="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/assessment/assessor.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:19:14.321Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "dfa34dcc6991f6e13356589c1d83f9836d2095e4c17aa9b860a74f7751aafbc4",
    "id": "eJylVV1v2zAM/CucgA725jpd92Y0A4IM21sboF33MA+DKtOOMVkKJLpDUeS/D7JkO3EyrB95EijeHUkfo0fGrUVra1XdaC1Zxq6+L65XpzdXq9MPZyxhQhe41IpQEcvYhovfvELwoAYV5SpXdbPRhiDKVU55h5BY0qmQ9aysJaHJmb8qG+qP2rpT7OD0sEFYCIHWagO1IjQlFwiPLnPRKUW0NmjXWhZgydSqSqBA4rW08OOn10i/Gl7gZx+N4U5rmavtAX+X5UhaQV5hyaVoJSdtwP92+cZLl3pba8mp1mqpW1cmDAEbtMpWCbjEP3tykRgljpMncP9v6ngcTlewQWqNgrd7Gt3NbjNZ6GbUTnzKtInsQLtL3O52FPEK3u3pxfCaL+MbKXktsYBsDmRa7CLawK+ewV0YriocGEOTdQm8SsdWvcBl26CpBZe3XLYYeUwair14AmLoJO6FhhLnUHJpsY/yKp1OMV0UxRAL4rHP34ZxdoW/CYxB4RjTytSKonhAhe/tgcc8vdT3aNxa/md3VmgEKnJpL96fhZcaJHc36fnrMWGLnrQFg/bRbZhQPr7G9FyMrp/wHvr/udP15ZMm3jn97On+95j38xBP+5qG7ZjE4QIOqhwczrl4sZkjif21jWOYz+GsJy4b8kaWKsrZpXZ/fGiBdHg7chYIB3eH/ermnxMPpWdzKKXm9PE86tqOYTYE9tQdaMOtdYge/GkHPBlA7GXcRnaofh+PTWO6kK63LxsXLCNt02sq0JgEchY8AiIMPoOT9Lw8OclzlbOkLyvesa3T7jzHEuYmtOK0ZhmbfbNo7GyNyjxI3tzNmlZSvZE423tdx2c4HLVJK822fwFzm+nf"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/assessment/assessor.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:19:14.372Z",
    "codeReview": {
      "review": "This code has three critical areas of concern.  First, `AccessorGrade`'s `Assess` method uses a boolean (`failed`) that is unnecessarily inverted.  Second, `AccessorAverageCoverage`'s `Assess` method has a potential division by zero error if `details` is empty.  Third, both `Assess` methods lack clear error handling;  if `GradeNumericalValue` or `threshold` are invalid types, the program will panic.  For example, in `AccessorGrade`,  `ag.Calculator.GradeNumericalValue(detail.Grade)` and `ag.Calculator.GradeNumericalValue(threshold)` could fail if the input types are incorrect.\n"
    },
    "gradingDetails": {
      "dependencyInversionScore": "A*",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "B",
      "openClosedScore": "A",
      "singleResponsibilityScore": "B"
    },
    "hash": "15b8b01bdbdc35988b9dca1d137d93ce6a6bc14cbcd8066a936818ed377f8312",
    "id": "eJylVe9r2zAQ/Vdugg5785zSfTPNIKRsDEZX6NYv0xiqfHbMZClI545S8r8PWbKTOBnrj3wSp3vv3Z3fRQ9MOIfONbr+ZoxiBbv++uXzBcuYNCUujSbUxAq2FvK3qBFCdouauOa6adfGEiRcc+I9QmFF76RqZlWjCC1n4apqaTga50+ph9P9GmEhJTpnLDSa0FZCIjz4zEWvlNDKolsZVYIj2+g6gxJJNMrBj59BI/9kRYkXIZrCrTGK680Bf5/lSTpJQWEplOyUIGMh/Hb5tpc+9aYxSlBj9NJ0vkwYAy5qVZ2WcIl/9uQSuZU4Tp7B3b+p0+1w+oItUmc1vN7T6G92myliN1vtLKRMmygOtPvEzW5HiajhzZ5eCi/5MqGRSjQKSyjmQLbDPmIs/BoY/IUVusaRMTbZVCDqfNtqELjsWrSNFOpGqA6TgMljseePQIydpIPQWOIcKqEcDlFR59Mp5ouyHGNRPA35mzjOvvBXkTEqHGO6so2mJB1R8XsH4DFPL80dWr+W/9mdK7QSNfm0Z+/PIkiNkrub9PT1mLAlj9qCUfvoNkwoH15ieiG3rp/wHvr/qdMN5ZMh0Tv99PH+D5i38xjPh5rG7ZjE4RwOqhwdLoR8tpkThcO1S1OYz+F0IK5aCkZWOuHs0vg/PnRAJr4dnEXC0d1xv/r5cxKx9GIOlTKC3p8lfdspzMbAnroHrYVzHjGAP+yAJwNIg4zfyB417OOxaUwX0vf2ce2DVWJcfk0lWpsBZ9EjIOPgCzjJz6qTE841Z9lQVrpjW6/de45lzE/oStCKFWz23aF1sxVqe69EeztrO0XNWuFs73XdPsPxaGxeG7b5C8hD6CI="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/main.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:19:15.522Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "df85f1aac382316398217b59a4e31d9c6b4cbbc3ed7f8b8a6526e5bb71096dbf",
    "id": "eJytWN9v2zgM/lc4AxucznHal3vIIQ+9dN0KFGuxdLuHeUB1Np0KkyVDkrvluv7vB0ryr9Rd17t7WVyR/PiRoihqdxEzBo3hcnullIiW0cWfx5vL+dXF5fzoMEqiXBW4VtKitNEyqln+lW0RKsZlJjPJq1ppC3EmM5s5XYGlneeCLzxuhdJm0YS45MKinhRpZEUrKAXbdt9VB6VM+2Ws5nJrHgEidiSaEdnFAj6hNlxJUCXYG4T1+RlYpUQmcyWN7cQryKKj9DD9zcGSIQUM3DgrlFbvoFZcWiiVhp1qdAeVZrJsZO4M4hncEa3FAk6w5BKBwjG0ZG80mhslireaFQjLlROlGxdNnEWdfL4lhSxKIIv8vxu0noeTQKeZZtFsBH2JOkdpO/AzaUfItZcT6uEIOAhoox+iKyXMqWDbCc4kGjJdq6pic4M108xiAYIb61KvlOByCzGm2zSBzcX52UkS6k7V86PDZC2QyflaFZikaToLvm/99oy8/6GUiLMoiMhvyYRBcn/CTS3YzseUN1pTMm6nK6ANz1fteFOCCyfqt6Nzc+xMfrYjHnStblFTTidx8yB9DLqVP0TPNTKLH1yt72N72bw9CAPotZMAAy9r89Gf2gDvy3fdGKsq/jc6pca4HoDG/VoFXOaiKbBLLpel0hWztCMys47RR6e8Ajod7cHIrIO6wu+O+fXw9HaH8Rped9+v4Zo4OaxlJgFGFp9VTS7NF9K58N/LTF57V2Vl09Nac2mFjB0lV5+yOOcS04vG1o2NZwl0lGbBjlQvye4ES9YIa2Inue+yc8m0oR1yaHMxOujemhTiPp3vmCxEny7X5GRmeQkHwxq/2ydexsqkG1ug1rSHk+l6abLMnYOwEKJQJn3zndv4cI/7Wslb1NYdAgNcWgUMfFMFI3iOgVh/7lcrkFw8Sc4DUmjUNyUXoVx7KkcdFd9Vzqk9LFdQU7boNjLxQee2T96Z5JYzQcX4jhur9O4DsgI1iW+GCwmg1gRIF0r6Hr+N1P0m8tIpvfi1mN5orTTwlgDlKHh0PlAv4eVtSD9q/Wi8PhDi0doPyHe0R8Gk9BMC+PfUieWA9bPoHte12IG/tw0wWQyahSt1wSwa63rnqdNy3ch9UfbPe3E4QW3uVvDANPU/I5ugHiqBKmPKzVW3vu+ktwjocVd2CYzBF4tcyZJvAy6X7nz6tUeKaz0Q/k+1FTg8q7QCyY7ekLOrIc/zv5eQB/71CuJlMEnPtlJpTE+VKKiSgvcfP/blXKDZ41YzezO16ZfdejwBkkx7Dmz7AunR2wIZVMWoZwqBufXX/fAouCGFK+FuvrVqZCA6uFXf47dPrUZ7I+RM5I1gVu1F5erej1frTsXvnHMdeEyaBRl56eF70xO0jAtDhmOoNHyNz1wCB+OJNTBneY7GKN0NTONIj4fiAY8E9rPUluPBcAB79QpejDykfiCK98gkMIxp9mQhvx2PaVAyLrCAZQyulH9WxS2d4TA3HfOxV2gV4yci7gCHQbeLD+MOs/1zI18/mCKfEzyxHU2bwZ0fITG0Q/p2t62thNeLA2hoN50W6vQtStQdYDyM5mHN/T7RrZ7sV1vvgVqW9zrZsvYjpphp+efpDGkILrAA07idKxshdi/6fIb8PYpzLATkN5h/NVBTORQD2+Hgdh9eo/2EBKYW3LZPhPFzaziBhbmOBjoa9cOruX2sDiaufs7zOjP4/CWMg3dToyC99fo6sI2WncHdfXcpLRawIaKgpKfpmqbVvAJTsxxNNwRSdbTsnEnPiDKVhKzQu5u7SmLSvUHINNBwf3zmX6BHutK82pCjuBX2F2Zg7V+vlOIoiUoukO6UaBktPhrUZnGDUu8Eq/5aVI2wvBa4GP1fA733062K7v8BrV494w=="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/filterTools.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:19:17.225Z",
    "codeReview": {
      "review": "**OWASP Top 10 Review (Short)**\n\n**Critical Areas of Concern:**\n\n1.  **Improper Input Validation:**  The code lacks robust input validation for the `tool` string.  A malicious user could potentially inject harmful characters or exploit the code.  Example: `strings.ToUpper(tool)` is vulnerable to command injection if `tool` is user-supplied.\n\n\n2.  **Insufficient Data Sanitization:**  The code doesn't sanitize the `value` string before using `strings.TrimPrefix` and `strings.TrimSuffix`.  This could lead to unexpected behavior or vulnerabilities if the input contains special characters. Example: `strings.TrimPrefix(value, \" \")`.\n\n\n3.  **Potential for Denial-of-Service (DoS):**  If the input `values` array is very large, the code could potentially lead to a DoS attack.  The nested loops and appending operations could consume significant resources.  Example: The `for` loop iterating over `values` and appending to `filteredHistories` in the `Filter` method.\n"
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 1,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "a42f8a686137c4917440db6f1e73fb7fc60333f16aa02ac918ff7b8b1c2d522c",
    "id": "eJytlEFvnDAQhf/KyIcKKhba60oc0lRtT82q2aiHOKpcGMCqsZE9JEWr/e+VMSy7JW0VqScs3rxvxn6GAxPOoXNS13tjFNuym69Xt7vN/ma3efuGJawwJV4bTaiJbVknih+iRqikIrRccy3bzliCiGtOnDmyUteOM65jr9LQIXwYiz3egdSEthIFwsE7ghQ9CtWjg/uH4E+gkY6Mlejg07yKlyXXxxPcYwMFHNm+oMOoVb0u4DM+LXIUXwwytrdIvdXwaqny7gUQEbxetBnw0nFDr3BkWC6vt/lSM05NlbHwLYGR72UrdI0wtRspnKYjTvdWtjuLlfwZ5kmAM+AsXlfd9tUfqui0t9/mojSM+27w25+tp21O9vWWchBdh7qMVlICzzZL03SEHc/iWHn/FsnFnL4F/OdQllgCcFiCaS5hnGQFp4M3d12HNppM6dX5ZxZDnq8qaRQmEqcss1j2BQI1CKUgAcqIclZn7LUp8Qs+SnyCHFrR3Qfqg9BDuFLnxR+tKKWu3yMJqdzzhsnysminBtO1OM6B/itSlrBKKtwJatiWZXcOrcsa1HZQov2etb0i2SnM/D9IYUWbQsksoKbH+C2ntWHHXy4FzQw="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/filterTools.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:19:17.281Z",
    "codeReview": {
      "review": "1. **String manipulation in a loop:**  `strings.TrimPrefix` and `strings.TrimSuffix` are called within the loop.  This creates unnecessary repeated string allocations and copies.  Example: `strings.TrimPrefix(value, \" \")`.  Should be done once outside the loop.\n\n2. **Unnecessary `ToUpper`:** Converting to uppercase for comparison (`strings.ToUpper`) is inefficient and potentially problematic if case-insensitive matching is not the intended behavior.  Example: `strings.ToUpper(history.AssessingTool)`.\n\n3. **Mutable `Histories`:** The `Filter` method modifies the input `histories` object. This violates the principle of immutability, making the code harder to reason about and potentially leading to unexpected side effects.  Example: `filteredHistories = append(filteredHistories, history)`.\n"
    },
    "gradingDetails": {
      "dependencyInversionScore": "A*",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "B",
      "openClosedScore": "B",
      "singleResponsibilityScore": "B"
    },
    "hash": "322b5f8dac63c1b7d9fa0a0199a9ef0fb4b9c69110a70c25cf448c6228ae72b1",
    "id": "eJytlE9vnDAQxb/KyIcKKgr3lTi0ifpHqtqoSU5xFLkwBqvGtuwhKVrtd6/AsOyWtFWknrB4834z9jPsmQgBQ1CmubFWsx27/vr50yXLWGVrvLCG0BDbMSeqH6JBkEoTem64UZ2zniDhhhNngbwyTeCMm3RUaXAI76fikRtAGUIvRYWwHx1RSh6F7jHA3X30Z9CqQNYrDPBxWaXrkpvDET5iIwUC+b6i/aTJ3lTwBZ9WOUnPBpnae6TeG3i1Vo3uFZAQvF61BfDScWOveGRYr6935VozTU3SenjIYOKPshemQZjbTRRO8xHnN151Vx6l+hnnyYAz4CzdVl338g9VdNzbb3NRHsd9N4zbX6zHbc727ZZKEM6hqZONlMGzzfI8n2CHkzg23r9Fcjbn2AL+cyhrLBE4rMG05zBOSsLx4O2tc+iT2ZS/Pf2+UijLTSVNwkziVBQe675CoBahFiRAW1Ev6oK9sDV+w0eFT1BCJ9xdpN4LM8QrdVr8wYtameYSSSgdnjfMlpdFOzeYr8VhCfRfkbKMSaXxSlDLdqy4DehD0aLxgxbd96LrNSmnsRj/QRolvam0KiJqfkzfct5YdvgF0JHLTw=="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/main.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:19:18.259Z",
    "codeReview": {
      "review": "This code lacks proper error handling for `toolsFlag` being `nil` (line 48).  The `parseTools` function (line 128) doesn't validate the input string for malformed comma-separated values.  Finally, the code lacks clear separation of concerns; multiple responsibilities are bundled within functions like `main`.\n"
    },
    "gradingDetails": {
      "dependencyInversionScore": "B",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "B",
      "openClosedScore": "B",
      "singleResponsibilityScore": "B"
    },
    "hash": "19c7cfa512fbd4ac0769caf939d51791b517f98ddca570f6a52262df19e7bd02",
    "id": "eJytWN9v2zgM/lc4AxucznG6l3vIIQ+9dN0KFGuxdLuHekB1Np0KkyVDkrvluv7vB0ryr9Rd17t7WVyR/PiRoihqdxEzBo3hcnuplIiW0eb87PQ4SqJcFbhW0qK00TKqWf6VbREqxmUmM8mrWmkLcSYzmzldgaWd54IvPGCF0mbRhLjkwqKeFGlkRSsoBdt231UHpUz7ZazmcmseASJ2JJoR2cUCPqM2XElQJdgbhPXZKVilRCZzJY3txCvIojfpYfqbgyVDChi4cVYord5Brbi0UCoNO9XoDirNZNnI3BnEM7gjWosFHGPJJQKFY2jJ3mg0N0oU7zQrEJYrJ0o3Lpo4izr5fEsKWZRAFvl/N2g9DyeBTjPNotkI+gJ1jtJ24KfSjpBrLyfUwxFwENBGP0RXSpgTwbYTnEk0ZLpWVcXmBmummcUCBDfWpV4pweUWYky3aQKu1JLzP482F/NLVc/fHCZrgUzO16rAJE3TWfB967dn5P0PpUScRUFEfksmDJL7Y25qwXY+przRmpJxO10BbXi+asebElw4Ub8dnZsjZ/KzHfGga3WLmnI6iZsH6WPQrfwheq6RWfzoan0f28vm7UEYQK+dBBh4WZuP/tQGeF++68ZYVfG/0Sk1xvUANO7XKuAyF02BXXK5LJWumKUdkZl1jD455RXQ6WgPRmYd1CV+d8yvh6e3O4zX8Lr7fg3XxMlhLTMJMLK4UjW5NF9I59x/LzN57V2VlU1Pas2lFTJ2lFx9yuKMS0zPG1s3Np4l0FGaBTtSvSC7YyxZI6yJneS+y84F04Z2yKHNxeige2tSiPt0vmeyEH26XJOTmeUlHAxr/G6feBkrk25sgVrTHk6m66XJMncOwkKIQpn07Xdu48M97mslb1FbdwgMcGkVMPBNFYzgOQZi/blfrUBy8SQ5D0ihUd+UXIRy7am86aj4rnJG7WG5gpqyRdeQiQ86t33yTiW3nAkqxvfcWKV3H5EVqEl8M1xIALUmQLpQ0g/4baTuN5GXTunFr8X0VmulgbcEKEfBo/OBegkvb0P6UetH4/WBEI/WfkC+oz0KJqWfEMC/p04sB6yfRfeorsUO/L1tgMli0CxcqQtm0VjXO0+clutG7ouyf9aLwwlqc7eCB6ap/xnZBPVQCVQZU24uu/V9J71FQI+7sktgDL5Y5EqWfBtwuXTn0689UlzrgfB/qq3A4VmlFUh29IacXQ15nv+9hDzwr1cQL4NJerqVSmN6okRBlRS8//ixL+cCzR63mtmbqU2/6NbjCZBk2nNg2xdIj94WyKAqRj1TCMytv+6HR8ENKVwJd/OtVSMD0cGt+gG/fW412hshZyJvBLNqLypX9368Wncqfuec68Bj0izIyEsP35seo2VcGDIcQ6Xha3zmEjgYT6yBOctzNEbpbmAaR3o0FA94JLCfpbYcD4YD2KtX8GLkIfUDUbxHJoFhTLMnC/ndeEyDknGBBSxjcKX8sypu6QyHuemYj7xCqxg/EXEHOAy6XXwYd5jtnxv5+sEU+Zzgie1o2gzu/AiJoR3St7ttbSW8XhxAQ7vptFCn71Ci7gDjYTQPa+73iW71ZL/aeg/UsrzXyZa1HzHFTMs/T2dIQ3CBBZjG7VzZCLF70ecz5O9RnCMhIL/B/KuBmsqhGNgOB7f78BrtJyQwteC2fSKMn1vDCSzMdTTQ0agfXs3tY3UwcfVznteZwdWXMA7eTY2C9Nbr68A2WnYGd/fdpbRYwIaIgpKepmuaVvMKTM1yNN0QSNXRsnMmPSPKVBKyQu9u7iqJSfcGIdNAw/1xxb9Aj3SpebUhR3Er7C/MwNq/XinFURKVXCDdKdEyWnwyqM3iBqXeCVb9tagaYXktcDH6vwZ676dbFd3/A4SKPCY="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/gradeDetails.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:19:19.504Z",
    "codeReview": {
      "review": "**OWASP Top 10 Review (Snippet)**\n\nThree critical areas of concern:\n\n1.  **Insecure Data Handling:**  The `GetCoverage` function's coverage calculation is overly simplistic and lacks proper input validation.  Hardcoded values (120, 100, etc.) for coverage are problematic.  This could lead to unexpected results or vulnerabilities if the threshold is manipulated.  Example: `if g.Score > thresholdAsNum { g.Coverage = 120 }`.\n\n2.  **Improper Error Handling:**  No error handling is present in `GetCoverage`.  If `thresholdAsNum` is negative or invalid, the program will likely crash or produce incorrect results.\n\n3.  **Lack of Input Validation:** The `GetCoverage` function does not validate the input `thresholdAsNum`.  This could lead to unexpected behavior or vulnerabilities if malicious input is provided.\n"
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 1,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 1
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "426e35a11bbd85e4480c9b28b432f12fe86dc528c98c13e26b6f65dbaeb9da49",
    "id": "eJyNVMFq4zAU/JWHTklx4qRlWTCkULpsb2kgXfbiQ1X52dGuLBnpuUsp+fdFspzYwYXc7HkzfjMj25+MO4fOSV29GKNYxp5/P+x3i5fn3WK9YgkTpsBHowk1sYw1XPzlFUIpFaHNda5l3RhLkDOSNebMQ/TRIDxZXuAPJC4VSE1oSy4QPnOd0xPSo3lHyyucSU3zXB+nZA4c2VZQFPkBAHhQ6gpe/zijs5xVHs/Zq+fshbGBIzWdCM6DkdCvHRFEBCPnp1S45TVeLiojHmm+LZjwQ8aoniJrdMTrBnw3S397pvWzwA35y1YL2OK/YQWzEC/uSCBk8eYTKMc2E/CLzzeyxv149XzcbSjVIrVWjwYBj3VnPl9wkHRoKDigwUlE+8ayk6k48B0FdjDXg33y7OwyjI6xhzSFwRsCgivRKk7ogA4I/WlBg1agJn/5xh0WYHQgdB1xXQAdLLqDUUXsdlbBzTDqfLhndmI/uG1b+5LnXUmyhGrZvVr3cMGKbVXLk90NrG9XIQ6gcggD9WZzlXz1hfz+Ur5YTz7g+9X620n9t6v1d5P6u6F+OuH5uFkSPqwdpwPLWPrLoXXpAbX9ULx+S+tWkWwUpv43pLCkhVAy7f4+aTU4y2Vl2PE/QLa3ag=="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/model.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:19:21.909Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "46a2d9cef206ba000f788c337d00b65b03c47849b8db589fc3ab2b4eb97ed106",
    "id": "eJyFk02L2zAQhv/KoJMNTtxeAz1st7RbKGxoUnqIAqu1x/ak+jDSuEtY9r8XOYrXKc3WF4PmeV7JmvGzUCFgCGTbrXNarMT9z5vNerG9Xy/evxOFqFyNt84yWhYr0avql2oRGtKMXlppyfTOM2TSSpaCyaAU0uaxxMce4Y4CO3+EwH6oGJ4jdzPfEmKJbAvn5+EQnF3Jy4NJ8RDNz6RxrbhL6BWzSVSSvnhV4wRdk9pIJeNHQG+VwbeNIVFJ2pLBDSvTn6h4Fcu4dinxmUrWravxO/4mfBoxo/rdabu9ssfJqiZq9k1k20/IinS4prUXVFLvVOjgv9fRqXC+v681SJZ8FaV6BF/+6jlhgN0+9T/WmsFWkHWv5Ry+oc1yIJsGwyMP3oJGm3V5SvynFUJGBRyimcNjnKK53+1ov5zasfyIjfOYdbvDbPWN+M2T6mfxY3KMLCBGwIfxVYy7jCGimCZOrEQZhyeUHVp/1Mo8lmbQTL3GMjZRY8OLSlN5+oNKE9eWrRMvfwCMOTN5"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/gradeDetails.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:19:22.271Z",
    "codeReview": {
      "review": "The `GetCoverage` function lacks a clear, consistent logic for calculating coverage based on the score.  The `else if` chain is overly complex and prone to errors.  It's also overly specific to a particular threshold value.  The function should be refactored to use a more structured approach, such as a lookup table or a function that maps scores to coverage percentages.  Line 40 (`if g.Score > thresholdAsNum`) is a poor example of this.  Finally, the `GradeDetail` interface is unused, making the code less flexible.\n"
    },
    "gradingDetails": {
      "dependencyInversionScore": "B",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "B",
      "openClosedScore": "B",
      "singleResponsibilityScore": "B"
    },
    "hash": "f3574bdca1d496bf568c152e979c84edf711a8db3fd6619a6e66a992186a7ebc",
    "id": "eJyNVF2L2zAQ/CuLnpLii++DUjDkoNzRo1DSQto3P5xOXstqZclI65bjyH8vkuXEDj7Imz07450Z2X5j3Hv0Xhn501rNCrb//u3rI8uYsBU+WENoiBWs4+IPlwi10oSuNKVRbWcdQclItViyANFrh/DkeIWPSFxpUIbQ1VwgvJWmpCekB/sXHZe4UobWpTksyTx4cr2gJAoDAAigMhKef3tripLJgJfsOXD2wrrIUYaOBB/ARBjXzggigYnzRWnc8RbPF9UJT7RQEyz4IWv1SFEteuJtB6GbTbg90cZZ5Mb8dW8E7PDftIJVjJd2ZBCzBPMZ1HObGYTFpxvV4n6+ej3vNpbqkHpnZoOIp7qLkC86yAY0FhzR6CShY2PF0VQahI4iO5obwTF5cXIZR4fUQ57D5A0BwbXoNSf0QA3CeFrQoRNoKFy+cI8VWBMJQ0fcVECNQ99YXaVuVxI+TKOup3tWR/Znv+vbUPJ6KEnVIDfDq3UPZ6zUltwc7W7h5vY6xgHUHmGi3m4vkl+/I78/l1/dLD7g08X620X9x4v1d4v6u6l+OeHpuFkWP6wfnBpWsPyXR+fzBo171bx9ydtek+o05uE3pLGmK6FVPvx9cjk5y4207PAf3E61rQ=="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/model.go",
    "grade": "A",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:19:23.558Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "dependencyInversionScore": "B",
      "interfaceSegregationScore": "A*",
      "liskovSubstitutionScore": "A*",
      "openClosedScore": "B",
      "singleResponsibilityScore": "B"
    },
    "hash": "38ce36232c0a562f486a90cb94add2a7985ec5301cdf4f830e05d1964931ec90",
    "id": "eJyFk1Fr2zAQx7/KoScbvPg9sIetZWuh0LJ0T1Ggqn22L5NPRjqvhNLvPuQonlOWzi8G3e/3l6w7vyoTAoZA3D46Z9Vabe7vbq9VoSpX45VjQRa1VoOpfpkWoSEr6DVrpn5wXiDTrEUroR610pzHkhwGhBsK4vwBgvixEniN3JflXhBLxC2cnqd9cLzW5yfS6ima38jig5EuoRfMJlFJ+u5NjTN0SWojlYyfAT2bHj82xkQl6ZF63IjphyMVr2IV184lOVHJunI1/sDfhC8T1pthe9xuZ/gwW9VMLb6JuL1GMWTDJa09o5J6Y0IH/72OzoTT/d3WoEXLRZTqCXx713PCANtd6n+sNSNXkHV/yzncIWc5EKfB8CijZ7DIWZenxH9aIWRUwD6aOTzHKVr63ZZ2q7kdq6/YOI9Zt90vVj+I37yYYRE/JcfIAmIEfJ5exbTLFKKKeeLUWpVxeELZIfuDNf1z2Y9WaLBYxiZabORTZak8/kFlH9dWrVNvfwBZdTG8"
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/pathFilter.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:19:23.575Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "792a1348ef2a1ac68bce8edd428ee235269982729d7c7f49c3524c62b3d4510a",
    "id": "eJx9VU1v3DYQ/SsTHZpVsRaT6wI+BEGDpIfEgF30YBkBVxpJ01BDgZy1sw383wuS+vRHbxQ5nPfmvRnqV6a9R++J2xtrTXbIvv394frq4ubb1cX7d9k+q2yNHy0LsmSHbNDVD90iNGQEXcklUz9YJ7AruZQyRhts5KIypOQ8oC+zdDJo6VRDBsNi2vTiiNsYk4dkSsGVlu5TzA7kwaEfLHs6GoTGuhGXuA0rhJDLw1F7rMEyUMvWYR3PPGiuobGmRueLkgOZdXIv7lQJ/ApExnuf4jWA27vIvAjf6+OUC27vEu2SH0fOX/FhlblyqCXgA+MDEHvRXCHYZg3/QNKBdAiDs/dUY/2/5JsTV1uU3YbzmvEeXuGbw+8rArFwh3JyDL8t+3F7q8gBANbf+21IQjk8QY1Bj4tEI2ryz4M9Sax+5aJ0WqDXUnWg+RzkCgFbVawLHUE1Rv1o5fgslVLwRSAVNnngDVUIlWXRxKF5LJvzi/jaIbCVKe8k/W5o1uLlYzm7jrxYR+jh87TKl2XS+F67QOLz89AgTSmhrb/vIaU6w+ESnOYWodumKYUaeDM0BfkvidyIfo6uB3L5FFnKBvAS9DAg17v17oyYpzuPo2GrtliHL07O+FB1WP3w8NChdOhAQ0v3yIumyc3YzOeNkcFH8pOHm9Po46uyL7XH/FNfH601qfYwjNb12tC/mMYrxAWJq/CM+PCMQWX7QTvyNhbLU3wdkIL+0ytV3Nhro30XwfIkjVLwMZQNutVhtLcNuvIz1jmbGXxbD+xolFLwpyXetmKcfdY97sM+w0zw2Wi+SnjeCNnjVxFiE6viq+4xz+emeiLA5SU8hZjbamwMcSd83jVKwfVgSBbdicVCTQ6rueGlJucD5/HpL+KV3ZbDHspMldki+R8/K3Oqk6NGewE02AcrqQGSt2HOm/GxVgpuOvKgvT/1OI71zAi5Tn033og6F/Ch/ufkY7YVW6g0gzbewhGBeBnIYmVzTW5xOdR2ezDIu7DKL97fTdKN0Zs38sXuGN/sWfFEaW1KujsHvGDKaMuLM91o4zEOc7bPmtHg7JCpvzw6rzpkdza6P6r+ZIQGg2rzS0/vtxrmmSxamz3+B+NvCTM="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/pathFilter.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:19:23.617Z",
    "codeReview": {
      "review": "The `PathFilter` implementation has three critical areas of concern:\n\n1.  **Inefficient `isIgnored` function:**  The nested loops in `isIgnored` (checking ignored files and folders) have a time complexity of O(n*m), where n is the number of ignored files and m is the number of ignored folders.  This is inefficient for large lists of ignored items.  Consider using a Trie or a similar data structure to speed up the lookup.  Example:  Replace the `for` loops with a more optimized approach.\n\n2.  **Assumes file path structure:** The `isIgnored` function assumes that the `path` always ends with a file name.  If the `histories` can contain directory paths, this will lead to incorrect filtering.  Example: Modify the `isIgnored` function to handle directory paths correctly.\n\n3.  **Lack of error handling:** The code lacks error handling.  `filepath.Join` or `filepath.ToSlash` could potentially return errors.  Example: Add error handling to `filepath.Join` and `filepath.ToSlash` calls.\n"
    },
    "gradingDetails": {
      "dependencyInversionScore": "B",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "B",
      "openClosedScore": "B",
      "singleResponsibilityScore": "A"
    },
    "hash": "06723b04f082cf776d0003b16c72a9c337069bb1ce784c98f6e355202ed42c7a",
    "id": "eJx9VU2P3DYM/SusD+m4mFjodYA9BGmCbFGkBXZ7Wi8KjU3bbGTKkOjdToP974Ukf+5Hb7JE8T2+R8rfM+09ek/c3lprslN28/tv179kx6yyNX60LMiSnbJBV990i9CQEXQll0z9YJ3AoeRSyhhtsJH3lSEllwF9maWTQUunGjIYFvOmF0fcxpg8JFMK/tDSfY7ZgTw49INlT2eD0Fg34RK3YYUQcnk4a481WAZq2Tqs45kHzTU01tTofFFyILNN7sWNlcD3QGS69zleA7i7j8yL8L09Trng7j7RLvlp4vwVHzeZK4daAj4wPgKxF80Vgm228I8kHUiHMDj7QDXW/0u+Gbnaoxx2nLeMj/AG3xx+2hCIhTuU0TG8W/fj9l6REwBsv4/7kIRyeoYag55WiSbU5J8HO0qsfuOidFqg11J1oPkS5AoBe1WsCx1BNUb9aOP4IpVScC2QCps98IYqhMqyaOLQPJbN5VV87RDYypx3lv4wNFvx8qmcQ0derCP08GVe5esyafygXSDx5WVokKaU0NZ/HSGlusDpCpzmFqHbpymFGvhhaAry14nchH6Jrgdy+RxZyg7wCvQwINeH7e6CmKc7T5Nhm7bYhq9OLvhQdVh98/DYoXToQENLD8irpsnN2MyXnZHBR/Kzh7vT6OObsq+1x/xzX5+tNan2MIzW9drQv5jGK8QFiavwjPjwjEFl+0E78jYWy3N8HZCC/vMrVdzaG6N9F8HyJI1S8DGUDbrVYbT3DbrxM9a5mBl82w7sZJRS8Ksl3rdinH3WPR7DPsNC8MVovkl42QjZ41cRYhOr4qvuMc+XpnomwNUVPIdY2mpqDHEjvuwapeBmMCSr7sRioSaH1dLwUpPzgfP09BfxymHP4QhlpspslfzTP5UZ6+So0V4ADfbBSmqA5Mcw5830WCsFtx150N6PPU5jvTBCrlPfTTeizgV8qP8efcy2YQuVZtDGWzgjEK8DWWxsrsmtLofa7k4G+RBW+fuf72fppujdG/lqd0xv9qJ4orQ1Jd1dAl4xZbLl1ZlutPEYhzk7Zs1kcHbK1J8enVcdsrsY3Z9VPxqhwaDa/dLT+62GZSaL1mZP/wF3JAd2"
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/collectGrades.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:19:24.392Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "06140381ad5dfe1d9d8bd8714d319e87c38a4dd8cb66851d89bb783819570213",
    "id": "eJydVE2PmzAQ/SuWDxWsCOz244K0hzSrbk+7kZJuD6WqXGcAq8ZG9tAoivLfKzALjrP9UG943sx7z+MZjpRZC9YKVW21ljSnj5+Xm/Vi+7he3FzThHK9g5VWCAppTlvGf7AKSCkkgilUofDQAllpKYHjvWE7sEQoBFMyDuRYqALPwKgWFrURYMnH56+EYG3A1lruiEUjVBWTL1+H/DtAJqQt1GnSGuIjp9Cqr+g4OimHMck7yVAbEpxHmrJTnDzAPmCK+G8L4+CGg5gB7IwirwKaAbuwkpOZPekzTr6ZqCJXAU0g+X99c0YrP5LfBjnH3gaW2pBvCXEqhz7LMFUBmWXHeynYe1TPXRxDo8tDOgQTUqVBG9z5oWvACM7kE5MdnBfFk4n0g5CwZljPkaU/q3N4KxrYIGvaOPSY3gOu9E8wrILo39xMPY1HtrP23RLWtqB2kR9NyKzYF7nnnSak+uMkz0MX7M1L5gaq6bGFwgu+zYB5rG4/jpeTH2ZG8YWjyzkPi44vz3GYNlL/7TZO0O4F8tq1zUU4s0AKurwqaO4eZTT1zkdD8K0Hvg/BNx64CsHXHngXgjf9aQcl6ySeI9fzYtOEluP40pxmnywYm9WgzEGy5nvWdBJFKyHrf68SSlxwKTL3V824v/hppenpF8cWHLc="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/collectGrades.go",
    "grade": "A",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:19:25.356Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "dependencyInversionScore": "A*",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "A",
      "openClosedScore": "A",
      "singleResponsibilityScore": "B"
    },
    "hash": "5ec80855026f79443e67ed2e6c60b4fe2d31c27457626ef0af2cb947116760d1",
    "id": "eJydVE1vnDAQ/SuWDxVEFPp5Qcoh3VXTSlVaaZNeSlS5ZgCrxkb20NUK7X+vwAS83jStesPzZt57Hs8wUGYtWCtUfau1pDndff70cUsTynUJG60QFNKcdoz/ZDWQSkgEU6hC4aEDstFSAsdrw0qwRCgEUzEOZChUgSdg1AiL2giw5MPDV0KwMWAbLUti0QhVx+Tb/ZS/BWRC2kIdF60pPnMKrcaKnqOTchiTvJcMtSHBeaapesXJDewDpoj/sTAObjiJGcDeKPIsoJmwMys5WdmTMePom4lqchHQBJL/1zdntPYj+WWQM4w2sNKGfE+IUzmMWYapGsgqO99Lwd6jeujiHJpdHtIpmJA6Ddrgzjd9C0ZwJr8y2cNpUbyYSN8LCV8YNmvkyh/SNXwrWtgha7s49JheA270LzCshujf3Cw9jWe2k/ZdEtZ1oMrIjyZkVRyL3PMuE1I/Ocnr0AV785i5iWp5bKHwjG83YR6r24/hfPLDzCg+c3Q+52HR8Pgch2kz9d9u4wTtXiBvXNtchDMLpKBXFwXN3aPMpt76aAi+8cB3IfjaAzch+MoDtyH4cjyVULFe4inyYl1smtBqHl+a0+zOgrFZA8ocJGt/ZG0vUXQSsvH3KqHC51yKzP1VM+4vflprevwN6Woa+g=="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/latestGrades.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:19:25.383Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "947f6f205ef5910ec0f7166115539052698591d7ed6a47aea76d5a803e7d8c35",
    "id": "eJyVVE1v2zAM/SuEDkO8unZ3zZBDFyAbsHUNkBQ7VMWg2rQjRJY8idlmpPnvgz/kjyZAsZMFkXx8fH7UkQnn0Dmp860xis3Z/Y/bzfp6e7++/nDDQpaYFJdGE2pic1aKZC9yhEwqQss111SVCCup02+C0NFnK1J0IDWhzUSCcOSa06pJH2fMdtKRsRIdfPGnYDhyferBJ8CO7CGhYxPNDjqB7/hnghuck2koWKSD1fBuHKlhBqSZyuH9OFxD/Sfvtlccw4NDEJCYojROEsIeqzlwtpIK14J2L7dj1Tmrq1TTpoWqYL6AQuxxVojy0ZGVOn/qQkHNmFNmLPwMYTfkW6FzhN2UC6c9NtEcNVpBuPScvmLVTVNFnlePF00Idi05yQzqMKYdlxDwr3Tk6gYT/o97rJ4++mjH5Lw+2soCNySKMvqEmbHYM+oDwVD9SqOmByw8ZZ91ag8nQOVwKH67tCk8taN2dlka/Rst3YlyazZKJjibwASdf+L4oryQWKzTQcBBy1+HxgbwLBymYDR40UHoFKaGaB158Zdl/a+abC60Jgm678T0vgSugLMXzuBqWjtMcTYvJO1NPUMhSjAZeIeSAQGuSRpuo476uXCd1HeihAuefr1CXXbLwe9CnxPCTQgK9Qg0CN5eiqZ5Z4hJgwWIskSdzsa3PUzgfeH1HGc12rGQeY3ZnMUPDq2Ld6htpUTxHBcHRbJUGNePqcKMrhMl4/YNjdXodYlyw07/ABd4GCw="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/latestGrades.go",
    "grade": "A",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:19:25.393Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "dependencyInversionScore": "A*",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "A*",
      "openClosedScore": "B",
      "singleResponsibilityScore": "A"
    },
    "hash": "240de67b09d08d0b9d544f71b5595f3a03e7c06f1094cbe4af381762bcd008ca",
    "id": "eJyVVE2P0zAQ/SsjH1DDhoRzUQ9QVEDsAlJ3T+sV8iaT1KpjB3sKRN3+d5TEzse20opTLM/Mmzcvb3xkwjl0Tury1hjFlmz7/frLRxazzOS4NppQE1uyWmR7USIUUhFarrmmpkbYSJ1fC0JHn6zI0YHUhLYQGcKRa06bLn2asdhJR8ZKdPA5nKLxyPVpAJ8BO7KHjI5dtDjoDL7hnxludE6mo2CRDlbDq2mkhRmRFqqE19NwC/WfvPteaQp3DkFAZqraOEkIe2yWwNlGKvwhaPf0fio3Z22V6tr0UA0sV1CJPS4qUd87slKXDz4UtYw5FcbCzxh2Y74VukTYzblw2mMXLVGjFYTrwOkrNn6aJgm8BrxkRtC35CQLaMOYey4x4F/pyLUNZvzv99g8vAtRz+S8PrmVFW5JVHXyAQtjcWA0BKKx+plGXQ9YBcoh69QfToDK4Vj8cmlXeOpH9XZZG/0bLd2I+tZslcxwMYOJvH/S9KK8kFls00HAQctfh84G8Cgc5mA0BNFB6BzmhugdefGXFcOvmq0s9CaJ/Hdm+lACV8DZE2dwNa8dpzibF7L+pp2hEjWYAoJDyYAA1yWNt4mnfi6cl/pG1HDB089XyGf3HMIuDDkxvI1BoZ6ARtHLS9E194aYNViBqGvU+WJ6O8BEwRdBz2lWpx2LWdCYLVl659C6dIfaNkpUj2l1UCRrhWn7mCos6E2mZNq/oamavC5JadjpH1rTFm8="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/report.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:19:26.166Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "0fc3913d388ca96fed1a2276165490855645cccd852b42de0b73e287d79bf6d5",
    "id": "eJxtVU1v4zYQ/StTAQVkQJF2+3Uw4EPiLdIemgQbd3NYFQUtjmS2NEcYUgmMIP+9GFJSLG9ziTycj/feDIevmfIevTeu2xHZbJ3dP10/Plzt7h+uPn7IiqwhjVtyAV3I1lmvmn9Vh8DYE4fa1c4c5Qvy2tWhjt4W23DVWFO1xgbkOoOqgmvvh6NxHYSD8dCrcADjoSFmbEKKbY+hztKnpU4+V1KgquAWHbIK+DlWBeLmgD6IxUM4TGigS26GHPRMDXpfxvDfA2js0WkP5EDtJbQRNw95SvnEJiCvQDkNDRFr42JybdoWGV2Aho49OXRBcraDay5A5R0rjZ8wKGM9fP0rcS9vz6wF0BD6ITwIeR/YuK6AcGD0B7I6es7mlwgIluiQmRheRSLTgkW3KLqCzQY+pOM6WOrKBzYuWJfX2ZNiZ1y3hjuCGAN6RNozPRuNGgJN+k16lnW2SsmqCn5TTlsE1fdMPRsV0J7gCo7qtMeEFpQDPPbhNLWDGBjDwA58j41pTZMYzDm3jCrITKQwrYKClji2NAmQXMcsyVRGNca+fTH48kkF9Qq7hY7rS13fzsWPrN5ktiKMjyXcDMbqWDcwxi4MTRgYxWMvZ8iw3sAdvuwY8SZZ8pinYxp61FPn1xsYA8pbOTkfgJuTVF82TVIwUbgjjYvoWCSxlJr5ss5qRv9DCVtlm8FK4xp6RlYd+jjJqusYO7H7oIKXgGZ0pYnPdozYzgf5UrqIMMaPEbeW9so+iiUpIC37uwBHGsWFlZMFMXMaB/K9cjnjvYu7ZYScS4IiQV3JyviDtGkN+pg5MZp5vHfvxxIeZdrm5uXUy91WtoCGBqthj6DJIahWrlTUV4aOGPbYEqdZM65LTIlDUj2iz2ceUXEAEGQ/nWveGqcsRBbWghrZJN/Rej0aCwgU1PSzAGWtLN2o7P/pc78Mz5M2M/WfS3hg7BXj8u48G3wRl+fxdkj6i/uSevJ5IreG9DezLZLD9QhwOp8RF3GnW0alTyCaoYb96YxEir8gsP5GkOS2O1MlllrINPpcXPCLG14sp+KXEuKeOH8eBp/eHwTj/sFGIL9vGeR4IxY7ZtLvm91hWtlk8N0GnLHTgI9bqj2G8ldZc21eZ60yNu3WtCITkjV8/1JnheQ4X0USGVe2RD4OjTxg7WDtaV7MOibwJhCf3nP5unaS7gLkiMcZW7u3rMhaY1EOs3VW/emRfXVAxyerjvvqONhgeovV4v1OFcZ/ZUfZ23+g2vuX"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/report.go",
    "grade": "A",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:19:27.285Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "dependencyInversionScore": "A*",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "A",
      "openClosedScore": "A",
      "singleResponsibilityScore": "B"
    },
    "hash": "51c57788531b386e24a86fbf45fbac84b0f5eccf9b8abc38bb9b9c8f75df8df8",
    "id": "eJxtVdtu4zYQ/ZWpgAIyoJV6fxDgh8Qp0gXabLBJdx9WRUGLI5ktzRGGVAIjyL8XQ0qK5W1eIg/ncs6Z4fAlU96j98b1j0Q2q7OHD7+/v8mKrCWNO3IBXcjqbFDtv6pHYByIQ+MaZ47yBXnjmtBEb4tdeNdaU3XGBuQmg6qCK+/Ho3E9hIPxMKhwAOOhJWZsQ4rtjqHJ0qelXj43UqCq4BYdsgr4MVYF4vaAPojFQzjMaKBPboYcDEwtel/G8PcBNA7otAdyoPYS2oqbhzyl/MwmIG9AOQ0tEWvjYnJtug4ZXYCWjgM5dEFydqNrL0DlPSuNNxiUsR6+/JW4l7dn1gJoDMMY7oW8D2xcX0A4MPoDWR09F/NzBARrdMhMDC8ikenAolsV3cB2C9+l4yZY6st7Ni5YlzfZZ8XOuL6GO4IYA3pCOjA9GY0aAs36zXqWTbZJyaoKflNOWwQ1DEwDGxXQnuAdHNVpjwktKAd4HMJpbgcxMIaRHfgBW9OZNjFYcu4YVZCZSGFaBQUdcWxpEiC5TlmSqYxqTH37ZPD5RgX1Ao8rHetLXV/PxY+sXmW2IozvS7gejdWxbmCMXRjbMDKKx17OkKHewh0+PzLidbLkMU/PNA6o587XW5gCyls5OR+A65NUXzdNUjBRuCONq+hYJLGUmvm6zmZB/0MJO2Xb0UrjWnpCVj36OMmq7xl7sfuggpeAdnKlmc9uitgtB/lauogwxk8Rt5b2yj6IJSkgLfu7AEcaxYWVkwWxcJoG8q1yueC9i7tlgpxLgiJB3cjK+IO06Qz6mDkxWni8de/HEh5k2pbm5TTI3Va2gJZGq2GPoMkhqE6uVNRXho4Y9tgRp1kzrk9MiUNSPaLPFx5RcQAQZD+da94ZpyxEFtaCmtgk38l6NRkLCBTU/LMAZa1s26js/+nzYR2eJ20W6j+XcM84KMb13Xky+CwuT9PtkPQX9yX15ONMrob0t7AtksPVBHA+XxAXcadbRqVPIJqhhv3pjESKvyBQfyVIcns8UyWWWsk0+Vxc8IsbXqyn4pcS4p44fx5Gn94fBOP+wVYgv20Z5HgjVjtm1u+r3WE62WTwzRacsfOAT1uqO4byV1lzXd5knTI27da0IhOSGr59brJCcpyvIomMK1siH8ZWHrButPa0LGYdE3gTiE9vuXzTOEl3AXLC44xt3GtWZJ2xKIdZnVV/emRfHdDxyarjvjqONpjBYrV6v1OF6V/ZU/b6H1yK+do="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/builder.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:19:28.198Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "d1a44c3883602cb7ef8246a05a1dd56036f06a44c6b2ccecd990a755378d3760",
    "id": "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"
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/calculator.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:19:29.965Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "adae4a0d544c23a4a5598f4a503ee1c9cef3e11dd3d8ba81d5faca16b0db762a",
    "id": "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"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/builder.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:19:30.186Z",
    "codeReview": {
      "review": "The code has three critical areas of concern:\n\n1.  **Inefficient Path Handling:** The nested `strings.Split` and manual path concatenation within the `BuildReportTree` function is inefficient and error-prone.  Repeated string manipulation for path traversal is not ideal.  Example: `currentPath = currentPath + \"/\" + part`.\n\n2.  **Redundant Directory Creation:** The code creates directory nodes multiple times for the same directory path, leading to potential memory waste and logic errors.  Example: The `dirs` map is used to avoid duplicates, but the logic for checking if a child already exists in a parent is not perfect.\n\n3.  **Lack of Error Handling:** The code lacks error handling for invalid input paths (e.g., empty paths).  Example: `if len(parts) == 0 { continue }` is a basic check, but more robust error handling is needed.\n"
    },
    "gradingDetails": {
      "dependencyInversionScore": "B",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "B",
      "openClosedScore": "B",
      "singleResponsibilityScore": "A"
    },
    "hash": "f4359dfa0a642b416ab16fe298765dfd315b11a1f82c297bdb0c347e15bbb759",
    "id": "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"
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/template.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:19:31.942Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "010061295045880dca6db655c808c3a227650e6db15b88dcc480812680c73573",
    "id": "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"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/calculator.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:19:32.109Z",
    "codeReview": {
      "review": "This code, while functional, has several SOLID design flaws.  First, `calculateFileNodeCoverage` and `calculateDirectoryNodeCoverage` modify the `ReportNode` directly, violating the Single Responsibility Principle (SRP).  These functions should only calculate coverage, not modify the node's internal state.  Second, the `calculateCoverageScore` function is tightly coupled to the specific grade-to-coverage mapping, making it hard to change or extend.  Third, the use of `processedToolsThisFile` in `calculateFileNodeCoverage` is redundant and could be simplified.  For example, `calculateFileNodeCoverage` could be improved by removing the `processedToolsThisFile` map and using a conditional check within the loop to avoid double-counting.\n"
    },
    "gradingDetails": {
      "dependencyInversionScore": "B",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "A*",
      "openClosedScore": "B",
      "singleResponsibilityScore": "A"
    },
    "hash": "52944ef0e995a30ee59a6263b0d085bf08db8ef2d219d193db328cf8a44031a9",
    "id": "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"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/template.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:19:34.149Z",
    "codeReview": {
      "review": "The code has three critical areas of concern.  First, hardcoded colors in the CSS (`#1e1e1e`, etc.) make the theme inflexible.  Second, the template functions (`getCoverageClass`, `getCoverageColor`) use multiple `if` statements for coverage ranges, which is inefficient and could be improved with a lookup table or a more concise conditional.  Finally, the template (`repoReportTemplateHTML`) has numerous removed placeholders (`{{ getFileGrade $node }}`, etc.) that are not used, indicating potential incomplete or unused functionality.\n"
    },
    "gradingDetails": {
      "dependencyInversionScore": "B",
      "interfaceSegregationScore": "A*",
      "liskovSubstitutionScore": "B",
      "openClosedScore": "B",
      "singleResponsibilityScore": "B"
    },
    "hash": "9370a6bfc69ffeba37137c841e03ce69bb66ca96c57395e7b0988e35ea963dc2",
    "id": "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"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/writer.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:19:34.249Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "dependencyInversionScore": "A*",
      "interfaceSegregationScore": "A*",
      "liskovSubstitutionScore": "A*",
      "openClosedScore": "A*",
      "singleResponsibilityScore": "A*"
    },
    "hash": "e12367d9ffe27a287a829eb9e677c39c87da95f8992f9bc8a511979b00170ef6",
    "id": "eJydVE1P3DAQ/StTS5QEhaQXVCkVB7QLgoqPFdD2koubjHctHDuyJ00R2v9e2d5slkVIFbfJZObNe89jvzDuHDon9fLRGMVK9nB3fTVnGatNgzOjCTWxknW8fuJLBIudsVTpSsvWR5BUuqKKiZYqFsMVtaogbDvFCcekcWPUcVoVQir0gU+mHq0o4D5A/7KS0EKDQmp0QCsEqQmt4DWCMBYGK0nqJfANlzw0380WJZwpZQYHjRQCLWoKtWgdJJePN9cZfH+4u80Aqc7T0DS/WpRwKZcrtMcK/6CC1jS9QgcNdqgbMBpoJd3EIK80PXf4muvE78VLDNmk4cQ3ZT8lDnNOPAPTU9fTgtMKHFmplymgtcZWer0xwRN9Dd52ClvU5F4P9Vb44g1mdOHhflHChal7h4F8KLCoG7TBMt2Ad37qCWLezHRk+5qimvEg4WiM8sfxbCNr0esabnHYh0lSSI72k1kUnG7A206FDJSnsMW/xSGpmD/d2FmxNL/ode2SsSR8pfmCW4fJVDgS80P9VpEUAfzTKWip4siKLFJvtc9kIFrKzz0hkVRMcKmwATLQeeDo3jiyhIOhYoFsgPbSR6jP+ypfpi4vcZ35abt2JQO8sSaFD2xOFBX/zmXwcbxb+VzaZOrbNaQ8BePym6dG2jOlkm17Bl++npyk39537R3Daot+RyIQNNJiTcY+w+GBOxyd25mya+KW/oVUmO3QmwXMdxR8gNzObYm34C05P2XviBsUaGFimM+UcZikkfnk55Bv9/f8L9b9lnmU5Q/1A75ihPr/VYx7xjLmFXo5rGTFD4fWFSvU9lnx9nfR9opkp7Dwb7xCQce1kkV8Tov4ZuZLw9b/AEEVMXY="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/writer.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:19:35.051Z",
    "codeReview": {
      "review": "OWASP TOP 10 Review:\n\nCritical areas of concern include:\n\n1.  **Missing Input Validation:**  No input validation is present for `outputPath`.  A malicious user could potentially manipulate this to write to unintended locations or overwrite critical files (Path Traversal).  Example: `outputPath = \"../important_file.txt\"`.\n\n2.  **Potential Template Injection:**  The code uses a template engine (`template.Template.Execute`) without proper escaping of user-supplied data in `ReportViewData`.  This leaves the application vulnerable to template injection attacks if user input is not properly sanitized before being passed to the template.\n\n3.  **Error Handling:** While error handling is present, it could be improved.  The `MkdirAll` and `Create` functions return errors that are wrapped but not checked for specific error types.  This makes debugging difficult.  Example:  `if err != nil { return fmt.Errorf(...) }`  should be more specific error handling.\n"
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 1,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "ddf38042c6987a30980ecdba0a2252440bfb5bc3670190d023e8fae9e3fffcb7",
    "id": "eJydVMFO3DAQ/ZWpJUqCsgk9oEqpOKBdEK0KG8G2veTiJpNdC8eO7ElThPj3yvZmsyxCqrhNJjNv3nse+4lxa9FaodYrrSXL2fLXxX0xWy2L2adTlrBK1zjXilARy1nHqwe+RjDYaUOlKpVoXQRRqUoqWdNSyUK4oVZmhG0nOeGY1HaMOk6brBESXeCSsUPLMrjz0L+MIDRQYyMUWqANglCEpuEVQqMNDEaQUGvgWy6pb17OixwupNSDhVo0DRpU5GvRWIiuVzffE/h2v7xNAKlKY9+0+FrkcC3WGzQziX9QQqvrXqKFGjtUNWgFtBF2YpCWih47fMl14vfkJPpsVHPi27KfAocFJ56A7qnrqeC0AUtGqHUMaIw2pXremuCIvgRvO4ktKrIvhzorXPEWM7hwf1fkcKWr3qIn7wsMqhqNt0zV4JyferyYVzMtmb6ioGY8SDgZo3Q1nm1g3fSqglscDmGiGKKTw2QSBMdb8LaTPgP5Oezwb3GISuZON3SWLE6velXZaCzxX3FacGMxmgpHYm6o2yoSjQf/cA5KyDCyJIPUG+UyCTQtpZeOUBOVrOFCYg2koXPAwb1xZA5HQ8k8WQ/tpI9QHw9VPk1dTuJz4qbt2xUN8MqaGN6xOUFU+LsQ3sfxbqULYaKpb9+Q/By0TW8eamEupIx27Qmcfj47i7+87dobhlUG3Y4EIKiFwYq0eYTjI3s8Orc3Zd/EHf0rITHZozf3mG8oeAe5vdsSbsFrcm7KwRHX2KCBiWE6l9piFAfmk59Dutvfy79Y9TvmQZY71Hf4igHq/1cx7BlLmFPo5LCcZT8sGpttUJlHydvfWdtLEp3EzL3xEhuaVVJk4TnNwpuZrjV7/gf5xzMz"
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/html.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:19:35.697Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "ee8874e44afd7b119fbb732af8196de07924377dab27a13a00a6e13b1f14145c",
    "id": "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"
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/create.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:19:37.349Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "40d19d3f9b1481aea9bcd26574693e1326e7d27389689e1583f49add78d9426f",
    "id": "eJytUktLw0AQ/ivLHKSRpNFrblKhFaotGvHgeliTSbK42Q2zE6WU/HfJgzYFj96Wb77XsHME5T16r22ZOmcggd3b3cs+Snf76PYGQshcjitnGS1DAo3KvlSJgrBxxNJKq+v+JeRANFhwlBkdF9owkoSewYcGxcPzoBDaMlKhMhRHaSWv0SIpxnG6KEnleI+stPHi/WN0Wa5naCi4IvSVM7nwTNqWgUAiR9J2p7AN12bK80xtxmPYCKU9Y5ROmqK1mXjCn7NsEZwKD0pCbsmKqzNjgOeWiZCwSR+3EsJ+1E3ek/uiEtdncSD+b++LgnPbvswf9qGQsHI5bvuvWrlvJFViNBKXFddGwiwrkLaDEAptcK+4ggTiV4/k4wotHYyqP+O6Nawbg/HFAYwHEmeEinFZOuh+AZGT5Pg="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/html.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:19:37.937Z",
    "codeReview": {
      "review": "The code has three critical areas of concern:\n\n1.  **Redundant Calculations:** The code recalculates file-level averages multiple times, leading to unnecessary computations.  Lines like `for _, detail := range detailsList` within the `GenerateRepoHTMLReport` function are examples of this.\n\n2.  **Inefficient Data Handling:**  The use of `groupedDetails` and then recalculating averages from the original data in the `GenerateRepoHTMLReport` function is inefficient.  The code should store the necessary data in the `ReportNode` structure to avoid redundant lookups.\n\n3.  **Lack of Clarity in Coverage Calculation:** The `calculateCoverage` function's logic is complex and not immediately obvious.  The use of `thresholdGrade` and the different coverage values based on grade comparisons needs better documentation and potentially a more structured approach.\n"
    },
    "gradingDetails": {
      "dependencyInversionScore": "B",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "A*",
      "openClosedScore": "B",
      "singleResponsibilityScore": "B"
    },
    "hash": "375533e6780df7c2d3f544c39ea914ff891efc812144d1494be379f7acd1c41e",
    "id": "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"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/create.go",
    "grade": "A",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:19:38.290Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "dependencyInversionScore": "A*",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "A*",
      "openClosedScore": "A",
      "singleResponsibilityScore": "A"
    },
    "hash": "df3fb56e6f3e2663b0115a9d824ff7fe2c36c3484a57b8bda5e8d97aefa85d69",
    "id": "eJytUktrwzAM/itCh9GMtLnn2kJb6B5s3WnewUuUxMyxg6xslJL/PvKgTWHH3cyn7yWsM+oQKATjyqP3FlN8fTrsNxhj5nNaeyfkBFNsdPalSwKmxrMop5yp+xeogWipkGVmTVIYK8QKe4acGoL9y6AA44S40BnBWTklW3LEWmicLkrWOW1ItLEB3j9Gl9V2hsYgFVOovM0hCBtXRkDMnpXrLmE7qe2UF4TbTMawETr2jFE6aYrWZfBIP1fZIroUHpRM0rKDuytjgOeWKSjcHR8OCuN+1E3ek/uigvurOIL/2/um4Ny2L/OHfQwK1z6nQ/9Va/9NrEtajsRVJbVVOMuKlOswxsJYetZSYYrJWyAOSUWOT1bXn0ndWjGNpeTmAMYDSTImLbQqPXa/U43jOw=="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/read/fileReader.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:19:38.306Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "74e8a175833f0b39f743aa32bb1ed74684e890f5696d69a243428a14f0bec037",
    "id": "eJydVlFv20YM/iucgBby4Mjbqwc/DG6xpSiSIGmxF71cJJ51i3Qn8Kh4RtH/PvBOZ0uZ0xjLS2SKR378+JG6b5nyHr03dvfFuTZbZ7d//f5wd/Xl9u7q11+yZVa5GrfOMlrO1lmvqie1QyBUdWlLa7reEUNe2pLL4Nui5quqNSttWkYqs/gKbeVqY3erv72zyag7To/Op6decSOHUR7EuJBEqxVsXY2fUfM9qhoJjGUkrSoB0yljPXCD4FWHpeVDj6/7f5NEYv3TeHZ0yBeQR7RFtBj0S0AiR4vSfh/Tj84pmgdC3zvrzWOLoB0FTozdBRhNdC6kWpBiihHUPIpnGipOgHp37xyD/HkmY3di3o6c3ilujuaE6Qb384AVoWL0oMDiHoz1rGyF4PQ8cRFOXzPsVfsUiTumrw1hJa7AhAjsQBtbBx9tyDMUqc2gXRu4YJD2DkKwH0NroBTQeMCu58NSHGvUamjZS1wJWQ1EaBn2jp6EvGP2GOceeSDrQdnYDzB6kt94sE5gDLYGZQ/7BgnB2BBZ8hel1YOt/sOTdHwuj9Tv2IuEPVhhvQHniz+Q93UuYmSjg/2nDVjTxhNyRqCKZQm64+KjxNN5mWllWqyl4B3y6wWv4d2+zELGkCT0uORAQjWQN8/YHmIvjgyIQzURyBGvuCXlHI/nqazLikCiCY4mxH0/o3E8lKSzDtI9chdfTvW7hhnYFD1lbWgpmU/ynsxomC5/frZAk+vCq9r4yj0j4YSjSyR1PuxMXo6gUlZ+P8b1l7SVNwQ/z2hZwIXLJbIex+WEd68meZcwkpPgjq1rqJhths0GyqzM3hRjSPN5MrynCidz403kPDT1nRdZNlTcT+WTZBGrDBiC7uLeLj45Y/MXIJdQZlOWy2xx1Pi2wepJWjFrA/5jPPtQstVuOo0PrDifJH9d0kaL/7W/cfxRwuUyYOnlD5iaAakdxqYERKAY+qDnkZsXOEZZ/yB4VJ6qqvjpnVX9yiIwGoSE4tp/MLLA3ur0GSLhcQhLU822ztkSTtvntkd7fkDEQf5P+yLel/Xlgn3pJPVb1HCNGil+ZLet85ifVPUBRe4B/aeH2xu5AzhQ4Fsz+yiK97OilApezmvMIqFCmYKkuMF9jE4y3jitc72B0buILvn7MfLit/9HRAx3iUrSKo2ep32aLTOBKS3J1tnqq0fyqwYtHVrVPa66oWXTt7iaXeFkzYWr2Hhr2Lns+7/Pd642"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/read/fileReader.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:19:38.349Z",
    "codeReview": {
      "review": "This code has three critical areas of concern.  First, `NewHistoryReader` relies on `os.Getwd()`, which is not ideal for a reusable component.  Second, the error handling for `os.Stat` could be improved by checking for `os.IsNotExist` more explicitly.  Third, the code lacks clear separation of concerns; the `HistoryReader` handles both finding the `.codeleft` folder and reading the file, which blurs responsibilities.\n"
    },
    "gradingDetails": {
      "dependencyInversionScore": "A*",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "A",
      "openClosedScore": "B",
      "singleResponsibilityScore": "B"
    },
    "hash": "c3d36054438975005bb4dece31e0a36ede3fc646e9b3e26562f5bdcfa0a3e3cb",
    "id": "eJydVlFv4zYM/iucgDs4Q+a8Z8hTeth6KNqh3d78otpUrNWRDIpuFhzuvw+UrMTu0muwvtShKfLjx4+0vikdAoZg3e5P7zu1Vk8Pd7c3aqlq3+DWO0bHaq16Xb/oHQKhbipXObvvPTEUlau4ir4dGv6l7uzK2I6RKpVeoat9Y91u9XfwLhvNnvOjD/mp19zKYZQHMS4k0WoFW9/gHRp+RN0ggXWMZHQtYPbaugDcIgS9x8rxscf3/b9JIrH+bgN7OhYLKBLaMlkshiUgkadF5b6P6UfnHC0AYei9C/a5QzCeIifW7SKMNjmXUi1IMeUIah4lMA01Z0C9f/SeQf4Ck3U7MW9HTv/Q3J7MGdM9HuYBa0LNGECDwwNYF1i7GsGbeeIynr5lOOjuJRF3St9YwlpcgQkR2IOxrok+xlJgKHObwfgucsEg7R2E4DCGNkA5oA2A+56PS3Fs0Oih4yBxJWQ9EKFjOHh6EfJO2VOcR+SBXADtUj/Amkl+G8B5gTG4BrQ7HlokBOtiZMlfVs4Mrv4PT9LxuTxyv1MvMvZohfUGfCh/Qz40hYiRrYn2nzbgbJdOyBmBKpYlmD2XXySeKSpltO2wkYJ3yO8XvIZPh0rFjDFJ7HHFkYR6oGBfsTumXpwYEId6IpATXnHLyjkdL3JZ1xWBRBMcbYz7eUbjeChLZx2le+IuvZzqdw0zsDl6ztrSUjKf5T2Z0Thd4fJsgSG/j68aG2r/ioQTjq6R1OWwM3l5glo7+f2c1l/WVtES/DyjZQFXLpfEehqXM96DnuRdwkhOhju2rqVythk2G6hUpT4UY0xzNxnec4WTuQk2cR6b+imILFsqH6fyybJIVUYMUXdpb5dfvXXFG5BLqNSU5UotThrftli/SCtmbcB/bOAQS3bGT6fxiTUXk+TvS9oa8b8N956/SLhCBiy//AFTMyCNx9SUiAg0Qx/1PHLzBsco6x8ET8rTdZ2+ubOq31kE1oCQUN6GGysL7KNOXyASnoe4NPVs61ws4bx9Hnp0lwdEHOT/tC/ifV1frtiXXlJ/RA03aJDSR3bb+YDFWVU3KHKP6L8+PdzLHcCDhtDZ2UdRvF815VTwdl5TFgkVyxQk5T0eUnSS8cZpnesNjN5lcik+j5EXv/4/IlK4a1SSV2nyPO9TtVQCU1qi1mr1V0AKqxYdHTu9f17th45t3+FqdoWTNRevYuOtYefV938BC8OseQ=="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/read/findCodeLeft.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:19:38.378Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "061dc9c4abad3387bc1535520f6ddbb23d4d8a2f74e37a4dfce9de013af3f8c7",
    "id": "eJx1U01v2zAM/SucgHU24FjbNUAOW9oBBQa0WDv0oosqU7EQmQooOVlQ5L8PsuN8bN1JND/fe6TfhI4RY3S0eg7Bi7l4ePn69Dh7fnicffksKmFCg8tACSmJudhos9YrBEbdKFLkuk3gBIUilZSwXVJiNEOcrI1OrbTOYzays8yFUoJ11CxDgx5t+omm5+i2CBE1mxYj8OTye7CBQUPjGE0KvAfSHTagRG2O9UpATw0yKMEhJCVqRbYn8/6QIudATOxoVUIxGhUgc+AS3jLurWaYmj/q1B6zM3SVkBnmC5hI1S/ar4eeFeShxeZcUIEjGyDE+rvzeE82VLDTfn3HPM0bnnGqSs6ewh8WQM5PAZUYU880hUfvYXykhGWLZg3OgumZkRIMIFz8v24/Bt1OYzPO+j7eOi5KuLk5s/umIw6USlgsrovP4K60WgzDp5CU8LR2G2gwGqTG0Qpsz6lFhkAGYYeftgg29NSAhk4n0/5F+QQl97l119yPOeR8/j7k68p08B8Fj4lKKDHsekgfF5pluyKwGNLerbRdqu/yymxxocWFyE3ACBQS4G8XE2ja71pkHA90Dh9j7pKvpbxAcBxxiaIaOR0UiUpkCbJTzIX8FZGjbJF473X3KrveJ7fxKKfqmfFO5l9UTuefIdarIA5/ACNda2o="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/read/findCodeLeft.go",
    "grade": "C",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:19:38.393Z",
    "codeReview": {
      "review": "1. **Missing Error Handling:** The `filepath.Walk` function's error is not checked within the loop.  This could lead to silent failures if there's an issue during traversal.  Example:  `if walkErr != nil { return walkErr }` should be outside the loop.\n\n\n2. **Inconsistent Naming:**  `.codeLeft` in the code and `.codeleft` in the function signature.  This inconsistency should be fixed for better readability and maintainability.\n\n\n3. **Unnecessary Variable:** The `codeleftPath` variable is assigned within the loop but not used until after the loop.  This is unnecessary and can be simplified.\n"
    },
    "gradingDetails": {
      "dependencyInversionScore": "F",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "B",
      "openClosedScore": "F",
      "singleResponsibilityScore": "A*"
    },
    "hash": "16017d114de28950cfca0fbcc107aa6a7a31e2d336052c25240cbcf1e8c3a686",
    "id": "eJx1U02L2zAQ/StTQbc2uNY94EuTLQQWWrotveiiyqNYRB6ZkZw0LPnvRXacTdrtSeP5fO/N+EXoGDFGR7vvIXixEs9fnrYbUQkTWlwHSkhJrMSgzV7vEBh1q0iR64fACQpFKilh+6TEbIa4WINOnbTOYzays8yFUoJ11K5Dix5t+oZm5OgOCBE1mw4j8OLyJ7CBQUPrGE0KfALSPbagRG0u9UrASC0yKMEhJCVqRXYk8/aQIudATOxoV0IxGxUgc+ASXjLug2ZYmn/VqbtkZ+gqITOsGlhI1T+13089K8hDi+G1oAJHNkCI9WfncUs2VHDUfv/IvMybnnmqSs5ew+8aIOeXgEqMaWRawrP3PD9SwrpDswdnwYzMSAkmEC7+X7enSbfr2Iyz3saN46KEh4dXdp90xIlSCU1zX/wK7k6rZhq+hKSE570boMVokFpHO7Ajpw4ZAhmEI344INgwUgsaep1M9xflK5TcZ+PuuV9yyPn8fc7XlengPwpeEpVQYtr1lD4vNMt2R6CZ0t6stH2qH/PKbHGjxY3IbcAIFBLgbxcTaDodO2ScD3QF72Pukq+lvEFwGXGLopo5nRWJSmQJslOshPwRkaPskPjkdf9L9qNPbvAol+qPxjuZf1G5nH+GWO+COP8BPzxprQ=="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/read/configReader.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:19:38.408Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "58b488f94f88fed7563d4a3e63b187e10e785860e7c8dc3f36ec2d8873163355",
    "id": "eJydVk1v2zgQ/StTAS3khSPtXl34ULjBIkWRBE6LXnRhqKHNjUwaw1G9RtH/vhhSn9mkCZpLbGr43puZNyP/yFQIGIJ1uy/eN9kqu/n24e724svN7cVff2bLTPsaN94xOs5W2VHpB7VDIFR15SpnD0dPDHnlKq5ibIOGL3RjSz4fMVRZeoJO+9q6XflP8K4/NAfuP/oh8qh4XxrboHyQw4XwlCVsvDN2t0VVI4ENQBiO3gV73yAYT1GSdTvgPYKOsYWQgWAVlRM5c4zA1GqGH8K7xaPfes8gf4HJup0cb7qEbhXvh+OfnaBrPM3wNKFiDKDA4QmsC6ycRvBmRlvEu1cMJ9U8hKh2IK8toWZPZ2BCBPZgrKtjjLEUGIq+wmB8E+vAIKVtHSOFDtoA9YA2AB6OfF5KYI1GtQ0HwY1FaonQMZw8PUjhBvaEs0VuyQVQDpDIE1gz4bcBnBcZratBufNpj4RgXUQW/qJypnX6cZXyBeR/TA+WCX2R+tArj6ewWoMPxd/IpzoXG7A18fzNGpxt0g25I0LlZAnmwMWl4Jm8yoyyDdaS7g75+XRX8PZUZZExksT+VhxLoFsK9js259SJIX8J0BNzDHolrHfNcD3v03pdEkg00aEj7rtpzbo7vW9W0bVD6dLDqXVXMNPag/ekmpZCPDpbWBJfnKrw5EyBIX+IT0ZXPGehbgLGoVDRNaOxniSYecwTaOXk+31aP73Bck0wc9Rioj/aLW6iIh3M7VaWcOlCS/goD9k9Qh+Qu45pKmbLYL2GKquyFz0YMT9PJnbMaDIswcapp9jMt0HcqKnYTl3TuyFmESVEt6U9WXzy1uWPNC5BNvJQ0ypbDMbe7FE/SN2nNcd/beAQ83XGTyfwjhXnI/PzLrZGwq/CtedLQctlpvqHv6jSVEbtMfU96gGVujGUZa6iM/IvoJPFlNbpJTfN+JnBtwakAMVV+GhlX73U4v/XEO7buCHVbMk8pX/cNTdHdE+OgTyX/9OGSPCrGvKK3eiF+IWqcI0GKb1KN40PmI9e+ohi8Sj9093NNVjHfpz49JKV0O+KOhqYDmRCF4iYnCgorvGUUCkXyml6qzV00UUKyd8l0MX730s/ob3CFh1WRzduzGyZiUjpQ7bKyq8BKZR7dHRu1OG+PLQN22OD5ezHkSywUk9/Fux89vM/1K9prA=="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/read/configReader.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:19:38.453Z",
    "codeReview": {
      "review": "This code has three critical areas of concern.  First, `NewConfigReader` relies on a recursive function (`findCodeleftRecursive`) which is not ideal for large repositories.  Second, error handling is not consistent; some errors are wrapped, others are not.  Third, the code lacks clear separation of concerns; the `ConfigReader` handles both finding the `.codeleft` folder and reading the config file.  Example: `findCodeleftRecursive` function should be extracted.  Example:  Error handling in `ReadConfig` should be more consistent. Example:  Create a separate function to handle finding the `.codeleft` folder.\n"
    },
    "gradingDetails": {
      "dependencyInversionScore": "B",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "B",
      "openClosedScore": "B",
      "singleResponsibilityScore": "A"
    },
    "hash": "14cf29d2c5fee1a25332a9eaf340382cd6cdb2bab5f4667b49c29d8b1b0b0241",
    "id": "eJydVk1v2zgQ/SuzAlrIC69098InJyhSFEnhdG+6MNTQZiOTwnBU1yj634sh9ZkmTbC5xKaG772ZeTPyj0yFgCFYd/jifZNtsvu7TzdX2TrTvsadd4yOs03WKv2oDgiEqq5c5eyp9cSQV67iKsY2aPgf3diSLy2GKktP0GlfW3covwbvhkNz4uGjHyNbxcfS2AblgxyuhKcsYeedsYc9qhoJbADC0HoX7EODYDxFSdYdgI8IOsYWQgaCVVRO5CwxAlOnGX4I7x5bv/eeQf4Ck3UHOd71CX1WfByPf/aCbvG8wNOEijGAAodnsC6wchrBmwVtEe/eMJxV8xii2pG8toSaPV2ACRHYg7GujjHGUmAohgqD8U2sA4OUtnOMFHpoAzQA2gB4avmylsAajeoaDoIbi9QRoWM4e3qUwo3sCWeP3JELoBwgkSewZsZvAzgvMjpXg3KX8xEJwbqILPxF5Uzn9NMq5SvI/54frBP6KvVhUB5PYbMFH4oPyOc6FxuwNfH8ry0426QbckeEyskazImLa8EzeZUZZRusJd0D8svpbuDducoiYySJ/a04lkB3FOw3bC6pE2P+EqBn5hj1StjgmvF6PqT1tiSQaKZDR9z385r1dwbfbKJrx9Klh3PrbmChdQAfSDWthXhytrAkvjhV4dmZAkP+FJ9MrnjJQv0ETEOhomsmYz1LsPCYJ9DKyfeHtH4Gg+WaYOGo1Ux/tFvcREU6WNqtLOHahY7wSR6ye4Q+IPcd01QslsF2C1VWZa96MGJ+mk3slNFsWIKNU0+xme+CuFFTsZ+7ZnBDzCJKiG5Le7L46K3Ln2hcg2zksaZVthqNvTuifpS6z2uO323gEPN1xs8n8J4V5xPzyy62RsJvwq3na0HLZaaGh3+o0lxG7TH1PeoBlboxlmWpojfyH6CTxZTW6e02z/iFwbcGpADFTbiysq9ea/HvNYSHLm5ItVgyz+mfds1di+7ZMZDn8n/eEAl+U0PesBu9EL9SFa7RIKVX6a7xAfPJS1coFo/SP97f3YJ17KeJTy9ZCf2mqKeB+UAmdIGIyYmC4hbPCZVyoZynt9lCH12kkPx9Al39+//ST2hvsEWP1dNNGzNbZyJS+pBtsvK/gBTKIzq6NOr0UJ66hm3bYLn4cSQLrNTznwUHn/38BS4eZ+8="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/types/model.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:19:39.315Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "f7a656feae48a465e9a47fe9a907c837f9aa9d6e225b3fac8cc672d87ccd3d00",
    "id": "eJx1U01vm0AQ/SujPcemufpWIUXqoTWtHeUQImUNA2y77NCdQS6K/N+r5SsGJ5zQe29m3gyPN6WZkdm48khk1U7tn74eks1xn2zuv6g7lVGOMTlBJ2qnGp390SWCdA1y6lIXRRCTK0wJHhuPjE4YpEJg8W0mrUegogeyXrb9zeSgMBa3qQtdpvJBD2+pS+VYeeSKbB5Q40p4DVW7VMlEpOo1CA+Ytd5IB4vyVPZnzQ2ciOxcSgEay1KJzwhLPjvjyF5mjMf2I/Gz1TYMW846kDU5hGfRjwM8z0v8L9R5txY1A/xuy6J2MeW48jbB70KqG4v/gpulcsY/kCaePlMnnm62/zusO51aFyhd7I2YTNvVDb4b9jpuVievR/T2roteI/2tdORx1fjBWGQAeH4JbwBzi5Agnnd8IJujZ3h+WQWmGIgbB6Yf1sOXMcb9gKsQ6z6lIAQnhEGfg3HXWR4T3Fde+/6ha1xH1+l6+nyJlmpNN1qqyY6669cLMrVT0SOj56hC5zur61NUt1ZMYzEKv6bFQjaZNVH/R0Z1gLYlqct/bMFpJg=="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/types/model.go",
    "grade": "A",
    "username": "Hlamb",
    "timestamp": "2025-04-11T10:19:39.976Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "dependencyInversionScore": "A*",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "A*",
      "openClosedScore": "B",
      "singleResponsibilityScore": "A"
    },
    "hash": "439add89080dad73e535702fb5e39322cf3a5d179abdeb67fa51ed3d6e4029c1",
    "id": "eJx1U11v2zAM/CuEnrv4Pa8eChTY1mzpnqoCVWza1iaLmkgjM4r890H+aux0fjLujuSRPr8pw4zM1tdPRE7t1fHxy8NndacKKjEnL+hF7VUwxW9TI0gfkLXXPssgJ1/ZGiKGiIxeGKRBYIldIV1EoGoAikG2+8XkobIOd9qnLnP5qIc37bU8NRG5IVcm1PoaXlPVXiuZCa1ek/CIRRet9LAq1/J4NhzgROSWUkrQVKYlPyOs+eKME3tZMJ7aT8T3zrg0bD3rSM6WkJ5VP07wMu8Qf6Ap+60ojPC7LYfG51TixtsMvwupDQ7/Jjdr5YJ/ID1E+p/6EOlm+z/juvOpTYXS59GKLYzb3OCr5WjysDl5O6G3d131muiH2lPETeN765AB4PklvQEsLVKCeNnxnlyJkeH5ZROYaiRuHNhh2ABfphgPA65CbIaUghCcEEZ9CdZfZ3lK8FB57fubaXEbXW/a+fMdjDRbOhhpZjvqblgvydReZT8ZI2cN+tg7056ytnNig8Ms/ZoOK/lUOJsNf2TWJmhXk7r8A7CbZ2k="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/assessment/assessor.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-04-11T12:02:33.228Z",
    "codeReview": {
      "review": "This code has three critical areas of concern.  First, `AccessorGrade`'s `Assess` method uses a boolean (`failed`) that is unnecessarily inverted.  Second, `AccessorAverageCoverage`'s `Assess` method has a potential division by zero error if `details` is empty.  Third, both `Assess` methods lack clear error handling;  if `GradeNumericalValue` or `threshold` are invalid types, the program will panic.  For example, in `AccessorGrade`,  `ag.Calculator.GradeNumericalValue(detail.Grade)` and `ag.Calculator.GradeNumericalValue(threshold)` could fail if the input types are incorrect.\n"
    },
    "gradingDetails": {
      "dependencyInversionScore": "A*",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "B",
      "openClosedScore": "A",
      "singleResponsibilityScore": "B"
    },
    "hash": "7ce72fe1bbe907dbb10b84ce89c22bf6085218d9e0158676172783ea602fe531",
    "id": "eJylVe9r2zAQ/Vdugg5785zSfTPNIKRsDEZX6NYv0xiqfHbMZClI545S8r8PWbKTOBnrj3wSp3vv3Z3fRQ9MOIfONbr+ZoxiBbv++uXzBcuYNCUujSbUxAq2FvK3qBFCdouauOa6adfGEiRcc+I9QmFF76RqZlWjCC1n4apqaTga50+ph9P9GmEhJTpnLDSa0FZCIjz4zEWvlNDKolsZVYIj2+g6gxJJNMrBj59BI/9kRYkXIZrCrTGK680Bf5/lSTpJQWEplOyUIGMh/Hb5tpc+9aYxSlBj9NJ0vkwYAy5qVZ2WcIl/9uQSuZU4Tp7B3b+p0+1w+oItUmc1vN7T6G92myliN1vtLKRMmygOtPvEzW5HiajhzZ5eCi/5MqGRSjQKSyjmQLbDPmIs/BoY/IUVusaRMTbZVCDqfNtqELjsWrSNFOpGqA6TgMljseePQIydpIPQWOIcKqEcDlFR59Mp5ouyHGNRPA35mzjOvvBXkTEqHGO6so2mJB1R8XsH4DFPL80dWr+W/9mdK7QSNfm0Z+/PIkiNkrub9PT1mLAlj9qCUfvoNkwoH15ieiG3rp/wHvr/qdMN5ZMh0Tv99PH+D5i38xjPh5rG7ZjE4RwOqhwdLoR8tpkThcO1S1OYz+F0IK5aCkZWOuHs0vg/PnRAJr4dnEXC0d1xv/r5cxKx9GIOlTKC3p8lfdspzMbAnroHrYVzHjGAP+yAJwNIg4zfyB417OOxaUwX0vf2ce2DVWJcfk0lWpsBZ9EjIOPgCzjJz6qTE841Z9lQVrpjW6/de45lzE/oStCKFWz23aF1sxVqe69EeztrO0XNWuFs73XdPsPxaGxeG7b5C8hD6CI="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/assessment/assessor.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-04-11T12:02:57.210Z",
    "codeReview": {
      "detailedReview": {
        "tasks": [
          {
            "done": false,
            "titleTask": "interfaceSegregation",
            "violatingCode": "The `Accessor` and `AccessorCoverage` interfaces both have an `Assess` method, but with different parameters.  This violates the Interface Segregation Principle because a single interface forces implementations to implement methods they don't need.  For example, `AccessorGrade` doesn't use the `thresholdPercent` parameter, and `AccessorAverageCoverage` doesn't use the `threshold` string parameter.  A better design would separate these concerns into distinct interfaces.\n",
            "codeResolution": "The `Accessor` interface has two distinct assessment methods (one for grades, one for coverage).  This violates the Interface Segregation Principle (ISP).  Refactor into separate `GradeAccessor` and `CoverageAccessor` interfaces, each with a single `Assess` method tailored to its specific type of assessment.  This allows clients to depend only on the interfaces they need.\n",
            "severity": "Medium",
            "rationale": "The `Accessor` interface forces both grade and coverage assessment logic into a single interface.  This violates the Interface Segregation Principle (ISP) because `AccessorGrade` and `AccessorAverageCoverage` have distinct assessment methods and responsibilities.  This leads to less cohesive interfaces, making future modifications and extensions more complex and potentially impacting maintainability.  A better approach would be to create separate interfaces for grade and coverage assessment, improving code organization and reducing coupling.\n",
            "lineStart": 10,
            "lineEnd": 42,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "openClosed",
            "violatingCode": "The `AccessorGrade` and `AccessorAverageCoverage` structs both implement assessment logic, but separately.  Adding a new assessment type requires creating a new struct and implementing the assessment logic again.  The `Assess` methods in both structs are nearly identical in structure, violating the Open/Closed Principle.  This is evident in the need to create separate `Assess` functions for grade and coverage assessments.\n",
            "codeResolution": "The `Accessor` interface and its implementations (`AccessorGrade`, `AccessorAverageCoverage`) violate the Open/Closed Principle.  Adding a new assessment type requires modifying the interface and potentially the calling code.  To improve this, create separate interfaces for grade and coverage assessment,  e.g., `GradeAccessor` and `CoverageAccessor`.  Each would have its own `Assess` method with appropriate parameters.  The calling code would then use the appropriate accessor type.\n",
            "severity": "Medium",
            "rationale": "The `AccessorGrade` and `AccessorAverageCoverage` types both implement assessment logic, but with different assessment criteria (grade vs. coverage).  Adding a new assessment type (e.g., complexity) would require modifying the existing code to accommodate the new logic. This violates the Open/Closed Principle because the system is not open for extension without modification.  This impacts maintainability, as adding features requires altering core assessment logic, increasing the risk of introducing bugs and making future extensions more difficult.\n",
            "lineStart": 40,
            "lineEnd": 75,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "liskovSubstitution",
            "violatingCode": "The `Accessor` and `AccessorCoverage` interfaces have different `Assess` method signatures, preventing interchangeability.  `Accessor` uses a string threshold and `filter.GradeDetails`, while `AccessorCoverage` uses an integer threshold and `filter.GradeDetails`.  This violates the Liskov Substitution Principle because an `Accessor` cannot be directly substituted for an `AccessorCoverage` and vice-versa.\n",
            "codeResolution": "The `Accessor` and `AccessorCoverage` interfaces have differing `Assess` method signatures, preventing substitutability.  Create a unified interface, perhaps `CodeAccessor`, with a generic `Assess` method that accepts an interface representing assessment criteria.  Concrete types would implement this interface to handle specific assessment logic (grade or coverage).  This allows for interchangeable assessment strategies without violating the Liskov Substitution Principle.\n",
            "severity": "Medium",
            "rationale": "The Liskov Substitution Principle (LSP) is violated because `Accessor` and `AccessorCoverage` have different `Assess` methods.  `Accessor` uses a string threshold and `AccessorCoverage` uses an integer threshold.  This prevents interchangeable use; you cannot substitute one for the other without altering the calling code, impacting maintainability and potentially causing runtime errors if the wrong type is used.\n",
            "lineStart": 40,
            "lineEnd": 75,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "singleResponsibility",
            "violatingCode": "The `AccessorGrade` type violates the Single Responsibility Principle because it handles both assessment logic (`Assess` method) and violation counting/printing (delegated to `ViolationCounter`).  The `Assess` method iterates through grade details, performs comparisons, and updates the `ViolationCounter`.  This mixes assessment with reporting, making the class harder to maintain and test.  Similarly, `AccessorAverageCoverage` combines assessment and reporting.\n",
            "codeResolution": "The `AccessorGrade` and `AccessorAverageCoverage` types violate the Single Responsibility Principle (SRP).  Both handle assessment logic and violation reporting.  Refactor by separating these concerns. Create a `ViolationReporter` interface and have `AccessorGrade` and `AccessorAverageCoverage` depend on it.  This allows for easier testing and extension of violation reporting mechanisms.  For example:\n\n```go\ntype ViolationReporter interface {\n    Report(violations []filter.GradeDetails)\n}\n\ntype ConsoleViolationReporter struct{}\n\nfunc (c *ConsoleViolationReporter) Report(violations []filter.GradeDetails) {\n    // ... existing violation printing logic ...\n}\n\ntype AccessorGrade struct {\n    Calculator       filter.GradeCalculator\n    reporter         ViolationReporter\n}\n\nfunc (ag *AccessorGrade) Assess(threshold string, details []filter.GradeDetails) bool {\n    // ... assessment logic ...\n    if !passed {\n        ag.reporter.Report(violations)\n    }\n    return passed\n}\n```\n",
            "severity": "Medium",
            "rationale": "The `AccessorGrade` type violates the Single Responsibility Principle because it handles both assessment logic and violation reporting.  This coupling makes the code harder to maintain, test, and potentially less efficient.  Changes to one aspect (e.g., the assessment algorithm) could inadvertently affect the other (violation reporting), increasing the risk of bugs and hindering future development.  Separating these concerns into distinct types would improve modularity and reduce complexity.\n",
            "lineStart": 26,
            "lineEnd": 36,
            "status": ""
          }
        ],
        "codeReviewTitle": "SOLID Code Review"
      },
      "upgradedCode": {
        "oldCode": "package assessment\n\nimport (\n\t\"codeleft-cli/filter\"\n\t\"fmt\"\n\t\"os\"\n)\n\n// Assessment is a package that provides functionality to assess code quality based on grades and coverage.\ntype Accessor interface {\n\tAssess(threshold string, details []filter.GradeDetails) bool\n}\n\ntype AccessorGrade struct {\n\tCalculator       filter.GradeCalculator\n\tViolationCounter Violations\n}\n\nfunc NewAccessorGrade(calculator filter.GradeCalculator, violationCounter Violations) Accessor {\n\treturn &AccessorGrade{\n\t\tCalculator:       calculator,\n\t\tViolationCounter: violationCounter,\n\t}\n}\n\nfunc (ag *AccessorGrade) Assess(threshold string, details []filter.GradeDetails) bool {\n\tfailed := true\n\tfor _, detail := range details {\n\t\tif ag.Calculator.GradeNumericalValue(detail.Grade) < ag.Calculator.GradeNumericalValue(threshold) {\n\t\t\tfailed = false\n\t\t\tag.ViolationCounter.AddViolation(detail)\n\t\t}\n\t}\n\tif !failed {\n\t\tag.ViolationCounter.Print()\n\t}\n\treturn failed\n}\n\ntype AccessorCoverage interface {\n\tAssess(thresholdPercent int, details []filter.GradeDetails) bool\n}\n\ntype AccessorAverageCoverage struct {\n\tViolationCounter Violations\n}\n\nfunc NewAccessorAverageCoverage(violationCounter Violations) AccessorCoverage {\n\treturn &AccessorAverageCoverage{\n\t\tViolationCounter: violationCounter,\n\t}\n}\n\nfunc (aac *AccessorAverageCoverage) Assess(thresholdPercent int, details []filter.GradeDetails) bool {\n\ttotal := 0\n\tfor _, detail := range details {\n\t\ttotal += detail.Coverage\n\t\tif detail.Coverage < thresholdPercent {\n\t\t\taac.ViolationCounter.AddViolation(detail)\n\t\t}\n\t}\n\tif (len(details)) == 0 {\n\t\tfmt.Println(\"No files to assess\")\n\t\treturn false\n\t}\n\n\taverage := float32(total) / float32(len(details))\n\tpass := average >= float32(thresholdPercent)\n\n\tif !pass {\n\t\taac.ViolationCounter.Print()\n\t}\n\tfmt.Fprintf(os.Stderr, \"Average coverage: %.2f%%\\n\", average)\n\treturn pass\n}\n",
        "newCode": "package assessment\n\nimport (\n\t\"codeleft-cli/filter\"\n\t\"fmt\"\n\t\"os\"\n)\n\n// ViolationReporter interface for reporting violations\ntype ViolationReporter interface {\n\tReport(violations []filter.GradeDetails)\n}\n\n// ConsoleViolationReporter implements ViolationReporter and prints violations to the console\ntype ConsoleViolationReporter struct{}\n\nfunc (c *ConsoleViolationReporter) Report(violations []filter.GradeDetails) {\n\tfor _, v := range violations {\n\t\tfmt.Printf(\"Violation: File: %s, Grade: %s, Coverage: %d\\n\", v.File, v.Grade, v.Coverage)\n\t}\n}\n\n// GradeAccessor interface for assessing code grades\ntype GradeAccessor interface {\n\tAssess(threshold string, details []filter.GradeDetails) bool\n}\n\n// CoverageAccessor interface for assessing code coverage\ntype CoverageAccessor interface {\n\tAssess(thresholdPercent int, details []filter.GradeDetails) bool\n}\n\n// AccessorGrade assesses code grades\ntype AccessorGrade struct {\n\tCalculator       filter.GradeCalculator\n\tReporter         ViolationReporter\n\tViolationDetails []filter.GradeDetails\n}\n\n// NewGradeAccessor creates a new AccessorGrade instance\nfunc NewGradeAccessor(calculator filter.GradeCalculator, reporter ViolationReporter) GradeAccessor {\n\treturn &AccessorGrade{\n\t\tCalculator: calculator,\n\t\tReporter:   reporter,\n\t}\n}\n\n// Assess assesses code grades against a threshold\nfunc (ag *AccessorGrade) Assess(threshold string, details []filter.GradeDetails) bool {\n\tpassed := true\n\tag.ViolationDetails = []filter.GradeDetails{} // Reset violations\n\tfor _, detail := range details {\n\t\tif ag.Calculator.GradeNumericalValue(detail.Grade) < ag.Calculator.GradeNumericalValue(threshold) {\n\t\t\tpassed = false\n\t\t\tag.ViolationDetails = append(ag.ViolationDetails, detail)\n\t\t}\n\t}\n\tif !passed {\n\t\tag.Reporter.Report(ag.ViolationDetails)\n\t}\n\treturn passed\n}\n\n// AccessorAverageCoverage assesses code coverage\ntype AccessorAverageCoverage struct {\n\tReporter         ViolationReporter\n\tViolationDetails []filter.GradeDetails\n}\n\n// NewCoverageAccessor creates a new AccessorAverageCoverage instance\nfunc NewCoverageAccessor(reporter ViolationReporter) CoverageAccessor {\n\treturn &AccessorAverageCoverage{\n\t\tReporter: reporter,\n\t}\n}\n\n// Assess assesses code coverage against a threshold\nfunc (aac *AccessorAverageCoverage) Assess(thresholdPercent int, details []filter.GradeDetails) bool {\n\ttotal := 0\n\taac.ViolationDetails = []filter.GradeDetails{} // Reset violations\n\tfor _, detail := range details {\n\t\ttotal += detail.Coverage\n\t\tif detail.Coverage < thresholdPercent {\n\t\t\taac.ViolationDetails = append(aac.ViolationDetails, detail)\n\t\t}\n\t}\n\tif len(details) == 0 {\n\t\tfmt.Println(\"No files to assess\")\n\t\treturn false\n\t}\n\n\taverage := float32(total) / float32(len(details))\n\tpass := average >= float32(thresholdPercent)\n\n\tif !pass {\n\t\taac.Reporter.Report(aac.ViolationDetails)\n\t}\n\tfmt.Fprintf(os.Stderr, \"Average coverage: %.2f%%\\n\", average)\n\treturn pass\n}",
        "changes": [
          {
            "oldCode": "package assessment",
            "newCode": "package assessment",
            "reason": "Unchanged",
            "start": 1,
            "end": 1
          },
          {
            "reason": "Unchanged",
            "start": 2,
            "end": 2
          },
          {
            "oldCode": "import (",
            "newCode": "import (",
            "reason": "Unchanged",
            "start": 3,
            "end": 3
          },
          {
            "oldCode": "\t\"codeleft-cli/filter\"",
            "newCode": "\t\"codeleft-cli/filter\"",
            "reason": "Unchanged",
            "start": 4,
            "end": 4
          },
          {
            "oldCode": "\t\"fmt\"",
            "newCode": "\t\"fmt\"",
            "reason": "Unchanged",
            "start": 5,
            "end": 5
          },
          {
            "oldCode": "\t\"os\"",
            "newCode": "\t\"os\"",
            "reason": "Unchanged",
            "start": 6,
            "end": 6
          },
          {
            "oldCode": ")",
            "newCode": ")",
            "reason": "Unchanged",
            "start": 7,
            "end": 7
          },
          {
            "oldCode": "\n// Assessment is a package that provides functionality to assess code quality based on grades and coverage.\ntype Accessor interface {",
            "newCode": "\n// ViolationReporter interface for reporting violations\ntype ViolationReporter interface {\n\tReport(violations []filter.GradeDetails)\n}\n\n// ConsoleViolationReporter implements ViolationReporter and prints violations to the console\ntype ConsoleViolationReporter struct{}\n\nfunc (c *ConsoleViolationReporter) Report(violations []filter.GradeDetails) {\n\tfor _, v := range violations {\n\t\tfmt.Printf(\"Violation: File: %s, Grade: %s, Coverage: %d\\n\", v.File, v.Grade, v.Coverage)\n\t}\n}\n\n// GradeAccessor interface for assessing code grades\ntype GradeAccessor interface {",
            "reason": "Modified",
            "start": 8,
            "end": 10,
            "reasonDiff": "The `Accessor` interface was replaced with `ViolationReporter`, `ConsoleViolationReporter`, and `GradeAccessor` interfaces to adhere to the Interface Segregation and Open/Closed Principles.  The original `Accessor` interface combined distinct functionalities, violating the SOLID principles.\n"
          },
          {
            "oldCode": "\tAssess(threshold string, details []filter.GradeDetails) bool",
            "newCode": "\tAssess(threshold string, details []filter.GradeDetails) bool",
            "reason": "Unchanged",
            "start": 11,
            "end": 11
          },
          {
            "oldCode": "}\n",
            "newCode": "}\n\n// CoverageAccessor interface for assessing code coverage\ntype CoverageAccessor interface {\n\tAssess(thresholdPercent int, details []filter.GradeDetails) bool\n}\n\n// AccessorGrade assesses code grades",
            "reason": "Modified",
            "start": 12,
            "end": 13,
            "reasonDiff": "The `CoverageAccessor` interface was introduced to adhere to the Interface Segregation Principle, separating the responsibility of coverage assessment from grade assessment.\n"
          },
          {
            "oldCode": "type AccessorGrade struct {",
            "newCode": "type AccessorGrade struct {",
            "reason": "Unchanged",
            "start": 14,
            "end": 14
          },
          {
            "oldCode": "\tCalculator       filter.GradeCalculator",
            "newCode": "\tCalculator       filter.GradeCalculator",
            "reason": "Unchanged",
            "start": 15,
            "end": 15
          },
          {
            "oldCode": "\tViolationCounter Violations",
            "newCode": "\tReporter         ViolationReporter\n\tViolationDetails []filter.GradeDetails",
            "reason": "Modified",
            "start": 16,
            "end": 16,
            "reasonDiff": "To adhere to the Single Responsibility Principle, the `ViolationCounter` field was replaced with a `ViolationReporter` interface and a `ViolationDetails` slice. This separates the assessment logic from the reporting logic, improving modularity and maintainability.\n"
          },
          {
            "oldCode": "}",
            "newCode": "}",
            "reason": "Unchanged",
            "start": 17,
            "end": 17
          },
          {
            "reason": "Unchanged",
            "start": 18,
            "end": 18
          },
          {
            "oldCode": "func NewAccessorGrade(calculator filter.GradeCalculator, violationCounter Violations) Accessor {",
            "newCode": "// NewGradeAccessor creates a new AccessorGrade instance\nfunc NewGradeAccessor(calculator filter.GradeCalculator, reporter ViolationReporter) GradeAccessor {",
            "reason": "Modified",
            "start": 19,
            "end": 19,
            "reasonDiff": "The `NewAccessorGrade` function signature was changed to `NewGradeAccessor` and the return type changed to `GradeAccessor` to adhere to the Interface Segregation Principle, separating grade assessment from coverage assessment.\n"
          },
          {
            "oldCode": "\treturn &AccessorGrade{",
            "newCode": "\treturn &AccessorGrade{",
            "reason": "Unchanged",
            "start": 20,
            "end": 20
          },
          {
            "oldCode": "\t\tCalculator:       calculator,\n\t\tViolationCounter: violationCounter,",
            "newCode": "\t\tCalculator: calculator,\n\t\tReporter:   reporter,",
            "reason": "Modified",
            "start": 21,
            "end": 22,
            "reasonDiff": "To adhere to the Single Responsibility Principle, the `ViolationCounter` field was replaced with a `Reporter` field of type `ViolationReporter`. This change separates the assessment logic from the responsibility of reporting violations.\n"
          },
          {
            "oldCode": "\t}",
            "newCode": "\t}",
            "reason": "Unchanged",
            "start": 23,
            "end": 23
          },
          {
            "oldCode": "}",
            "newCode": "}",
            "reason": "Unchanged",
            "start": 24,
            "end": 24
          },
          {
            "reason": "Unchanged",
            "start": 25,
            "end": 25
          },
          {
            "newCode": "// Assess assesses code grades against a threshold",
            "reason": "Added",
            "start": 26,
            "end": 26,
            "reasonDiff": "Added a comment to clarify the purpose of the `Assess` method in `AccessorGrade` as part of refactoring to adhere to SOLID principles, specifically the Interface Segregation Principle.\n"
          },
          {
            "oldCode": "func (ag *AccessorGrade) Assess(threshold string, details []filter.GradeDetails) bool {",
            "newCode": "func (ag *AccessorGrade) Assess(threshold string, details []filter.GradeDetails) bool {",
            "reason": "Unchanged",
            "start": 26,
            "end": 26
          },
          {
            "oldCode": "\tfailed := true",
            "newCode": "\tpassed := true\n\tag.ViolationDetails = []filter.GradeDetails{} // Reset violations",
            "reason": "Modified",
            "start": 27,
            "end": 27,
            "reasonDiff": "The `passed` variable initialization and the `ag.ViolationDetails` slice resetting are added to track assessment results and store violation details, respectively, which are used for reporting violations later.\n"
          },
          {
            "oldCode": "\tfor _, detail := range details {",
            "newCode": "\tfor _, detail := range details {",
            "reason": "Unchanged",
            "start": 28,
            "end": 28
          },
          {
            "oldCode": "\t\tif ag.Calculator.GradeNumericalValue(detail.Grade) < ag.Calculator.GradeNumericalValue(threshold) {",
            "newCode": "\t\tif ag.Calculator.GradeNumericalValue(detail.Grade) < ag.Calculator.GradeNumericalValue(threshold) {",
            "reason": "Unchanged",
            "start": 29,
            "end": 29
          },
          {
            "oldCode": "\t\t\tfailed = false\n\t\t\tag.ViolationCounter.AddViolation(detail)",
            "newCode": "\t\t\tpassed = false\n\t\t\tag.ViolationDetails = append(ag.ViolationDetails, detail)",
            "reason": "Modified",
            "start": 30,
            "end": 31,
            "reasonDiff": "To adhere to the Single Responsibility Principle, the violation details are now collected in the `ViolationDetails` field and reported using the injected `ViolationReporter` instead of directly managing violation counting and printing within the `AccessorGrade` struct.\n"
          },
          {
            "oldCode": "\t\t}",
            "newCode": "\t\t}",
            "reason": "Unchanged",
            "start": 32,
            "end": 32
          },
          {
            "oldCode": "\t}\n\tif !failed {\n\t\tag.ViolationCounter.Print()\n\t}\n\treturn failed\n}\n\ntype AccessorCoverage interface {\n\tAssess(thresholdPercent int, details []filter.GradeDetails) bool\n}\n",
            "newCode": "\t}\n\tif !passed {\n\t\tag.Reporter.Report(ag.ViolationDetails)\n\t}\n\treturn passed\n}\n\n// AccessorAverageCoverage assesses code coverage",
            "reason": "Modified",
            "start": 33,
            "end": 43,
            "reasonDiff": "To adhere to the Interface Segregation and Single Responsibility Principles, the `AccessorGrade` assessment logic and violation reporting were decoupled.  A `ViolationReporter` interface and a `ConsoleViolationReporter` implementation were introduced, and `AccessorGrade` now relies on the reporter for handling violations.\n"
          },
          {
            "oldCode": "type AccessorAverageCoverage struct {",
            "newCode": "type AccessorAverageCoverage struct {",
            "reason": "Unchanged",
            "start": 44,
            "end": 44
          },
          {
            "oldCode": "\tViolationCounter Violations",
            "newCode": "\tReporter         ViolationReporter\n\tViolationDetails []filter.GradeDetails",
            "reason": "Modified",
            "start": 45,
            "end": 45,
            "reasonDiff": "To adhere to the Single Responsibility Principle and separate violation reporting from assessment logic, the `ViolationCounter` member was replaced with a `ViolationReporter` interface and a `ViolationDetails` slice to store violations before reporting.\n"
          },
          {
            "oldCode": "}",
            "newCode": "}",
            "reason": "Unchanged",
            "start": 46,
            "end": 46
          },
          {
            "reason": "Unchanged",
            "start": 47,
            "end": 47
          },
          {
            "oldCode": "func NewAccessorAverageCoverage(violationCounter Violations) AccessorCoverage {",
            "newCode": "// NewCoverageAccessor creates a new AccessorAverageCoverage instance\nfunc NewCoverageAccessor(reporter ViolationReporter) CoverageAccessor {",
            "reason": "Modified",
            "start": 48,
            "end": 48,
            "reasonDiff": "To adhere to the Interface Segregation Principle and the Single Responsibility Principle, the `NewAccessorAverageCoverage` function signature was changed to accept a `ViolationReporter` instead of a `Violations` object, and renamed to `NewCoverageAccessor` to better reflect its purpose of creating a `CoverageAccessor`.\n"
          },
          {
            "oldCode": "\treturn &AccessorAverageCoverage{",
            "newCode": "\treturn &AccessorAverageCoverage{",
            "reason": "Unchanged",
            "start": 49,
            "end": 49
          },
          {
            "oldCode": "\t\tViolationCounter: violationCounter,",
            "newCode": "\t\tReporter: reporter,",
            "reason": "Modified",
            "start": 50,
            "end": 50,
            "reasonDiff": "To adhere to the Single Responsibility Principle.  The `ViolationCounter` field was replaced with a `Reporter` field to separate violation reporting from assessment logic.\n"
          },
          {
            "oldCode": "\t}",
            "newCode": "\t}",
            "reason": "Unchanged",
            "start": 51,
            "end": 51
          },
          {
            "oldCode": "}",
            "newCode": "}",
            "reason": "Unchanged",
            "start": 52,
            "end": 52
          },
          {
            "reason": "Unchanged",
            "start": 53,
            "end": 53
          },
          {
            "newCode": "// Assess assesses code coverage against a threshold",
            "reason": "Added",
            "start": 54,
            "end": 54,
            "reasonDiff": "Added a comment to clarify the purpose of the `Assess` method in `AccessorAverageCoverage` to adhere to SOLID principles, specifically the Interface Segregation Principle, by creating separate interfaces for grade and coverage assessment.\n"
          },
          {
            "oldCode": "func (aac *AccessorAverageCoverage) Assess(thresholdPercent int, details []filter.GradeDetails) bool {",
            "newCode": "func (aac *AccessorAverageCoverage) Assess(thresholdPercent int, details []filter.GradeDetails) bool {",
            "reason": "Unchanged",
            "start": 54,
            "end": 54
          },
          {
            "oldCode": "\ttotal := 0",
            "newCode": "\ttotal := 0",
            "reason": "Unchanged",
            "start": 55,
            "end": 55
          },
          {
            "newCode": "\taac.ViolationDetails = []filter.GradeDetails{} // Reset violations",
            "reason": "Added",
            "start": 56,
            "end": 56,
            "reasonDiff": "To reset the `ViolationDetails` before assessing the new details, ensuring that only violations from the current assessment are reported.\n"
          },
          {
            "oldCode": "\tfor _, detail := range details {",
            "newCode": "\tfor _, detail := range details {",
            "reason": "Unchanged",
            "start": 56,
            "end": 56
          },
          {
            "oldCode": "\t\ttotal += detail.Coverage",
            "newCode": "\t\ttotal += detail.Coverage",
            "reason": "Unchanged",
            "start": 57,
            "end": 57
          },
          {
            "oldCode": "\t\tif detail.Coverage < thresholdPercent {",
            "newCode": "\t\tif detail.Coverage < thresholdPercent {",
            "reason": "Unchanged",
            "start": 58,
            "end": 58
          },
          {
            "oldCode": "\t\t\taac.ViolationCounter.AddViolation(detail)",
            "newCode": "\t\t\taac.ViolationDetails = append(aac.ViolationDetails, detail)",
            "reason": "Modified",
            "start": 59,
            "end": 59,
            "reasonDiff": "To adhere to the Single Responsibility Principle, the violation details are now stored in the `ViolationDetails` field of the `AccessorAverageCoverage` struct and reported using a `ViolationReporter` instead of being added to a `ViolationCounter` and printed directly.\n"
          },
          {
            "oldCode": "\t\t}",
            "newCode": "\t\t}",
            "reason": "Unchanged",
            "start": 60,
            "end": 60
          },
          {
            "oldCode": "\t}",
            "newCode": "\t}",
            "reason": "Unchanged",
            "start": 61,
            "end": 61
          },
          {
            "oldCode": "\tif (len(details)) == 0 {",
            "newCode": "\tif len(details) == 0 {",
            "reason": "Modified",
            "start": 62,
            "end": 62,
            "reasonDiff": "Superfluous parentheses were removed.  The updated code style adheres to the Go convention of omitting parentheses around simple conditional expressions.\n"
          },
          {
            "oldCode": "\t\tfmt.Println(\"No files to assess\")",
            "newCode": "\t\tfmt.Println(\"No files to assess\")",
            "reason": "Unchanged",
            "start": 63,
            "end": 63
          },
          {
            "oldCode": "\t\treturn false",
            "newCode": "\t\treturn false",
            "reason": "Unchanged",
            "start": 64,
            "end": 64
          },
          {
            "oldCode": "\t}",
            "newCode": "\t}",
            "reason": "Unchanged",
            "start": 65,
            "end": 65
          },
          {
            "reason": "Unchanged",
            "start": 66,
            "end": 66
          },
          {
            "oldCode": "\taverage := float32(total) / float32(len(details))",
            "newCode": "\taverage := float32(total) / float32(len(details))",
            "reason": "Unchanged",
            "start": 67,
            "end": 67
          },
          {
            "oldCode": "\tpass := average >= float32(thresholdPercent)",
            "newCode": "\tpass := average >= float32(thresholdPercent)",
            "reason": "Unchanged",
            "start": 68,
            "end": 68
          },
          {
            "reason": "Unchanged",
            "start": 69,
            "end": 69
          },
          {
            "oldCode": "\tif !pass {",
            "newCode": "\tif !pass {",
            "reason": "Unchanged",
            "start": 70,
            "end": 70
          },
          {
            "oldCode": "\t\taac.ViolationCounter.Print()",
            "newCode": "\t\taac.Reporter.Report(aac.ViolationDetails)",
            "reason": "Modified",
            "start": 71,
            "end": 71,
            "reasonDiff": "To adhere to the Single Responsibility Principle, the violation reporting logic was decoupled from the `AccessorAverageCoverage` struct.  A `ViolationReporter` interface and a concrete `ConsoleViolationReporter` were introduced to handle the reporting, simplifying the `AccessorAverageCoverage` struct's responsibility to only assessment.\n"
          },
          {
            "oldCode": "\t}",
            "newCode": "\t}",
            "reason": "Unchanged",
            "start": 72,
            "end": 72
          },
          {
            "oldCode": "\tfmt.Fprintf(os.Stderr, \"Average coverage: %.2f%%\\n\", average)",
            "newCode": "\tfmt.Fprintf(os.Stderr, \"Average coverage: %.2f%%\\n\", average)",
            "reason": "Unchanged",
            "start": 73,
            "end": 73
          },
          {
            "oldCode": "\treturn pass",
            "newCode": "\treturn pass",
            "reason": "Unchanged",
            "start": 74,
            "end": 74
          },
          {
            "oldCode": "}",
            "newCode": "}",
            "reason": "Unchanged",
            "start": 75,
            "end": 75
          },
          {
            "reason": "Removed",
            "start": 76,
            "end": 76,
            "reasonDiff": "The interface `Accessor` was removed because it violated the Interface Segregation Principle by combining distinct assessment methods for grades and coverage.  This change improves code organization and reduces coupling.\n"
          }
        ]
      }
    },
    "gradingDetails": {
      "dependencyInversionScore": "A*",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "C",
      "openClosedScore": "B",
      "singleResponsibilityScore": "B"
    },
    "hash": "e988423d3b099fc92fb5c99b666f526ed5ab5104aa88f349a06f31f21b2395cb",
    "id": "eJylVW1r2zAQ/is3QYe9ZXbpvplmEFI2BqMrbOuXeYyrfXbEFCmTzh2l9L8PWbKTuBnrSz6J093zcr6LbgU6R85J3X41RolCfPn86eOZmInK1LQ0mkmzKMQGq1/YEoTsNWkudanlemMsQ1Lqksu+QlHDbyol80YqJluKcNWseTga50+pL89zWIx4IB0gDDy8QoaNNdeyJgdNpyuWRqOSfANsogzwjPC7C+ErdFSD0dBa9EWoa6jMNVlsKSs132wIFlVFzhkLUjPZBiuCWy8ryEh4ZcmtjKrBsZW6nUFNjFI5+P4jGMo+ePCzEE3hyhhV6jtvZg+/z/IgXcWBYYmq6hSysRB+u3jbS596KY1Cb3dpOi8TxoCLXL4fcE5/9uiSaktxGHwG1/+GTrfN6QVb4s5qeLnH0d/smimimy33LKRMTRT3uPvEu11HCbbwao8vhed8mWCkQamohmIObDvqI8bCzwHBX1jULY2I0aRsANtsazUQnHdrsrJCdYmqoyTUZFHs6QMqRifpQDRKnEODytEQxTabdjFb1PUYi+RpyL+L7eyFv4iIkeEQ0oWVmpN0rIrfOxQemull3KX/7c4F2arfZ81P3p9FoBopdzfp8esxQUsetAUj98FtmEDePmfosdpO/QT3/vw/trtBPhvGftKPHz7/oeb1PMazQdO4HZM4nMI9leOEI1ZPHuZE0XDt0hTmczgegJs1h0FWOinFufF/fOS2L0QpIuA43XG/+v6XjFF6MYdGGeS3J0lvO4V8DOyx+6INOucrhuJ3O8WTBqSBxm9kXzXs46FuTBfSe3u/8cEmMS77wjVZO4NSxBkZH7cCjrKT5uioLHUpZoOsdGdsPXc/c2ImfIcukFeiEPk3R9blK9L2RuH6Kl93iuVGUb73lG/f/Hg0NmuNuPsL6p0QRg=="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/assessment/assessor.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-04-11T12:04:02.481Z",
    "codeReview": {
      "detailedReview": {
        "tasks": [
          {
            "done": false,
            "titleTask": "interfaceSegregation",
            "violatingCode": "The `GradeAccessor` and `CoverageAccessor` interfaces both use the `Assess` method, but with different parameters.  This violates the Interface Segregation Principle because they are forced to implement methods they don't need.  A better approach would be to separate the assessment logic into distinct interfaces, such as `GradeAssessment` and `CoverageAssessment`, each with its own specific `Assess` method.\n",
            "codeResolution": "The `GradeAccessor` and `CoverageAccessor` interfaces both use `Assess` with different parameters.  This violates the Interface Segregation Principle (ISP).  Refactor into separate interfaces: `GradeAssessable` (with `AssessGrade(threshold string, details []filter.GradeDetails) bool`) and `CoverageAssessable` (with `AssessCoverage(thresholdPercent int, details []filter.GradeDetails) bool`).  `AccessorGrade` and `AccessorAverageCoverage` would implement their respective interfaces.  This allows for more focused and reusable interfaces.\n",
            "severity": "Medium",
            "rationale": "The `GradeAccessor` and `CoverageAccessor` interfaces both use the `ViolationReporter` interface.  This violates the Interface Segregation Principle (ISP) because `GradeAccessor` and `CoverageAccessor` are forced to depend on a method (`Report`) they may not need.  This can lead to unnecessary dependencies, making the code harder to maintain and potentially impacting performance if unused methods are included.  Separating the reporting functionality into a separate interface would improve modularity and flexibility.\n",
            "lineStart": 24,
            "lineEnd": 31,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "liskovSubstitution",
            "violatingCode": "The `AccessorGrade` and `AccessorAverageCoverage` types both implement the `Assess` method, but with different parameter types and functionalities.  This violates the Liskov Substitution Principle because they cannot be used interchangeably.  For example,  `AccessorGrade.Assess` takes a string threshold, while `AccessorAverageCoverage.Assess` takes an integer threshold.\n",
            "codeResolution": "The Liskov Substitution Principle (LSP) is violated because `AccessorGrade` and `AccessorAverageCoverage` have different `Assess` methods.  To fix this, create a common interface with a generic `Assess` method that both types implement.  This allows interchangeable use without altering the calling code.  For example:\n\n```go\ntype Assessor interface {\n    Assess(threshold interface{}, details []filter.GradeDetails) bool\n}\n\ntype AccessorGrade struct {\n    // ...\n}\n\nfunc (ag *AccessorGrade) Assess(threshold interface{}, details []filter.GradeDetails) bool {\n    // ... type assertion to get threshold string ...\n}\n\ntype AccessorAverageCoverage struct {\n    // ...\n}\n\nfunc (aac *AccessorAverageCoverage) Assess(threshold interface{}, details []filter.GradeDetails) bool {\n    // ... type assertion to get threshold int ...\n}\n```\n",
            "severity": "Medium",
            "rationale": "The Liskov Substitution Principle (LSP) is violated because `AccessorGrade` and `AccessorAverageCoverage` both implement the `GradeAccessor` and `CoverageAccessor` interfaces, respectively, but they have different functionalities and cannot be substituted for each other without causing issues.  `AccessorGrade` assesses grades based on a string threshold, while `AccessorAverageCoverage` assesses coverage based on an integer threshold.  This difference in functionality makes them incompatible, impacting maintainability and potentially leading to unexpected behavior if one is used where the other is expected.\n",
            "lineStart": 24,
            "lineEnd": 75,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "singleResponsibility",
            "violatingCode": "```go\nfunc (ag *AccessorGrade) Assess(threshold string, details []filter.GradeDetails) bool {\n\tpassed := true\n\tag.ViolationDetails = []filter.GradeDetails{} // Reset violations\n\tfor _, detail := range details {\n\t\tif ag.Calculator.GradeNumericalValue(detail.Grade) < ag.Calculator.GradeNumericalValue(threshold) {\n\t\t\tpassed = false\n\t\t\tag.ViolationDetails = append(ag.ViolationDetails, detail)\n\t\t}\n\t}\n\tif !passed {\n\t\tag.Reporter.Report(ag.ViolationDetails)\n\t}\n\treturn passed\n}\n\nfunc (aac *AccessorAverageCoverage) Assess(thresholdPercent int, details []filter.GradeDetails) bool {\n\ttotal := 0\n\taac.ViolationDetails = []filter.GradeDetails{} // Reset violations\n\tfor _, detail := range details {\n\t\ttotal += detail.Coverage\n\t\tif detail.Coverage < thresholdPercent {\n\t\t\taac.ViolationDetails = append(aac.ViolationDetails, detail)\n\t\t}\n\t}\n\t// ...rest of the function\n}\n```\n",
            "codeResolution": "The `AccessorGrade` and `AccessorAverageCoverage` types violate the Single Responsibility Principle (SRP).  `AccessorGrade` handles grade assessment and violation reporting, while `AccessorAverageCoverage` handles coverage assessment and reporting.  Refactor them into separate classes for assessment and reporting.  For example, create `GradeAssessment`, `CoverageAssessment`, and `ViolationReporter` interfaces.  Implement separate classes for each assessment type and reuse the `ViolationReporter` implementation.\n",
            "severity": "Medium",
            "rationale": "The `AccessorGrade` and `AccessorAverageCoverage` types violate the Single Responsibility Principle (SRP).  `AccessorGrade` handles grade assessment and violation reporting, while `AccessorAverageCoverage` handles coverage assessment and reporting.  These combined responsibilities make the code harder to maintain, test, and understand.  A change in one aspect (e.g., reporting mechanism) could necessitate changes in unrelated parts, increasing the risk of bugs and reducing code clarity.  Separating these concerns into distinct classes would improve modularity and maintainability.\n",
            "lineStart": 34,
            "lineEnd": 56,
            "status": ""
          }
        ],
        "codeReviewTitle": "SOLID Code Review"
      },
      "upgradedCode": {
        "oldCode": "package assessment\n\nimport (\n\t\"codeleft-cli/filter\"\n\t\"fmt\"\n\t\"os\"\n)\n\n// ViolationReporter interface for reporting violations\ntype ViolationReporter interface {\n\tReport(violations []filter.GradeDetails)\n}\n\n// ConsoleViolationReporter implements ViolationReporter and prints violations to the console\ntype ConsoleViolationReporter struct{}\n\nfunc (c *ConsoleViolationReporter) Report(violations []filter.GradeDetails) {\n\tfor _, v := range violations {\n\t\tfmt.Printf(\"Violation: File: %s, Grade: %s, Coverage: %d\\n\", v.FileName, v.Grade, v.Coverage)\n\t}\n}\n\n// GradeAccessor interface for assessing code grades\ntype GradeAccessor interface {\n\tAssess(threshold string, details []filter.GradeDetails) bool\n}\n\n// CoverageAccessor interface for assessing code coverage\ntype CoverageAccessor interface {\n\tAssess(thresholdPercent int, details []filter.GradeDetails) bool\n}\n\n// AccessorGrade assesses code grades\ntype AccessorGrade struct {\n\tCalculator       filter.GradeCalculator\n\tReporter         ViolationReporter\n\tViolationDetails []filter.GradeDetails\n}\n\n// NewGradeAccessor creates a new AccessorGrade instance\nfunc NewGradeAccessor(calculator filter.GradeCalculator, reporter ViolationReporter) GradeAccessor {\n\treturn &AccessorGrade{\n\t\tCalculator: calculator,\n\t\tReporter:   reporter,\n\t}\n}\n\n// Assess assesses code grades against a threshold\nfunc (ag *AccessorGrade) Assess(threshold string, details []filter.GradeDetails) bool {\n\tpassed := true\n\tag.ViolationDetails = []filter.GradeDetails{} // Reset violations\n\tfor _, detail := range details {\n\t\tif ag.Calculator.GradeNumericalValue(detail.Grade) < ag.Calculator.GradeNumericalValue(threshold) {\n\t\t\tpassed = false\n\t\t\tag.ViolationDetails = append(ag.ViolationDetails, detail)\n\t\t}\n\t}\n\tif !passed {\n\t\tag.Reporter.Report(ag.ViolationDetails)\n\t}\n\treturn passed\n}\n\n// AccessorAverageCoverage assesses code coverage\ntype AccessorAverageCoverage struct {\n\tReporter         ViolationReporter\n\tViolationDetails []filter.GradeDetails\n}\n\n// NewCoverageAccessor creates a new AccessorAverageCoverage instance\nfunc NewCoverageAccessor(reporter ViolationReporter) CoverageAccessor {\n\treturn &AccessorAverageCoverage{\n\t\tReporter: reporter,\n\t}\n}\n\n// Assess assesses code coverage against a threshold\nfunc (aac *AccessorAverageCoverage) Assess(thresholdPercent int, details []filter.GradeDetails) bool {\n\ttotal := 0\n\taac.ViolationDetails = []filter.GradeDetails{} // Reset violations\n\tfor _, detail := range details {\n\t\ttotal += detail.Coverage\n\t\tif detail.Coverage < thresholdPercent {\n\t\t\taac.ViolationDetails = append(aac.ViolationDetails, detail)\n\t\t}\n\t}\n\tif len(details) == 0 {\n\t\tfmt.Println(\"No files to assess\")\n\t\treturn false\n\t}\n\n\taverage := float32(total) / float32(len(details))\n\tpass := average >= float32(thresholdPercent)\n\n\tif !pass {\n\t\taac.Reporter.Report(aac.ViolationDetails)\n\t}\n\tfmt.Fprintf(os.Stderr, \"Average coverage: %.2f%%\\n\", average)\n\treturn pass\n}",
        "newCode": "package assessment\n\nimport (\n\t\"codeleft-cli/filter\"\n\t\"fmt\"\n\t\"os\"\n)\n\n// ViolationReporter interface for reporting violations\ntype ViolationReporter interface {\n\tReport(violations []filter.GradeDetails)\n}\n\n// ConsoleViolationReporter implements ViolationReporter and prints violations to the console\ntype ConsoleViolationReporter struct{}\n\nfunc (c *ConsoleViolationReporter) Report(violations []filter.GradeDetails) {\n\tfor _, v := range violations {\n\t\tfmt.Printf(\"Violation: File: %s, Grade: %s, Coverage: %d\\n\", v.FileName, v.Grade, v.Coverage)\n\t}\n}\n\n// GradeAssessable interface for assessing code grades\ntype GradeAssessable interface {\n\tAssessGrade(threshold string, details []filter.GradeDetails) bool\n}\n\n// CoverageAssessable interface for assessing code coverage\ntype CoverageAssessable interface {\n\tAssessCoverage(thresholdPercent int, details []filter.GradeDetails) bool\n}\n\n// GradeAssessment handles grade assessment\ntype GradeAssessment struct {\n\tCalculator       filter.GradeCalculator\n\tReporter         ViolationReporter\n\tViolationDetails []filter.GradeDetails\n}\n\n// NewGradeAssessment creates a new GradeAssessment instance\nfunc NewGradeAssessment(calculator filter.GradeCalculator, reporter ViolationReporter) GradeAssessable {\n\treturn &GradeAssessment{\n\t\tCalculator: calculator,\n\t\tReporter:   reporter,\n\t}\n}\n\n// AssessGrade assesses code grades against a threshold\nfunc (ga *GradeAssessment) AssessGrade(threshold string, details []filter.GradeDetails) bool {\n\tpassed := true\n\tga.ViolationDetails = []filter.GradeDetails{} // Reset violations\n\tfor _, detail := range details {\n\t\tif ga.Calculator.GradeNumericalValue(detail.Grade) < ga.Calculator.GradeNumericalValue(threshold) {\n\t\t\tpassed = false\n\t\t\tga.ViolationDetails = append(ga.ViolationDetails, detail)\n\t\t}\n\t}\n\tif !passed {\n\t\tga.Reporter.Report(ga.ViolationDetails)\n\t}\n\treturn passed\n}\n\n// CoverageAssessment handles code coverage assessment\ntype CoverageAssessment struct {\n\tReporter         ViolationReporter\n\tViolationDetails []filter.GradeDetails\n}\n\n// NewCoverageAssessment creates a new CoverageAssessment instance\nfunc NewCoverageAssessment(reporter ViolationReporter) CoverageAssessable {\n\treturn &CoverageAssessment{\n\t\tReporter: reporter,\n\t}\n}\n\n// AssessCoverage assesses code coverage against a threshold\nfunc (ca *CoverageAssessment) AssessCoverage(thresholdPercent int, details []filter.GradeDetails) bool {\n\ttotal := 0\n\tca.ViolationDetails = []filter.GradeDetails{} // Reset violations\n\tfor _, detail := range details {\n\t\ttotal += detail.Coverage\n\t\tif detail.Coverage < thresholdPercent {\n\t\t\tca.ViolationDetails = append(ca.ViolationDetails, detail)\n\t\t}\n\t}\n\tif len(details) == 0 {\n\t\tfmt.Println(\"No files to assess\")\n\t\treturn false\n\t}\n\n\taverage := float32(total) / float32(len(details))\n\tpass := average >= float32(thresholdPercent)\n\n\tif !pass {\n\t\tca.Reporter.Report(ca.ViolationDetails)\n\t}\n\tfmt.Fprintf(os.Stderr, \"Average coverage: %.2f%%\\n\", average)\n\treturn pass\n}",
        "changes": [
          {
            "oldCode": "package assessment",
            "newCode": "package assessment",
            "reason": "Unchanged",
            "start": 1,
            "end": 1
          },
          {
            "reason": "Unchanged",
            "start": 2,
            "end": 2
          },
          {
            "oldCode": "import (",
            "newCode": "import (",
            "reason": "Unchanged",
            "start": 3,
            "end": 3
          },
          {
            "oldCode": "\t\"codeleft-cli/filter\"",
            "newCode": "\t\"codeleft-cli/filter\"",
            "reason": "Unchanged",
            "start": 4,
            "end": 4
          },
          {
            "oldCode": "\t\"fmt\"",
            "newCode": "\t\"fmt\"",
            "reason": "Unchanged",
            "start": 5,
            "end": 5
          },
          {
            "oldCode": "\t\"os\"",
            "newCode": "\t\"os\"",
            "reason": "Unchanged",
            "start": 6,
            "end": 6
          },
          {
            "oldCode": ")",
            "newCode": ")",
            "reason": "Unchanged",
            "start": 7,
            "end": 7
          },
          {
            "reason": "Unchanged",
            "start": 8,
            "end": 8
          },
          {
            "oldCode": "// ViolationReporter interface for reporting violations",
            "newCode": "// ViolationReporter interface for reporting violations",
            "reason": "Unchanged",
            "start": 9,
            "end": 9
          },
          {
            "oldCode": "type ViolationReporter interface {",
            "newCode": "type ViolationReporter interface {",
            "reason": "Unchanged",
            "start": 10,
            "end": 10
          },
          {
            "oldCode": "\tReport(violations []filter.GradeDetails)",
            "newCode": "\tReport(violations []filter.GradeDetails)",
            "reason": "Unchanged",
            "start": 11,
            "end": 11
          },
          {
            "oldCode": "}",
            "newCode": "}",
            "reason": "Unchanged",
            "start": 12,
            "end": 12
          },
          {
            "reason": "Unchanged",
            "start": 13,
            "end": 13
          },
          {
            "oldCode": "// ConsoleViolationReporter implements ViolationReporter and prints violations to the console",
            "newCode": "// ConsoleViolationReporter implements ViolationReporter and prints violations to the console",
            "reason": "Unchanged",
            "start": 14,
            "end": 14
          },
          {
            "oldCode": "type ConsoleViolationReporter struct{}",
            "newCode": "type ConsoleViolationReporter struct{}",
            "reason": "Unchanged",
            "start": 15,
            "end": 15
          },
          {
            "reason": "Unchanged",
            "start": 16,
            "end": 16
          },
          {
            "oldCode": "func (c *ConsoleViolationReporter) Report(violations []filter.GradeDetails) {",
            "newCode": "func (c *ConsoleViolationReporter) Report(violations []filter.GradeDetails) {",
            "reason": "Unchanged",
            "start": 17,
            "end": 17
          },
          {
            "oldCode": "\tfor _, v := range violations {",
            "newCode": "\tfor _, v := range violations {",
            "reason": "Unchanged",
            "start": 18,
            "end": 18
          },
          {
            "oldCode": "\t\tfmt.Printf(\"Violation: File: %s, Grade: %s, Coverage: %d\\n\", v.FileName, v.Grade, v.Coverage)",
            "newCode": "\t\tfmt.Printf(\"Violation: File: %s, Grade: %s, Coverage: %d\\n\", v.FileName, v.Grade, v.Coverage)",
            "reason": "Unchanged",
            "start": 19,
            "end": 19
          },
          {
            "oldCode": "\t}",
            "newCode": "\t}",
            "reason": "Unchanged",
            "start": 20,
            "end": 20
          },
          {
            "oldCode": "}\n\n// GradeAccessor interface for assessing code grades\ntype GradeAccessor interface {\n\tAssess(threshold string, details []filter.GradeDetails) bool\n}\n\n// CoverageAccessor interface for assessing code coverage\ntype CoverageAccessor interface {\n\tAssess(thresholdPercent int, details []filter.GradeDetails) bool\n}\n\n// AccessorGrade assesses code grades\ntype AccessorGrade struct {",
            "newCode": "}\n\n// GradeAssessable interface for assessing code grades\ntype GradeAssessable interface {\n\tAssessGrade(threshold string, details []filter.GradeDetails) bool\n}\n\n// CoverageAssessable interface for assessing code coverage\ntype CoverageAssessable interface {\n\tAssessCoverage(thresholdPercent int, details []filter.GradeDetails) bool\n}\n\n// GradeAssessment handles grade assessment\ntype GradeAssessment struct {",
            "reason": "Modified",
            "start": 21,
            "end": 34,
            "reasonDiff": "The interface segregation principle was violated because `GradeAccessor` and `CoverageAccessor` interfaces used the same method name `Assess` with different parameters.  The refactor changed the interfaces to `GradeAssessable` with the method `AssessGrade` and `CoverageAssessable` with the method `AssessCoverage`. This adheres to the interface segregation principle.\n"
          },
          {
            "oldCode": "\tCalculator       filter.GradeCalculator",
            "newCode": "\tCalculator       filter.GradeCalculator",
            "reason": "Unchanged",
            "start": 35,
            "end": 35
          },
          {
            "oldCode": "\tReporter         ViolationReporter",
            "newCode": "\tReporter         ViolationReporter",
            "reason": "Unchanged",
            "start": 36,
            "end": 36
          },
          {
            "oldCode": "\tViolationDetails []filter.GradeDetails",
            "newCode": "\tViolationDetails []filter.GradeDetails",
            "reason": "Unchanged",
            "start": 37,
            "end": 37
          },
          {
            "oldCode": "}",
            "newCode": "}",
            "reason": "Unchanged",
            "start": 38,
            "end": 38
          },
          {
            "reason": "Unchanged",
            "start": 39,
            "end": 39
          },
          {
            "oldCode": "// NewGradeAccessor creates a new AccessorGrade instance\nfunc NewGradeAccessor(calculator filter.GradeCalculator, reporter ViolationReporter) GradeAccessor {\n\treturn &AccessorGrade{",
            "newCode": "// NewGradeAssessment creates a new GradeAssessment instance\nfunc NewGradeAssessment(calculator filter.GradeCalculator, reporter ViolationReporter) GradeAssessable {\n\treturn &GradeAssessment{",
            "reason": "Modified",
            "start": 40,
            "end": 42,
            "reasonDiff": "Renamed `NewGradeAccessor` to `NewGradeAssessment` and changed return type to `GradeAssessable` to adhere to the Interface Segregation Principle.\n"
          },
          {
            "oldCode": "\t\tCalculator: calculator,",
            "newCode": "\t\tCalculator: calculator,",
            "reason": "Unchanged",
            "start": 43,
            "end": 43
          },
          {
            "oldCode": "\t\tReporter:   reporter,",
            "newCode": "\t\tReporter:   reporter,",
            "reason": "Unchanged",
            "start": 44,
            "end": 44
          },
          {
            "oldCode": "\t}",
            "newCode": "\t}",
            "reason": "Unchanged",
            "start": 45,
            "end": 45
          },
          {
            "oldCode": "}",
            "newCode": "}",
            "reason": "Unchanged",
            "start": 46,
            "end": 46
          },
          {
            "reason": "Unchanged",
            "start": 47,
            "end": 47
          },
          {
            "oldCode": "// Assess assesses code grades against a threshold\nfunc (ag *AccessorGrade) Assess(threshold string, details []filter.GradeDetails) bool {",
            "newCode": "// AssessGrade assesses code grades against a threshold\nfunc (ga *GradeAssessment) AssessGrade(threshold string, details []filter.GradeDetails) bool {",
            "reason": "Modified",
            "start": 48,
            "end": 49,
            "reasonDiff": "The interface segregation principle was violated because the `Assess` method was used by multiple interfaces with different parameters.  The method was renamed to `AssessGrade` to adhere to the interface segregation principle.\n"
          },
          {
            "oldCode": "\tpassed := true",
            "newCode": "\tpassed := true",
            "reason": "Unchanged",
            "start": 50,
            "end": 50
          },
          {
            "oldCode": "\tag.ViolationDetails = []filter.GradeDetails{} // Reset violations",
            "newCode": "\tga.ViolationDetails = []filter.GradeDetails{} // Reset violations",
            "reason": "Modified",
            "start": 51,
            "end": 51,
            "reasonDiff": "The variable `ag` was renamed to `ga` due to the renaming of `AccessorGrade` to `GradeAssessment` to adhere to the Single Responsibility Principle and Interface Segregation Principle.\n"
          },
          {
            "oldCode": "\tfor _, detail := range details {",
            "newCode": "\tfor _, detail := range details {",
            "reason": "Unchanged",
            "start": 52,
            "end": 52
          },
          {
            "oldCode": "\t\tif ag.Calculator.GradeNumericalValue(detail.Grade) < ag.Calculator.GradeNumericalValue(threshold) {",
            "newCode": "\t\tif ga.Calculator.GradeNumericalValue(detail.Grade) < ga.Calculator.GradeNumericalValue(threshold) {",
            "reason": "Modified",
            "start": 53,
            "end": 53,
            "reasonDiff": "The change from `ag` to `ga` is due to renaming the `AccessorGrade` type to `GradeAssessment` to adhere to the Single Responsibility Principle and Interface Segregation Principle, separating grade assessment logic into a distinct type.\n"
          },
          {
            "oldCode": "\t\t\tpassed = false",
            "newCode": "\t\t\tpassed = false",
            "reason": "Unchanged",
            "start": 54,
            "end": 54
          },
          {
            "oldCode": "\t\t\tag.ViolationDetails = append(ag.ViolationDetails, detail)",
            "newCode": "\t\t\tga.ViolationDetails = append(ga.ViolationDetails, detail)",
            "reason": "Modified",
            "start": 55,
            "end": 55,
            "reasonDiff": "Refactoring to adhere to the Interface Segregation Principle. `AccessorGrade` was renamed to `GradeAssessment` and the corresponding receiver variable `ag` was renamed to `ga`.\n"
          },
          {
            "oldCode": "\t\t}",
            "newCode": "\t\t}",
            "reason": "Unchanged",
            "start": 56,
            "end": 56
          },
          {
            "oldCode": "\t}",
            "newCode": "\t}",
            "reason": "Unchanged",
            "start": 57,
            "end": 57
          },
          {
            "oldCode": "\tif !passed {",
            "newCode": "\tif !passed {",
            "reason": "Unchanged",
            "start": 58,
            "end": 58
          },
          {
            "oldCode": "\t\tag.Reporter.Report(ag.ViolationDetails)",
            "newCode": "\t\tga.Reporter.Report(ga.ViolationDetails)",
            "reason": "Modified",
            "start": 59,
            "end": 59,
            "reasonDiff": "The change from `ag` to `ga` reflects the renaming of `AccessorGrade` to `GradeAssessment` to adhere to the Single Responsibility Principle and Interface Segregation Principle.\n"
          },
          {
            "oldCode": "\t}",
            "newCode": "\t}",
            "reason": "Unchanged",
            "start": 60,
            "end": 60
          },
          {
            "oldCode": "\treturn passed",
            "newCode": "\treturn passed",
            "reason": "Unchanged",
            "start": 61,
            "end": 61
          },
          {
            "oldCode": "}",
            "newCode": "}",
            "reason": "Unchanged",
            "start": 62,
            "end": 62
          },
          {
            "reason": "Unchanged",
            "start": 63,
            "end": 63
          },
          {
            "oldCode": "// AccessorAverageCoverage assesses code coverage\ntype AccessorAverageCoverage struct {",
            "newCode": "// CoverageAssessment handles code coverage assessment\ntype CoverageAssessment struct {",
            "reason": "Modified",
            "start": 64,
            "end": 65,
            "reasonDiff": "Renamed `AccessorAverageCoverage` to `CoverageAssessment` to better reflect its role in handling code coverage assessment, as part of the refactoring to adhere to the Interface Segregation Principle.\n"
          },
          {
            "oldCode": "\tReporter         ViolationReporter",
            "newCode": "\tReporter         ViolationReporter",
            "reason": "Unchanged",
            "start": 66,
            "end": 66
          },
          {
            "oldCode": "\tViolationDetails []filter.GradeDetails",
            "newCode": "\tViolationDetails []filter.GradeDetails",
            "reason": "Unchanged",
            "start": 67,
            "end": 67
          },
          {
            "oldCode": "}",
            "newCode": "}",
            "reason": "Unchanged",
            "start": 68,
            "end": 68
          },
          {
            "reason": "Unchanged",
            "start": 69,
            "end": 69
          },
          {
            "oldCode": "// NewCoverageAccessor creates a new AccessorAverageCoverage instance\nfunc NewCoverageAccessor(reporter ViolationReporter) CoverageAccessor {\n\treturn &AccessorAverageCoverage{",
            "newCode": "// NewCoverageAssessment creates a new CoverageAssessment instance\nfunc NewCoverageAssessment(reporter ViolationReporter) CoverageAssessable {\n\treturn &CoverageAssessment{",
            "reason": "Modified",
            "start": 70,
            "end": 72,
            "reasonDiff": "Renamed `NewCoverageAccessor` to `NewCoverageAssessment` and changed return type to `CoverageAssessable` to adhere to the Interface Segregation Principle.\n"
          },
          {
            "oldCode": "\t\tReporter: reporter,",
            "newCode": "\t\tReporter: reporter,",
            "reason": "Unchanged",
            "start": 73,
            "end": 73
          },
          {
            "oldCode": "\t}",
            "newCode": "\t}",
            "reason": "Unchanged",
            "start": 74,
            "end": 74
          },
          {
            "oldCode": "}",
            "newCode": "}",
            "reason": "Unchanged",
            "start": 75,
            "end": 75
          },
          {
            "reason": "Unchanged",
            "start": 76,
            "end": 76
          },
          {
            "oldCode": "// Assess assesses code coverage against a threshold\nfunc (aac *AccessorAverageCoverage) Assess(thresholdPercent int, details []filter.GradeDetails) bool {",
            "newCode": "// AssessCoverage assesses code coverage against a threshold\nfunc (ca *CoverageAssessment) AssessCoverage(thresholdPercent int, details []filter.GradeDetails) bool {",
            "reason": "Modified",
            "start": 77,
            "end": 78,
            "reasonDiff": "The method name `Assess` was changed to `AssessCoverage` to adhere to the Interface Segregation Principle, as the original `Assess` method was used for both grade and coverage assessment with different parameters. This change creates distinct interfaces for grade and coverage assessment.\n"
          },
          {
            "oldCode": "\ttotal := 0",
            "newCode": "\ttotal := 0",
            "reason": "Unchanged",
            "start": 79,
            "end": 79
          },
          {
            "oldCode": "\taac.ViolationDetails = []filter.GradeDetails{} // Reset violations",
            "newCode": "\tca.ViolationDetails = []filter.GradeDetails{} // Reset violations",
            "reason": "Modified",
            "start": 80,
            "end": 80,
            "reasonDiff": "The variable `aac` was renamed to `ca` to reflect the change in the struct name from `AccessorAverageCoverage` to `CoverageAssessment` as part of the refactoring to adhere to the Single Responsibility Principle and Interface Segregation Principle.\n"
          },
          {
            "oldCode": "\tfor _, detail := range details {",
            "newCode": "\tfor _, detail := range details {",
            "reason": "Unchanged",
            "start": 81,
            "end": 81
          },
          {
            "oldCode": "\t\ttotal += detail.Coverage",
            "newCode": "\t\ttotal += detail.Coverage",
            "reason": "Unchanged",
            "start": 82,
            "end": 82
          },
          {
            "oldCode": "\t\tif detail.Coverage < thresholdPercent {",
            "newCode": "\t\tif detail.Coverage < thresholdPercent {",
            "reason": "Unchanged",
            "start": 83,
            "end": 83
          },
          {
            "oldCode": "\t\t\taac.ViolationDetails = append(aac.ViolationDetails, detail)",
            "newCode": "\t\t\tca.ViolationDetails = append(ca.ViolationDetails, detail)",
            "reason": "Modified",
            "start": 84,
            "end": 84,
            "reasonDiff": "The change from `aac` to `ca` reflects the renaming of `AccessorAverageCoverage` to `CoverageAssessment` to adhere to the Single Responsibility Principle and Interface Segregation Principle, separating coverage assessment logic into a dedicated type.\n"
          },
          {
            "oldCode": "\t\t}",
            "newCode": "\t\t}",
            "reason": "Unchanged",
            "start": 85,
            "end": 85
          },
          {
            "oldCode": "\t}",
            "newCode": "\t}",
            "reason": "Unchanged",
            "start": 86,
            "end": 86
          },
          {
            "oldCode": "\tif len(details) == 0 {",
            "newCode": "\tif len(details) == 0 {",
            "reason": "Unchanged",
            "start": 87,
            "end": 87
          },
          {
            "oldCode": "\t\tfmt.Println(\"No files to assess\")",
            "newCode": "\t\tfmt.Println(\"No files to assess\")",
            "reason": "Unchanged",
            "start": 88,
            "end": 88
          },
          {
            "oldCode": "\t\treturn false",
            "newCode": "\t\treturn false",
            "reason": "Unchanged",
            "start": 89,
            "end": 89
          },
          {
            "oldCode": "\t}",
            "newCode": "\t}",
            "reason": "Unchanged",
            "start": 90,
            "end": 90
          },
          {
            "reason": "Unchanged",
            "start": 91,
            "end": 91
          },
          {
            "oldCode": "\taverage := float32(total) / float32(len(details))",
            "newCode": "\taverage := float32(total) / float32(len(details))",
            "reason": "Unchanged",
            "start": 92,
            "end": 92
          },
          {
            "oldCode": "\tpass := average >= float32(thresholdPercent)",
            "newCode": "\tpass := average >= float32(thresholdPercent)",
            "reason": "Unchanged",
            "start": 93,
            "end": 93
          },
          {
            "reason": "Unchanged",
            "start": 94,
            "end": 94
          },
          {
            "oldCode": "\tif !pass {",
            "newCode": "\tif !pass {",
            "reason": "Unchanged",
            "start": 95,
            "end": 95
          },
          {
            "oldCode": "\t\taac.Reporter.Report(aac.ViolationDetails)",
            "newCode": "\t\tca.Reporter.Report(ca.ViolationDetails)",
            "reason": "Modified",
            "start": 96,
            "end": 96,
            "reasonDiff": "The change from `aac` to `ca` reflects the renaming of `AccessorAverageCoverage` to `CoverageAssessment` to adhere to the Single Responsibility Principle and Interface Segregation Principle, separating coverage assessment logic from reporting.\n"
          },
          {
            "oldCode": "\t}",
            "newCode": "\t}",
            "reason": "Unchanged",
            "start": 97,
            "end": 97
          },
          {
            "oldCode": "\tfmt.Fprintf(os.Stderr, \"Average coverage: %.2f%%\\n\", average)",
            "newCode": "\tfmt.Fprintf(os.Stderr, \"Average coverage: %.2f%%\\n\", average)",
            "reason": "Unchanged",
            "start": 98,
            "end": 98
          },
          {
            "oldCode": "\treturn pass",
            "newCode": "\treturn pass",
            "reason": "Unchanged",
            "start": 99,
            "end": 99
          },
          {
            "oldCode": "}",
            "newCode": "}",
            "reason": "Unchanged",
            "start": 100,
            "end": 100
          }
        ]
      }
    },
    "gradingDetails": {
      "dependencyInversionScore": "A*",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "B",
      "openClosedScore": "A",
      "singleResponsibilityScore": "B"
    },
    "hash": "044161d56184d37f6cbd980001952ad114cd5141b987ec6ad71b0ff5aea7e699",
    "id": "eJy9V12L3DYU/Su3hi126tohfTOZwrJLSqFsl6TNSxSKIl97TGXJSJoNYZj/XmR92GN7hl1Ku09a6X6ce3XPseaYUK1R6060f0jJkyr58Ptvv94necJkjXdSGBQmqZKBsr9pi+CsexSGCCK6fpDKQEoEMWT04NiYHxnvyqbjBhVJ3FHTm7CU2q4y616W8LGTnJpOivdoQ6GCThhUDWUIjVSgxu1OtPAULDUR5tuAV12PNpfbTydH+PTZwSp+UbTGezS04zoj4uTR3EmhJceNyP3A0VatN9JSUcOgOns4y2UkmD0CcyE95osJtFEHZo4jkOYgGKQMXl2yzuC5pblG2Eb+lcMTVDtQVLQ4xzlaENP0pni0RTQpSWLGCt51HCu40TmMgd3yTj6hoq39ryZEkCSHp8JaPtAe7Xq0tYtgae/bnKZOjwa3jKHWcnnncSLBThS01jRc+iW/sYrb0TE1e4V6L3ltu9qJNofateNSk75IyedD4CA/Dx3z1vGCLzpvQnxExVAYa/ZCmCHDaONRod5o2bmhGzQH5o5yduDUSAXub552Opy4hMEQ1jSwVnHz/lolUw0P+PX8QplCalADBYFfF8g7oQ0VDD1Blr4pm6rZriP3aoJqjT5bTNbYH4XmoAR8f4bD82UKW8GUOXeHIWoFEHPmCwa4Sdi8OKAttdUChTgoQRZoC6/O8GTwb8beFTpYFLWVB6MOaHdoW6wuc7cd6HiCsoT3qNGciXTUHQdjEp8Ay3eya4C2xdRPF/zh0KPqGOUfKT9g6nwKX/HbZ3jEdmQhUaxzBw3lGsPudq10GFDU6cZhqChzAU7+YsdKvvMpfEraFmEW/GIrYBYj+IlzQdZcv3XiEkRmMTwLKbrkNFeA/4zWKx3cZvYS25rjy0DpNQ6vsm7SeJH0uOTsixjL4l1c4SxlE2kX2df0feknwRVppKEjx16P9KXsf+Ovy/zDzu/HT35k92If3sKq1sjQC8ADGTdOr7GRo/DKoTPY7eD16rXDRUqSB2m/GDi+2dztksSH87MT9WKcBWKoL6XaQcMlNT+9Scc2ZFDGjXnyLKis9QjOP8+cFw3JXJogKFFOKFvryUZPJkGxhb4b3LtO6uKDqVGpHEjixzDObwU3xZvm5sY/5+js2TYTJSJOSZ7YZj1Ss0+qpPxTo9LlHoX6xmn/pewP3HQDx/Ls18D0s8EvpSpamZz+AdUEonA="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/assessment/assessor.go",
    "grade": "A",
    "username": "Hlamb",
    "timestamp": "2025-04-11T12:05:22.492Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "dependencyInversionScore": "A*",
      "interfaceSegregationScore": "A*",
      "liskovSubstitutionScore": "B",
      "openClosedScore": "A",
      "singleResponsibilityScore": "B"
    },
    "hash": "8e4740fe48a02a144248de3f1c45a0a8658bcc11d82502c0d312b92fcde3a18f",
    "id": "eJy9V22L4zYQ/itTwRb76trH9Zu5FI4sVwplu9y196UuZVYeO6ayZCRljyPkvxdZ8ktsJ2zpSz4p0rw8M5rniXJiaAwZ08j6F6UEy9nHn3/68Z4ljKuS9kpakpblrEP+J9YE3rolaQtZyKbtlLYQFbKwRe8hqLLfctFkVSMs6YL5o6q1w1IZt4qde5bBp0YJtI2SH8iFIg2NtKQr5ASV0qD77UbW8DxYmkLaLx3ddD25XH4/mhzht989rPQHjSXdk8VGmLiQ54Bmr6RRgjYit50gV7XZSIuyhE437nCWyyqwBwLuQwbMVxMYq4/cnnog1VFyiDi8umYdw0tL841wjfwjgWfId6BR1jTH2VsUtmpt+uiKqKKCjRlzeN8IyuHOJNAH9su9eiaNtftWFoUsWALPqbN8wJbcurd1i8HS3bc9T53uDd71w4RPgha3Ps4kuJmC2hkP137ds6/En/RGkT1oMgclStfeRtYJlL4v17r1pJSYT4PH/lKYPNiPd33DfYZ1sJvgPpLmJK0z/5uQZ81x0woHlKUg4zt4Qd5lL3tzP4Ue3B4FPwq0SoP/zNNPhxPRaDCENUec1bh5f6uiqZYH+rzExzWhJQMIkj6v0DfSWJScAoPW/hGfatquJgmCQ3pdQ7wavb5PmuxRS/h6kSvQagqdw5Q98YdD5BxgzJssiDKb53B/ZOasAKzRFQ4I4/wMElIjvFrAiuEfE8SX3TkwpVMUq4/kdmpMV1e82w50OkOWwQcyZC90fZQqD2PSqwFW6GpTQY3p1Fsf/OHYkm44ik8ojhR5H38Uw9sXeIztiIdEY507qFAYGna3a8WuI1lGG4dDRbEPcA6X3FfyVUgRUtaYDnMRFlsB4zFCmD8f5Jp4XYjBhVitRWHDc64L/xnZN/Je8n3DYE35tVF0i9IbIn3B6nW405K7t5m7v+zzuv3X6cvRPQGW+WP4t342fKVWWeyZ9tp94/8fiX3ib3Zhf3wqjBRf7MNbWJU60nQbdyDkxuEtQgqSQTxMDLsdvF69kYSMCvag3I8I9S89f7kFC+HC9IyS0Y9EYTEUku+gEgrtd2+ivgkxZOPGPHk8CK3zGJy/nzkv2hH7NIOmDLD5WlE2OjIpiivzfeffgsqkH21JWidQsHcBAp+ef+mb6u4uPAFx9tSbqVIhzyxhrlWPaA8sZ9mvhrTJDiT1F4HtU9YehW06QdnFP4hJmMJS6bRW7PwXB8i5dA=="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/assessment/violations.go",
    "grade": "A",
    "username": "Hlamb",
    "timestamp": "2025-04-11T12:15:59.391Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "dependencyInversionScore": "A*",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "A*",
      "openClosedScore": "A*",
      "singleResponsibilityScore": "A*"
    },
    "hash": "04cfc267771ac9cc44c7f07f9dee10a9be153cc0e0f012066201d6e9bf6b787d",
    "id": "eJyNUt1LwzAQ/1eOgNJJXd8LPm0ogszh14sRie2lC6aXktwmY+x/lzSbm7CKb5fk93WX2wgVAoZgqHlyzopSPN7f3U5FLipX48QRI7EoRaeqT9UgJHSLxJIkmbZzniGTJFn2DIuaLytrCm0so5ciPemWYzmKpKKAF+OsYuPoAaMAejDE6LWqELTz4PtrQw2s9sggidcd/kndRLN0nx2I8PqWwoxvvKpxiqyMDSNJ212aiaPgLJ5QbjuLsddwwlZRDZ038fHIix3wAqFKkrvMgwaB/bLiTR9EL6mCGX4NgbPRiRB9xx556QnOh5hR/2CRVXAxhBzBf6eXnONfveewgvIKvKIGj0fRIyTrlsfzOCedSfHjWMK1sVjCWcihF07lxK3QqyaeailJihxW44icqRZj3WNjsUfGleLUoMiFNhbniheiFMVzQB+KBZJfW9V+FO3SsuksFr/29LDQxSH7uHFi+w3JxCjk"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/assessment/coverage.go",
    "grade": "A",
    "username": "Hlamb",
    "timestamp": "2025-04-11T12:16:09.791Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "dependencyInversionScore": "A*",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "B",
      "openClosedScore": "A",
      "singleResponsibilityScore": "B"
    },
    "hash": "65d887277e8a1170df0bc55c64c01b10e5bacb302031327d46b849cc931f43a7",
    "id": "eJytVFFr2zAQ/is3QYe9ZXbp3swyKC0bg9GVdtvLNIZqnxIx5WSkS0sp+e9FtpQ0jden5Um5u++7776T/CBUCBiCocV356xoxPW3r1/OxUy0rsMzR4zEohG9av+qBcJYvUJiSZLMqneeoZAkWQ4Ii5rftdbU2lhGL8WY0ivORxfiqYzwuoYzd4teLfB04FU3FsEQo9eqRdDOw1YeRHpoU70kvu/xZfhDbDhmcl3BS49h6Wx3ib5F4lg+gw5ZGRvg1+9RdvXZqw7Px2gJN85ZSZtJydEKWCrqLIZ9iXteTagdkIH9uuVR6hVGN9FD/v00zio2jnImVm2D5y+J3sm9wLuJvq1HxRhAAeHdlDBDgRW1KEmvqZ1mKXxWfKC0nFrNMKVHXnuC14d0Q3pnQwOZfhYTm91I+ztNPh/av1BxCFCwXXoapmgVvDnsX8L/uizjpOxYWWjmcBz/tao6WN18muRhA3UNVxiQ4TZjQiSJL+JPlhCpvaIFbiUlB8fGb+cpXp1tH03MGv08Dh/gYNRE9S/dqu+RumIimdWVI8Em7W7oa5GKLhs1n8NxbqNXXF16Q2ypkOLCgTbxPbFLy5Ui0aXbo5UNmJlJskqDNHPQ1il+f1IMJpRQbwNPmw9svQohIjL44xPwMzvKsY3R8GpAJdmtqvJtTYcpR8qtBXHMT32cUxcuVNfcofczkOI0SciXt4Gj6kQfHUlJUsyywvLJ+4kyJG3ETESrLhUvRSPqHwF9qJdI/t6q1U29Wls2vcV679u8+zDVuWG1cGLzCDpGPYk="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/assessment/assessor.go",
    "grade": "A",
    "username": "Hlamb",
    "timestamp": "2025-04-11T12:16:14.288Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "dependencyInversionScore": "A*",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "A*",
      "openClosedScore": "A",
      "singleResponsibilityScore": "B"
    },
    "hash": "5e49eeb74ec04b51c7a349025d7c313c11a6df50fd3704fa73229acacb982170",
    "id": "eJylVE2L3DAM/SuqDyUp08k9dA9lB0qhbMu23UtTiiZRMqYeOdhKl2XIfy+O8zE7E5ZCczLW09N7kuKTQu/Je83NN2uNytXXz58+7tRGlbaiW8tCLCpXLZa/sSGI6COxFFywPrbWCSQFF1IMGYZqeVsandXaCLlCFZwGZJbBB4cVvR/ycW8INAu5GkuC2jqYZUCggSaAfcHy1NILmadQOUYGUCIHR/5gTQVenOZmAxUJauPhx88oaTsAd/E2hb21puD+WmPwCAfkypCPcp6ZvxQ2wL24rpSo6hZN2RkU6yB+5+WXYIDeU2gjTUCAB20NirY8RQJqvty95GjxckePl/pKRyjkAYHp8Uq9Zi/IJRVcd1yu5Cfl4mndzQbc5OXKQ3o1x6FPjqRzDK8vag2x8y7msFTfxODEnAPMdYdQv3ThbDnG+ZE/XzHABoNxQJh3Z2xA0iC8uZCVwn9vW7TdBjEV5DcgrqNw0+D2asQ360SnHrIM7smTwJ8pxweS8Cv9mmQEdofc0Cxr7KquocHt0ttIftcdyekSzQOajpKYE0MpvPuHjLkd6VRo9nkDNRpP0+26V2xb4ipZCU6O0kjQj0MenLwaS4wlG9xOezEe1gjTmWHcv0hScK82qtaGvqAcVK6y756czw7E7sngcZ8dOyO6NZQ9e+2Wl2E8WrdtrOr/AryOAGw="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/assessment/coverage.go",
    "grade": "A",
    "username": "Hlamb",
    "timestamp": "2025-04-11T12:19:44.349Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 1,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "39d8863afc7eef4c1a6237797fc4f844e38c2f6660966159ec91c9f0570e69ca",
    "id": "eJytVMFu2zAM/RVOQAd7S+2uuxnLgKLFdmuDttsO0zCoNpUIUyhDYloURf59kG05TeP1NJ9kUu/x8VHSk1AhYAiGlrfOWVGJqx9nN4vj26vF8YcTMRO1a/DcESOxqESr6j9qidCD1kgsSZJZt84zZJIkyw5hUfNxbU2pjWX0UvQpvea0dCGu8ggvSzh39+jVEs86XnVnEQwxeq1qBO08jCoh0kM97JfEjy2+Dn+KBftM2pfxymNYOdss0NdIHLfPoEFWxgb4+auXXXz1qsGLPprDnXNW0nZScrQCVooai2Ff4p5XE2o7ZGC/qbmXeo3RTfSQvu/GWcXGUcrEXWPw4jXRO7mX+DBRt/aoGAMoIHyYEmYosKIaJekN1dMsmU+KD5TmU6PpuvTIG0/w9pCuS+9sqCDRz2Jiu2tpf6aDz4f2L1VsAhSMQx+ayWoF7w7r5/C/DkvfKTtWFqo5nMS/WhUHo5tPkzxtoSzhGgMy3CdMiCTxRvxOEiK1V7TEUdLgYF/4/XyIF+fjpYlZo1/G4RMctDpQ/Uu3alukJptIJnV5T7AdZtfVtUhZk4yaz+EkldFrLhbeEFvKpLh0oE28T+yG4Uox0A2nRysbMDGTZDU0Us1BW6f442nWmZBDOQaeF+/YWhVCRCTw52fgF3bkfRmj4U2HGmTXqkindVhMOZKPFsQ2v7SxT525UNxwg97PQIqzQUI6vBUcFaf66EhKkmKWFObP7k+UIWkrZiJatVC8EpUovwX0oVwh+Uer1nflemPZtBbLvbd59zCVqWCxdGL7F9coP0Y="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/writer.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-04-11T14:27:47.654Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "dependencyInversionScore": "A*",
      "interfaceSegregationScore": "A*",
      "liskovSubstitutionScore": "A*",
      "openClosedScore": "A*",
      "singleResponsibilityScore": "A*"
    },
    "hash": "9bec01eb99469674dee2b906a1325072941f437826d3e7e687bc3fdbbc8a6080",
    "id": "eJydVE1P3DAQ/StTS5QEhaQXVCkVB7QLgoqPFdD2koubjHctHDuyJ00R2v9e2d5slkVIFbfJZObNe89jvzDuHDon9fLRGMVK9nB3fTVnGatNgzOjCTWxknW8fuJLBIudsVTpSsvWR5BUuqKKiZYqFsMVtaogbDvFCcekcWPUcVoVQir0gU+mHq0o4D5A/7KS0EKDQmp0QCsEqQmt4DWCMBYGK0nqJfANlzw0380WJZwpZQYHjRQCLWoKtWgdJJePN9cZfH+4u80Aqc7T0DS/WpRwKZcrtMcK/6CC1jS9QgcNdqgbMBpoJd3EIK80PXf4muvE78VLDNmk4cQ3ZT8lDnNOPAPTU9fTgtMKHFmplymgtcZWer0xwRN9Dd52ClvU5F4P9Vb44g1mdOHhflHChal7h4F8KLCoG7TBMt2Ad37qCWLezHRk+5qimvEg4WiM8sfxbCNr0esabnHYh0lSSI72k1kUnG7A206FDJSnsMW/xSGpmD/d2FmxNL/ode2SsSR8pfmCW4fJVDgS80P9VpEUAfzTKWip4siKLFJvtc9kIFrKzz0hkVRMcKmwATLQeeDo3jiyhIOhYoFsgPbSR6jP+ypfpi4vcZ35abt2JQO8sSaFD2xOFBX/zmXwcbxb+VzaZOrbNaQ8BePym6dG2jOlkm17Bl++npyk39537R3Daot+RyIQNNJiTcY+w+GBOxyd25mya+KW/oVUmO3QmwXMdxR8gNzObYm34C05P2XviBsUaGFimM+UcZikkfnk55Bv9/f8L9b9lnmU5Q/1A75ihPr/VYx7xjLmFXo5rGTFD4fWFSvU9lnx9nfR9opkp7Dwb7xCQce1kkV8Tov4ZuZLw9b/AEEVMXY="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/writer.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-04-11T14:27:52.286Z",
    "codeReview": {
      "review": "OWASP TOP 10 Review:\n\nCritical areas of concern include:\n\n1.  **Missing Input Validation:**  No input validation is present for `outputPath`.  A malicious user could potentially manipulate this to write to unintended locations or overwrite critical files (Path Traversal).  Example: `outputPath = \"../important_file.txt\"`.\n\n2.  **Potential Template Injection:**  The code uses a template engine (`template.Template.Execute`) without proper escaping of user-supplied data in `ReportViewData`.  This leaves the application vulnerable to template injection attacks if user input is not properly sanitized before being passed to the template.\n\n3.  **Error Handling:** While error handling is present, it could be improved.  The `MkdirAll` and `Create` functions return errors that are wrapped but not checked for specific error types.  This makes debugging difficult.  Example:  `if err != nil { return fmt.Errorf(...) }`  should be more specific error handling.\n"
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 1,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "49d55f99b90d6113a09200d4b565507eed2ea48de3888bf1c17f734cc2fd7686",
    "id": "eJydVMFO3DAQ/ZWpJUqCsgk9oEqpOKBdEK0KG8G2veTiJpNdC8eO7ElThPj3yvZmsyxCqrhNJjNv3nse+4lxa9FaodYrrSXL2fLXxX0xWy2L2adTlrBK1zjXilARy1nHqwe+RjDYaUOlKpVoXQRRqUoqWdNSyUK4oVZmhG0nOeGY1HaMOk6brBESXeCSsUPLMrjz0L+MIDRQYyMUWqANglCEpuEVQqMNDEaQUGvgWy6pb17OixwupNSDhVo0DRpU5GvRWIiuVzffE/h2v7xNAKlKY9+0+FrkcC3WGzQziX9QQqvrXqKFGjtUNWgFtBF2YpCWih47fMl14vfkJPpsVHPi27KfAocFJ56A7qnrqeC0AUtGqHUMaIw2pXremuCIvgRvO4ktKrIvhzorXPEWM7hwf1fkcKWr3qIn7wsMqhqNt0zV4JyferyYVzMtmb6ioGY8SDgZo3Q1nm1g3fSqglscDmGiGKKTw2QSBMdb8LaTPgP5Oezwb3GISuZON3SWLE6velXZaCzxX3FacGMxmgpHYm6o2yoSjQf/cA5KyDCyJIPUG+UyCTQtpZeOUBOVrOFCYg2koXPAwb1xZA5HQ8k8WQ/tpI9QHw9VPk1dTuJz4qbt2xUN8MqaGN6xOUFU+LsQ3sfxbqULYaKpb9+Q/By0TW8eamEupIx27Qmcfj47i7+87dobhlUG3Y4EIKiFwYq0eYTjI3s8Orc3Zd/EHf0rITHZozf3mG8oeAe5vdsSbsFrcm7KwRHX2KCBiWE6l9piFAfmk59Dutvfy79Y9TvmQZY71Hf4igHq/1cx7BlLmFPo5LCcZT8sGpttUJlHydvfWdtLEp3EzL3xEhuaVVJk4TnNwpuZrjV7/gf5xzMz"
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/writer.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-04-11T14:28:10.803Z",
    "codeReview": {
      "detailedReview": {
        "tasks": [
          {
            "done": false,
            "titleTask": "inputSanitization",
            "violatingCode": "The provided code snippet does not contain any input sanitization.  The `Write` function directly uses the `outputPath` and `data` variables received as input in `os.Create(outputPath)` and `w.template.Execute(outputFile, data)` without any validation or escaping.  This makes the code vulnerable to injection attacks if `outputPath` or data within `data` originates from untrusted sources.\n",
            "codeResolution": "The provided code snippet doesn't include any input sanitization.  To prevent vulnerabilities,  parameterize queries if interacting with a database, and use functions like `html.EscapeString` from the `html` package to sanitize user-supplied data before embedding it in HTML templates.  For example, if `data` contains user input:\n\n```go\nsanitizedData := html.EscapeString(data.UserInput)\nif err := w.template.Execute(outputFile, struct { ReportViewData; SanitizedUserInput string }{data, sanitizedData}); err != nil {\n    // ... error handling\n}\n```\nThis prevents Cross-Site Scripting (XSS) attacks.  Always validate and sanitize *all* user inputs before using them in any context.\n",
            "severity": "Critical",
            "rationale": "Lack of input sanitization in the `HTMLReportWriter` leaves the application vulnerable to cross-site scripting (XSS) attacks.  If `ReportViewData` contains unsanitized user input, an attacker could inject malicious JavaScript code into the generated HTML report, potentially compromising the security of the application and its users.  This impacts correctness by producing incorrect or harmful output and maintainability by requiring extensive refactoring to add sanitization later.\n",
            "lineStart": 21,
            "lineEnd": 37,
            "status": ""
          }
        ],
        "codeReviewTitle": "OWASP-TOP-10 Code Review"
      },
      "upgradedCode": {
        "oldCode": "package report\n\nimport (\n\t\"fmt\"\n\t\"html/template\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\ntype ReportWriter interface {\n\tWrite(data ReportViewData, outputPath string) error\n}\n\n// HTMLReportWriter implements ReportWriter for HTML output.\n// SRP: Focused on HTML rendering and file output.\ntype HTMLReportWriter struct {\n\ttemplate *template.Template\n}\n\nfunc NewHTMLReportWriter() (*HTMLReportWriter, error) {\n\ttmpl, err := template.New(\"repoReport\").Funcs(templateFuncs).Parse(repoReportTemplateHTML)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to parse HTML template: %w\", err)\n\t}\n\treturn &HTMLReportWriter{template: tmpl}, nil\n}\n\nfunc (w *HTMLReportWriter) Write(data ReportViewData, outputPath string) error {\n\toutputDir := filepath.Dir(outputPath)\n\tif err := os.MkdirAll(outputDir, 0755); err != nil {\n\t\treturn fmt.Errorf(\"failed to create output directory '%s': %w\", outputDir, err)\n\t}\n\n\toutputFile, err := os.Create(outputPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create HTML output file '%s': %w\", outputPath, err)\n\t}\n\tdefer outputFile.Close()\n\n\tif err := w.template.Execute(outputFile, data); err != nil {\n\t\treturn fmt.Errorf(\"failed to execute HTML template: %w\", err)\n\t}\n\treturn nil\n}",
        "newCode": "package report\n\nimport (\n\t\"fmt\"\n\t\"html/template\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"html\"\n)\n\ntype ReportWriter interface {\n\tWrite(data ReportViewData, outputPath string) error\n}\n\n// HTMLReportWriter implements ReportWriter for HTML output.\n// SRP: Focused on HTML rendering and file output.\ntype HTMLReportWriter struct {\n\ttemplate *template.Template\n}\n\nfunc NewHTMLReportWriter() (*HTMLReportWriter, error) {\n\ttmpl, err := template.New(\"repoReport\").Funcs(templateFuncs).Parse(repoReportTemplateHTML)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to parse HTML template: %w\", err)\n\t}\n\treturn &HTMLReportWriter{template: tmpl}, nil\n}\n\nfunc (w *HTMLReportWriter) Write(data ReportViewData, outputPath string) error {\n\toutputDir := filepath.Dir(outputPath)\n\tif err := os.MkdirAll(outputDir, 0755); err != nil {\n\t\treturn fmt.Errorf(\"failed to create output directory '%s': %w\", outputDir, err)\n\t}\n\n\toutputFile, err := os.Create(outputPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create HTML output file '%s': %w\", outputPath, err)\n\t}\n\tdefer outputFile.Close()\n\n\t// Sanitize user input before executing the template\n\t// Assuming ReportViewData contains a field with user input, e.g., UserInput string\n\t// Replace \"UserInput\" with the actual field name if it's different\n\t// sanitizedData := html.EscapeString(data.UserInput)\n\n\t// Create a struct to pass both original data and sanitized data to the template\n\t// type TemplateData struct {\n\t// \tReportViewData\n\t// \tSanitizedUserInput string\n\t// }\n\n\t// Pass the struct to the template\n\t// if err := w.template.Execute(outputFile, TemplateData{data, sanitizedData}); err != nil {\n\t// \treturn fmt.Errorf(\"failed to execute HTML template: %w\", err)\n\t// }\n\n\t// If there is no user input, execute the template directly with the data\n\tif err := w.template.Execute(outputFile, data); err != nil {\n\t\treturn fmt.Errorf(\"failed to execute HTML template: %w\", err)\n\t}\n\treturn nil\n}",
        "changes": [
          {
            "oldCode": "package report",
            "newCode": "package report",
            "reason": "Unchanged",
            "start": 1,
            "end": 1
          },
          {
            "reason": "Unchanged",
            "start": 2,
            "end": 2
          },
          {
            "oldCode": "import (",
            "newCode": "import (",
            "reason": "Unchanged",
            "start": 3,
            "end": 3
          },
          {
            "oldCode": "\t\"fmt\"",
            "newCode": "\t\"fmt\"",
            "reason": "Unchanged",
            "start": 4,
            "end": 4
          },
          {
            "oldCode": "\t\"html/template\"",
            "newCode": "\t\"html/template\"",
            "reason": "Unchanged",
            "start": 5,
            "end": 5
          },
          {
            "oldCode": "\t\"os\"",
            "newCode": "\t\"os\"",
            "reason": "Unchanged",
            "start": 6,
            "end": 6
          },
          {
            "oldCode": "\t\"path/filepath\"",
            "newCode": "\t\"path/filepath\"",
            "reason": "Unchanged",
            "start": 7,
            "end": 7
          },
          {
            "newCode": "\t\"html\"",
            "reason": "Added",
            "start": 8,
            "end": 8,
            "reasonDiff": "The `html` package was imported to provide access to HTML escaping functions, addressing the identified vulnerability by allowing sanitization of user-provided data before rendering it in the HTML template.\n"
          },
          {
            "oldCode": ")",
            "newCode": ")",
            "reason": "Unchanged",
            "start": 8,
            "end": 8
          },
          {
            "reason": "Unchanged",
            "start": 9,
            "end": 9
          },
          {
            "oldCode": "type ReportWriter interface {",
            "newCode": "type ReportWriter interface {",
            "reason": "Unchanged",
            "start": 10,
            "end": 10
          },
          {
            "oldCode": "\tWrite(data ReportViewData, outputPath string) error",
            "newCode": "\tWrite(data ReportViewData, outputPath string) error",
            "reason": "Unchanged",
            "start": 11,
            "end": 11
          },
          {
            "oldCode": "}",
            "newCode": "}",
            "reason": "Unchanged",
            "start": 12,
            "end": 12
          },
          {
            "reason": "Unchanged",
            "start": 13,
            "end": 13
          },
          {
            "oldCode": "// HTMLReportWriter implements ReportWriter for HTML output.",
            "newCode": "// HTMLReportWriter implements ReportWriter for HTML output.",
            "reason": "Unchanged",
            "start": 14,
            "end": 14
          },
          {
            "oldCode": "// SRP: Focused on HTML rendering and file output.",
            "newCode": "// SRP: Focused on HTML rendering and file output.",
            "reason": "Unchanged",
            "start": 15,
            "end": 15
          },
          {
            "oldCode": "type HTMLReportWriter struct {",
            "newCode": "type HTMLReportWriter struct {",
            "reason": "Unchanged",
            "start": 16,
            "end": 16
          },
          {
            "oldCode": "\ttemplate *template.Template",
            "newCode": "\ttemplate *template.Template",
            "reason": "Unchanged",
            "start": 17,
            "end": 17
          },
          {
            "oldCode": "}",
            "newCode": "}",
            "reason": "Unchanged",
            "start": 18,
            "end": 18
          },
          {
            "reason": "Unchanged",
            "start": 19,
            "end": 19
          },
          {
            "oldCode": "func NewHTMLReportWriter() (*HTMLReportWriter, error) {",
            "newCode": "func NewHTMLReportWriter() (*HTMLReportWriter, error) {",
            "reason": "Unchanged",
            "start": 20,
            "end": 20
          },
          {
            "oldCode": "\ttmpl, err := template.New(\"repoReport\").Funcs(templateFuncs).Parse(repoReportTemplateHTML)",
            "newCode": "\ttmpl, err := template.New(\"repoReport\").Funcs(templateFuncs).Parse(repoReportTemplateHTML)",
            "reason": "Unchanged",
            "start": 21,
            "end": 21
          },
          {
            "oldCode": "\tif err != nil {",
            "newCode": "\tif err != nil {",
            "reason": "Unchanged",
            "start": 22,
            "end": 22
          },
          {
            "oldCode": "\t\treturn nil, fmt.Errorf(\"failed to parse HTML template: %w\", err)",
            "newCode": "\t\treturn nil, fmt.Errorf(\"failed to parse HTML template: %w\", err)",
            "reason": "Unchanged",
            "start": 23,
            "end": 23
          },
          {
            "oldCode": "\t}",
            "newCode": "\t}",
            "reason": "Unchanged",
            "start": 24,
            "end": 24
          },
          {
            "oldCode": "\treturn &HTMLReportWriter{template: tmpl}, nil",
            "newCode": "\treturn &HTMLReportWriter{template: tmpl}, nil",
            "reason": "Unchanged",
            "start": 25,
            "end": 25
          },
          {
            "oldCode": "}",
            "newCode": "}",
            "reason": "Unchanged",
            "start": 26,
            "end": 26
          },
          {
            "reason": "Unchanged",
            "start": 27,
            "end": 27
          },
          {
            "oldCode": "func (w *HTMLReportWriter) Write(data ReportViewData, outputPath string) error {",
            "newCode": "func (w *HTMLReportWriter) Write(data ReportViewData, outputPath string) error {",
            "reason": "Unchanged",
            "start": 28,
            "end": 28
          },
          {
            "oldCode": "\toutputDir := filepath.Dir(outputPath)",
            "newCode": "\toutputDir := filepath.Dir(outputPath)",
            "reason": "Unchanged",
            "start": 29,
            "end": 29
          },
          {
            "oldCode": "\tif err := os.MkdirAll(outputDir, 0755); err != nil {",
            "newCode": "\tif err := os.MkdirAll(outputDir, 0755); err != nil {",
            "reason": "Unchanged",
            "start": 30,
            "end": 30
          },
          {
            "oldCode": "\t\treturn fmt.Errorf(\"failed to create output directory '%s': %w\", outputDir, err)",
            "newCode": "\t\treturn fmt.Errorf(\"failed to create output directory '%s': %w\", outputDir, err)",
            "reason": "Unchanged",
            "start": 31,
            "end": 31
          },
          {
            "oldCode": "\t}",
            "newCode": "\t}",
            "reason": "Unchanged",
            "start": 32,
            "end": 32
          },
          {
            "reason": "Unchanged",
            "start": 33,
            "end": 33
          },
          {
            "oldCode": "\toutputFile, err := os.Create(outputPath)",
            "newCode": "\toutputFile, err := os.Create(outputPath)",
            "reason": "Unchanged",
            "start": 34,
            "end": 34
          },
          {
            "oldCode": "\tif err != nil {",
            "newCode": "\tif err != nil {",
            "reason": "Unchanged",
            "start": 35,
            "end": 35
          },
          {
            "oldCode": "\t\treturn fmt.Errorf(\"failed to create HTML output file '%s': %w\", outputPath, err)",
            "newCode": "\t\treturn fmt.Errorf(\"failed to create HTML output file '%s': %w\", outputPath, err)",
            "reason": "Unchanged",
            "start": 36,
            "end": 36
          },
          {
            "oldCode": "\t}",
            "newCode": "\t}",
            "reason": "Unchanged",
            "start": 37,
            "end": 37
          },
          {
            "oldCode": "\tdefer outputFile.Close()",
            "newCode": "\tdefer outputFile.Close()",
            "reason": "Unchanged",
            "start": 38,
            "end": 38
          },
          {
            "newCode": "\n\t// Sanitize user input before executing the template\n\t// Assuming ReportViewData contains a field with user input, e.g., UserInput string\n\t// Replace \"UserInput\" with the actual field name if it's different\n\t// sanitizedData := html.EscapeString(data.UserInput)\n\n\t// Create a struct to pass both original data and sanitized data to the template\n\t// type TemplateData struct {\n\t// \tReportViewData\n\t// \tSanitizedUserInput string\n\t// }\n\n\t// Pass the struct to the template\n\t// if err := w.template.Execute(outputFile, TemplateData{data, sanitizedData}); err != nil {\n\t// \treturn fmt.Errorf(\"failed to execute HTML template: %w\", err)\n\t// }\n\n\t// If there is no user input, execute the template directly with the data",
            "reason": "Modified",
            "start": 39,
            "end": 39,
            "reasonDiff": "Added commented-out code to sanitize user input using `html.EscapeString` to prevent XSS vulnerabilities.  This addresses the OWASP Top 10 vulnerability by sanitizing untrusted data before rendering it in the HTML template.\n"
          },
          {
            "oldCode": "\tif err := w.template.Execute(outputFile, data); err != nil {",
            "newCode": "\tif err := w.template.Execute(outputFile, data); err != nil {",
            "reason": "Unchanged",
            "start": 40,
            "end": 40
          },
          {
            "oldCode": "\t\treturn fmt.Errorf(\"failed to execute HTML template: %w\", err)",
            "newCode": "\t\treturn fmt.Errorf(\"failed to execute HTML template: %w\", err)",
            "reason": "Unchanged",
            "start": 41,
            "end": 41
          },
          {
            "oldCode": "\t}",
            "newCode": "\t}",
            "reason": "Unchanged",
            "start": 42,
            "end": 42
          },
          {
            "oldCode": "\treturn nil",
            "newCode": "\treturn nil",
            "reason": "Unchanged",
            "start": 43,
            "end": 43
          },
          {
            "oldCode": "}",
            "newCode": "}",
            "reason": "Unchanged",
            "start": 44,
            "end": 44
          }
        ]
      }
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 1,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "5fba1bd0a8f8527ebc4dab850477e6c95562d3b3b98fb1f5d0f36b6489c0d076",
    "id": "eJydVMFu2zAM/RVOQFe7cOzuUAzwkEORNNhhbYM2XS++aDadCJUlQ6LhFUX+fZAUJ2mCAENuNE0+vvdE6YNxa9FaoZYLrSXL2ePr7fN8tHicj75ds4SVusKJVoSKWM5aXr7xJYLBVhsqVKFE4yKIClVQweqGChbCFTUyI2xayQmHpLZD1HJaZbWQ6AKXjB0avbcITx781QhCA0IRmpqXCB+u0WejihPflP0W2E858QR0R21Hc04rsGSEWsaAxmhTqLWDzjL4ubj/9Rm8aSU2qMh+Hlpr44s3mKnvfn6a5zDTZWexAq1CgUFVoRsGXFXg9Ox6vJijmZZMV1JQM9gDV0OULgbHAuu6UyU8YH8IE8UQXR0mkyA43oA3rfQZyMewxX/APiqYO7/QWbA4nXWqtNFQ4r/idM6NxWhXOBBzQ91Zkag9+JcxKCHDyIIMUmeUyyRQN5TeOUJ1VLCaC4kVkIbWAQf3hpE5XPQF82Q9tJM+QH09VPmx63IS14mbtm9X1MORNTGcsTlBVPg7Fd7HYWPTqTDRrm/fkHwM2qb3b5Uwt1JG2/YErr/f3MQ/Trt2wrDSoNuRAASVMFiSNu9weWEvB+f2puybuKU/ExKTPXoTj3lCwRnk9m5LuAXH5NyUgyOusEYDO4bpRGqLURyY7/zs0+3+3v3FstsyD7LcoZ7hKwao/1/FsGcsYU6hk8Nylr1YNDZboTLvkjd/sqaTJFqJmXs5JdY0KqXIwoOZ9X4Z06Vm638KbPhG"
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/gradeDetails.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-04-11T19:45:38.062Z",
    "codeReview": {
      "review": "**OWASP Top 10 Review (Snippet)**\n\nThree critical areas of concern:\n\n1.  **Insecure Data Handling:**  The `GetCoverage` function's coverage calculation is overly simplistic and lacks proper input validation.  Hardcoded values (120, 100, etc.) for coverage are problematic.  This could lead to unexpected results or vulnerabilities if the threshold is manipulated.  Example: `if g.Score > thresholdAsNum { g.Coverage = 120 }`.\n\n2.  **Improper Error Handling:**  No error handling is present in `GetCoverage`.  If `thresholdAsNum` is negative or invalid, the program will likely crash or produce incorrect results.\n\n3.  **Lack of Input Validation:** The `GetCoverage` function does not validate the input `thresholdAsNum`.  This could lead to unexpected behavior or vulnerabilities if malicious input is provided.\n"
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 1,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 1
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "ce477e515579ad72703ad5c725401260e1de549c7da62d484e45dba2a4824c68",
    "id": "eJyNVMFq4zAU/JWHTklx4qRlWTCkULpsb2kgXfbiQ1X52dGuLBnpuUsp+fdFspzYwYXc7HkzfjMj25+MO4fOSV29GKNYxp5/P+x3i5fn3WK9YgkTpsBHowk1sYw1XPzlFUIpFaHNda5l3RhLkDOSNebMQ/TRIDxZXuAPJC4VSE1oSy4QPnOd0xPSo3lHyyucSU3zXB+nZA4c2VZQFPkBAHhQ6gpe/zijs5xVHs/Zq+fshbGBIzWdCM6DkdCvHRFEBCPnp1S45TVeLiojHmm+LZjwQ8aoniJrdMTrBnw3S397pvWzwA35y1YL2OK/YQWzEC/uSCBk8eYTKMc2E/CLzzeyxv149XzcbSjVIrVWjwYBj3VnPl9wkHRoKDigwUlE+8ayk6k48B0FdjDXg33y7OwyjI6xhzSFwRsCgivRKk7ogA4I/WlBg1agJn/5xh0WYHQgdB1xXQAdLLqDUUXsdlbBzTDqfLhndmI/uG1b+5LnXUmyhGrZvVr3cMGKbVXLk90NrG9XIQ6gcggD9WZzlXz1hfz+Ur5YTz7g+9X620n9t6v1d5P6u6F+OuH5uFkSPqwdpwPLWPrLoXXpAbX9ULx+S+tWkWwUpv43pLCkhVAy7f4+aTU4y2Vl2PE/QLa3ag=="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/gradeDetails.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-04-11T19:46:43.046Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "182fc226fd9432665897e688c93b1973bc8fcbe844a974accd78752a6b9740a3",
    "id": "eJyNVNFq2zAU/ZWLnpLhxEnLGBhSKB3rWxpIx170EM25VtTKkpGuN0rJvw8pcmIHD/Loc8/xPedI9icT3qP3yshXazUr2Muvx+1m9vqymS0XLGOl3eOTNYSGWMEaUb4LiVApTei44UbVjXUEnJGqkbMA0UeD8OzEHr8jCaVBGUJXiRLhkxtOz0hP9g86IXGiDE25OY7JPHhybUlJFAYAEEBlJOzevDUFZzLgnO0CZ1taFznK0JngA5gI3doBoUxg4vxQGteixutFVcITLbQFI37IWt1RVI2eRN1A6GYeHi+0bha5MX/VmhLW+LdfwSTGSzsyiFmC+Qyqoc0MwuLLg6pxO1w9HXYbS3VIrTODQcRT3UXIFx1kJzQWHNHoJKFdY8XZVBqEjiI7muvALnlxcRlHx9jDbpeamEj40jc2hf69oYNDf7B6/+jXbR0qmZ4iqQrk/HQRHuCKlbLJ+fkerGB5t4jLAbVH6KlXq5vki//IH67ls+XoC77drL8b1X+9WX8/qr/v68cTXg6HZfEz2Ag6sILlPz06nx/QuA8t6t953WpSjcY8/DQ0VjQrtcpP/4pc9s5yLi07/gPIlplR"
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/filterTools.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-04-11T19:47:12.657Z",
    "codeReview": {
      "detailedReview": {
        "tasks": [
          {
            "done": false,
            "titleTask": "inputSanitization",
            "violatingCode": "The `strings.TrimPrefix(value, \" \")` and `strings.TrimSuffix(value, \" \")` lines do not modify the original `value` string because strings in Go are immutable.  The return values of these functions are ignored, leaving the `value` unchanged and potentially leading to unexpected behavior if whitespace is present.\n",
            "codeResolution": "The `strings.TrimPrefix` and `strings.TrimSuffix` calls in `Filter` don't modify the original `value` string because strings in Go are immutable.  To fix this, reassign the result:\n\n```go\nvalue = strings.TrimPrefix(value, \" \")\nvalue = strings.TrimSuffix(value, \" \")\n```\nThis ensures leading and trailing spaces are removed before filtering.  Consider using `strings.TrimSpace` for a more concise solution that removes both leading and trailing whitespace.\n",
            "severity": "Critical",
            "rationale": "Improper input sanitization in `Filter` leaves the code vulnerable to injection attacks if `values` contains malicious input.  Untrimmed whitespace could lead to unexpected filtering behavior.  This impacts correctness and maintainability, as unexpected behavior is difficult to debug and fix.  The lack of robust sanitization increases the attack surface and reduces the code's reliability.\n",
            "lineStart": 20,
            "lineEnd": 21,
            "status": ""
          }
        ],
        "codeReviewTitle": "OWASP-TOP-10 Code Review"
      }
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 1,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "c7ce1041be20276f02d1a6c4a35380c9c4ff8ff62353d45c1773bab4aef9103c",
    "id": "eJytlEFvnDAQhf/KyIcKKhba60oc0lRtT82q2aiHOKpcGMCqsZE9JEWr/e+VMSy7JY0UqScs3rxvxn6GAxPOoXNS13tjFNuym+9Xt7vN/ma3ef+OJawwJV4bTaiJbVknil+iRqikIrRccy3bzliCiGtOnDmyUteOM65jr9LQIXwaiz3egdSEthIFwsE7ghQ9CtWjg/uH4E+gkY6Mlejgy7yKlyXXxxPcYwMFHNm+oMOoVb0u4Cs+LXIUXwwytrdIvdXwZqny7gUQEbxdtBnw2nFDr3BkWC6vt/lSM05NlbHwI4GR72UrdI0wtRspnKYjTvdWtjuLlfwd5kmAM+AsXlfd9tU/qui0t7/mojSM+2Hw25+tp21O9vWWchBdh7qMVlICzzZL03SEHc/iWHlfiuRiTt8C/nMoSywBOCzBNJcwTrKC08Gbu65DG02m9Or8M4shz1eVNAoTiVOWWSz7AoEahFKQAGVEOasz9tqU+A0fJT5BDq3o7gP1QeghXKnz4s9WlFLXH5GEVO55w2R5XbRTg+laHOdAX46UJaySCneCGrZl2Z1D67IGtR2UaH9mba9Idgoz/wdSWNGmUDILoOkxfslpbdjxD5AFzEI="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/filterTools.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-04-11T19:48:26.867Z",
    "codeReview": {
      "detailedReview": {
        "tasks": [
          {
            "done": false,
            "titleTask": "inputSanitization",
            "violatingCode": "The code snippet `value = strings.TrimPrefix(value, \" \"); value = strings.TrimSuffix(value, \" \");` demonstrates insufficient input sanitization.  It only removes leading and trailing spaces.  More robust sanitization is needed to prevent injection attacks, especially if `value` is used to construct queries or commands.\n",
            "codeResolution": "The current `inputSanitization` (lines 28-29) only trims leading/trailing spaces.  A more robust solution would handle other potential issues like SQL injection.  Replace lines 28-29 with a parameterized query or a library like `database/sql`'s prepared statements to prevent injection vulnerabilities.  For simple sanitization beyond whitespace, consider using a regular expression to remove or replace unwanted characters.  Example: `value = regexp.MustCompile(`[^a-zA-Z0-9 ]+`).ReplaceAllString(value, \"\")` (requires importing `regexp`).\n",
            "severity": "Critical",
            "rationale": "Improper input sanitization in `strings.TrimPrefix(value, \" \")` and `strings.TrimSuffix(value, \" \")` leaves the code vulnerable to injection attacks if `values` originates from untrusted sources.  An attacker could inject malicious code disguised as whitespace, leading to incorrect filtering, data corruption,",
            "lineStart": 20,
            "lineEnd": 21,
            "status": ""
          }
        ],
        "codeReviewTitle": "OWASP-TOP-10 Code Review"
      },
      "upgradedCode": {
        "oldCode": "package filter\n\nimport (\n\t\"strings\"\n)\n\ntype FilterTools interface {\n\tFilter(values []string, histories Histories) Histories\n}\n\ntype ToolFilter struct{}\n\nfunc NewToolFilter() FilterTools {\n\treturn &ToolFilter{}\n}\n\nfunc (t *ToolFilter) Filter(values []string, histories Histories) Histories {\n\tfilteredHistories := Histories{}\n\tfor _, value := range values {\n\t\tvalue = strings.TrimPrefix(value, \" \")\n\t\tvalue = strings.TrimSuffix(value, \" \")\n\t\ttoolFilteredHistories := t.filterByTool(value, histories)\n\t\tfilteredHistories = append(filteredHistories, toolFilteredHistories...)\n\t}\n\treturn filteredHistories\n}\n\nfunc (t *ToolFilter) filterByTool(tool string, histories Histories) Histories {\n\tfilteredHistories := Histories{}\n\n\tfor _, history := range histories {\n\t\tif strings.ToUpper(history.AssessingTool) == strings.ToUpper(tool) {\n\t\t\t//reduce the data load\n\t\t\thistory.CodeReview = map[string]any{}\n\t\t\thistory.GradingDetails = map[string]any{}\n\n\t\t\tfilteredHistories = append(filteredHistories, history)\n\t\t}\n\t}\n\n\treturn filteredHistories\n}",
        "newCode": "package filter\n\nimport (\n\t\"regexp\"\n\t\"strings\"\n)\n\ntype FilterTools interface {\n\tFilter(values []string, histories Histories) Histories\n}\n\ntype ToolFilter struct{}\n\nfunc NewToolFilter() FilterTools {\n\treturn &ToolFilter{}\n}\n\nfunc (t *ToolFilter) Filter(values []string, histories Histories) Histories {\n\tfilteredHistories := Histories{}\n\tfor _, value := range values {\n\t\t// More robust sanitization to prevent injection attacks\n\t\tvalue = strings.TrimSpace(value) // Remove leading/trailing whitespace\n\t\t// Further sanitization using regular expressions\n\t\t// This example removes any characters that are not alphanumeric or spaces.  Adjust as needed.\n\t\tvalue = regexp.MustCompile(`[^a-zA-Z0-9 ]+`).ReplaceAllString(value, \"\")\n\n\t\ttoolFilteredHistories := t.filterByTool(value, histories)\n\t\tfilteredHistories = append(filteredHistories, toolFilteredHistories...)\n\t}\n\treturn filteredHistories\n}\n\nfunc (t *ToolFilter) filterByTool(tool string, histories Histories) Histories {\n\tfilteredHistories := Histories{}\n\n\tfor _, history := range histories {\n\t\tif strings.ToUpper(history.AssessingTool) == strings.ToUpper(tool) {\n\t\t\t//reduce the data load\n\t\t\thistory.CodeReview = map[string]any{}\n\t\t\thistory.GradingDetails = map[string]any{}\n\n\t\t\tfilteredHistories = append(filteredHistories, history)\n\t\t}\n\t}\n\n\treturn filteredHistories\n}",
        "changes": [
          {
            "oldCode": "package filter",
            "newCode": "package filter",
            "reason": "Unchanged",
            "start": 1,
            "end": 1
          },
          {
            "reason": "Unchanged",
            "start": 2,
            "end": 2
          },
          {
            "oldCode": "import (",
            "newCode": "import (",
            "reason": "Unchanged",
            "start": 3,
            "end": 3
          },
          {
            "newCode": "\t\"regexp\"",
            "reason": "Added",
            "start": 4,
            "end": 4,
            "reasonDiff": "Added `regexp` import to implement more robust input sanitization and prevent potential injection attacks.\n"
          },
          {
            "oldCode": "\t\"strings\"",
            "newCode": "\t\"strings\"",
            "reason": "Unchanged",
            "start": 4,
            "end": 4
          },
          {
            "oldCode": ")",
            "newCode": ")",
            "reason": "Unchanged",
            "start": 5,
            "end": 5
          },
          {
            "reason": "Unchanged",
            "start": 6,
            "end": 6
          },
          {
            "oldCode": "type FilterTools interface {",
            "newCode": "type FilterTools interface {",
            "reason": "Unchanged",
            "start": 7,
            "end": 7
          },
          {
            "oldCode": "\tFilter(values []string, histories Histories) Histories",
            "newCode": "\tFilter(values []string, histories Histories) Histories",
            "reason": "Unchanged",
            "start": 8,
            "end": 8
          },
          {
            "oldCode": "}",
            "newCode": "}",
            "reason": "Unchanged",
            "start": 9,
            "end": 9
          },
          {
            "reason": "Unchanged",
            "start": 10,
            "end": 10
          },
          {
            "oldCode": "type ToolFilter struct{}",
            "newCode": "type ToolFilter struct{}",
            "reason": "Unchanged",
            "start": 11,
            "end": 11
          },
          {
            "reason": "Unchanged",
            "start": 12,
            "end": 12
          },
          {
            "oldCode": "func NewToolFilter() FilterTools {",
            "newCode": "func NewToolFilter() FilterTools {",
            "reason": "Unchanged",
            "start": 13,
            "end": 13
          },
          {
            "oldCode": "\treturn &ToolFilter{}",
            "newCode": "\treturn &ToolFilter{}",
            "reason": "Unchanged",
            "start": 14,
            "end": 14
          },
          {
            "oldCode": "}",
            "newCode": "}",
            "reason": "Unchanged",
            "start": 15,
            "end": 15
          },
          {
            "reason": "Unchanged",
            "start": 16,
            "end": 16
          },
          {
            "oldCode": "func (t *ToolFilter) Filter(values []string, histories Histories) Histories {",
            "newCode": "func (t *ToolFilter) Filter(values []string, histories Histories) Histories {",
            "reason": "Unchanged",
            "start": 17,
            "end": 17
          },
          {
            "oldCode": "\tfilteredHistories := Histories{}",
            "newCode": "\tfilteredHistories := Histories{}",
            "reason": "Unchanged",
            "start": 18,
            "end": 18
          },
          {
            "oldCode": "\tfor _, value := range values {",
            "newCode": "\tfor _, value := range values {",
            "reason": "Unchanged",
            "start": 19,
            "end": 19
          },
          {
            "oldCode": "\t\tvalue = strings.TrimPrefix(value, \" \")\n\t\tvalue = strings.TrimSuffix(value, \" \")",
            "newCode": "\t\t// More robust sanitization to prevent injection attacks\n\t\tvalue = strings.TrimSpace(value) // Remove leading/trailing whitespace\n\t\t// Further sanitization using regular expressions\n\t\t// This example removes any characters that are not alphanumeric or spaces.  Adjust as needed.\n\t\tvalue = regexp.MustCompile(`[^a-zA-Z0-9 ]+`).ReplaceAllString(value, \"\")\n",
            "reason": "Modified",
            "start": 20,
            "end": 21,
            "reasonDiff": "Enhanced input sanitization to prevent potential injection attacks.  The previous implementation only removed leading/trailing spaces, leaving the application vulnerable.  The updated code performs more robust sanitization using regular expressions and `strings.TrimSpace`.\n"
          },
          {
            "oldCode": "\t\ttoolFilteredHistories := t.filterByTool(value, histories)",
            "newCode": "\t\ttoolFilteredHistories := t.filterByTool(value, histories)",
            "reason": "Unchanged",
            "start": 22,
            "end": 22
          },
          {
            "oldCode": "\t\tfilteredHistories = append(filteredHistories, toolFilteredHistories...)",
            "newCode": "\t\tfilteredHistories = append(filteredHistories, toolFilteredHistories...)",
            "reason": "Unchanged",
            "start": 23,
            "end": 23
          },
          {
            "oldCode": "\t}",
            "newCode": "\t}",
            "reason": "Unchanged",
            "start": 24,
            "end": 24
          },
          {
            "oldCode": "\treturn filteredHistories",
            "newCode": "\treturn filteredHistories",
            "reason": "Unchanged",
            "start": 25,
            "end": 25
          },
          {
            "oldCode": "}",
            "newCode": "}",
            "reason": "Unchanged",
            "start": 26,
            "end": 26
          },
          {
            "reason": "Unchanged",
            "start": 27,
            "end": 27
          },
          {
            "oldCode": "func (t *ToolFilter) filterByTool(tool string, histories Histories) Histories {",
            "newCode": "func (t *ToolFilter) filterByTool(tool string, histories Histories) Histories {",
            "reason": "Unchanged",
            "start": 28,
            "end": 28
          },
          {
            "oldCode": "\tfilteredHistories := Histories{}",
            "newCode": "\tfilteredHistories := Histories{}",
            "reason": "Unchanged",
            "start": 29,
            "end": 29
          },
          {
            "reason": "Unchanged",
            "start": 30,
            "end": 30
          },
          {
            "oldCode": "\tfor _, history := range histories {",
            "newCode": "\tfor _, history := range histories {",
            "reason": "Unchanged",
            "start": 31,
            "end": 31
          },
          {
            "oldCode": "\t\tif strings.ToUpper(history.AssessingTool) == strings.ToUpper(tool) {",
            "newCode": "\t\tif strings.ToUpper(history.AssessingTool) == strings.ToUpper(tool) {",
            "reason": "Unchanged",
            "start": 32,
            "end": 32
          },
          {
            "oldCode": "\t\t\t//reduce the data load",
            "newCode": "\t\t\t//reduce the data load",
            "reason": "Unchanged",
            "start": 33,
            "end": 33
          },
          {
            "oldCode": "\t\t\thistory.CodeReview = map[string]any{}",
            "newCode": "\t\t\thistory.CodeReview = map[string]any{}",
            "reason": "Unchanged",
            "start": 34,
            "end": 34
          },
          {
            "oldCode": "\t\t\thistory.GradingDetails = map[string]any{}",
            "newCode": "\t\t\thistory.GradingDetails = map[string]any{}",
            "reason": "Unchanged",
            "start": 35,
            "end": 35
          },
          {
            "reason": "Unchanged",
            "start": 36,
            "end": 36
          },
          {
            "oldCode": "\t\t\tfilteredHistories = append(filteredHistories, history)",
            "newCode": "\t\t\tfilteredHistories = append(filteredHistories, history)",
            "reason": "Unchanged",
            "start": 37,
            "end": 37
          },
          {
            "oldCode": "\t\t}",
            "newCode": "\t\t}",
            "reason": "Unchanged",
            "start": 38,
            "end": 38
          },
          {
            "oldCode": "\t}",
            "newCode": "\t}",
            "reason": "Unchanged",
            "start": 39,
            "end": 39
          },
          {
            "reason": "Unchanged",
            "start": 40,
            "end": 40
          },
          {
            "oldCode": "\treturn filteredHistories",
            "newCode": "\treturn filteredHistories",
            "reason": "Unchanged",
            "start": 41,
            "end": 41
          },
          {
            "oldCode": "}",
            "newCode": "}",
            "reason": "Unchanged",
            "start": 42,
            "end": 42
          }
        ]
      }
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 1,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "03ffb9d9e10ee399c45fbd104a5e2a70d9e12b69f5112e2410b29bfc19aa0cbf",
    "id": "eJytlEFvnDAQhf/KyIcKKhba60oc0kRpT82q2aiHOIpcGMCqsZE9JEWr/e8VGNa73SRSpJ6wePO+GfsZdkw4h85JXW+NUWzNbn5e3G5W25vN6vMnlrDClHhpNKEmtmadKH6LGqGSitByzbVsO2MJIq45cebISl07zriOR5WGDuF6Kh7xDqQmtJUoEHajw0vRk1A9Orh/8P4EGunIWIkOvi2rOCy53h/gI9ZTwJHtC9pNWtXrAr7jc5Cj+GSQqb1F6q2GD6FqdAdARPAxaAvgveP6Xv7IsAyv13momaamylh4TGDij7IVukaY200UTl7MYT7qdGtlu7FYyT9+rgQ4A87i16tv++qVajrs9Z85KfXjfxnG41ish23P9vMt5iC6DnUZnUkJvNgsTdMJtj+K58z7VkQnc44t4D+HFGLywCEE1ZzCOMkqHLy56zq00WxKL44/uxjy/KySJmEmccoyi2VfIFCDUAoSoIwoF3XBXpoSf+CTxGfIoRXdvac+CD34K3Zc/NWKUur6CklI5V42zJb3RTs3mK/Ffgn07UhZwiqpcCOoYWuW3Tm0LmtQ20GJ9lfW9opkpzAb/0gKK1oVSmYeND+mLzutDdv/Bexv0XY="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/filterTools.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-04-11T19:49:53.079Z",
    "codeReview": {
      "detailedReview": {
        "tasks": [
          {
            "done": false,
            "titleTask": "inputValidation",
            "violatingCode": "The input validation is insufficient.  The line `value = regexp.MustCompile(`[^a-zA-Z0-9 ]+`).ReplaceAllString(value, \"\")` only removes non-alphanumeric characters and spaces.  It doesn't handle other potential issues like SQL injection or cross-site scripting (XSS).  More robust validation is needed, potentially using parameterized queries or escaping special characters.\n",
            "codeResolution": "The `inputValidation` is currently performed using `strings.TrimSpace` and a regular expression to remove non-alphanumeric characters.  This is insufficient for robust validation.  A more comprehensive approach should be implemented, potentially using a whitelist of allowed characters or a more specific regular expression tailored to the expected input format.  For example, instead of `regexp.MustCompile(`[^a-zA-Z0-9 ]+`).ReplaceAllString(value, \"\")`, consider a more restrictive regex or a function that explicitly checks for allowed characters.  This would prevent unexpected characters from causing issues.  Adding input length checks would also enhance security.\n",
            "severity": "Critical",
            "rationale": "The lack of input validation for `values` in `ToolFilter.Filter` is problematic.  Malicious input could lead to unexpected behavior, such as denial-of-service attacks through excessive computation or unexpected data manipulation via regular expression vulnerabilities.  Robust input validation improves correctness and maintainability by preventing unexpected errors and simplifying debugging.  Improperly sanitized input could also affect the performance of the `regexp.MustCompile` function.\n",
            "lineStart": 21,
            "lineEnd": 25,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "inputSanitization",
            "violatingCode": "The code uses `strings.TrimSpace(value)` to remove leading/trailing whitespace and `regexp.MustCompile(`[^a-zA-Z0-9 ]+`).ReplaceAllString(value, \"\")` to remove non-alphanumeric characters.  This is insufficient sanitization; it doesn't handle special characters that could be used for injection attacks.  A more robust approach is needed, potentially using parameterized queries or escaping special characters specific to the database system.\n",
            "codeResolution": "The current input sanitization is insufficient.  It only removes non-alphanumeric characters and spaces.  A more robust approach is needed to prevent injection attacks.  Consider using a parameterized query or a library specifically designed for input sanitization, depending on the context (database interaction, etc.).  For example, instead of `regexp.MustCompile(`[^a-zA-Z0-9 ]+`).ReplaceAllString(value, \"\")`,  use a library like `github.com/microcosm-cc/bluemonday` for HTML sanitization or escape special characters appropriately for your target system.  This prevents unexpected behavior and security vulnerabilities.\n",
            "severity": "Critical",
            "rationale": "Insufficient input sanitization renders the application vulnerable to injection attacks.  Maliciously crafted input could bypass the `regexp` filter, leading to unexpected behavior, data corruption, or security breaches.  This impacts correctness and maintainability, as future developers might overlook the incomplete sanitization, increasing the risk of vulnerabilities.  Robust sanitization is crucial for reliable and secure operation.\n",
            "lineStart": 21,
            "lineEnd": 25,
            "status": ""
          }
        ],
        "codeReviewTitle": "OWASP-TOP-10 Code Review"
      }
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 1,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 1,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "e8823e744e67ba909ecefc7515822bf836d48c29a4548a84381c33cbd1b1ace6",
    "id": "eJytVF1v00AQ/Cure0AxJHZ5JFIeQlHhBVq1qZCoC13stX3ifHe6W7dNq/x3dD4nbkhVqRJP/pid2fXO+B4Fek/eS12vjFFiLk6/Ly/OZqvTs9n7IzEVhSnp2GgmzWIuLBZ/sCaopGJyuc61bK1xDJNc55wLRzXd21zEJ89O6tqHxyTU8toSnPTU0MyD1EyuwoLgMTAiNLlF1ZGHq+vIn0IjPRsnycOX7V0y3uZ6sxMPslEFPLuu4MceqzpdwDe6G+FJsjdI394Rd07Dm7EqsEeBCcPbEdsKvHbc2CsukMrx9Xwx1vRTc2Uc/JpCrx9gh7omGNr1KjlHcAHDqtOVk+2FxYLiWAlkGZxTa24JFGEpdZ2xQ6mkruGukUw+FEetLIOTznETlodasnxAlkZDF9IBjupOoQO6ty4Exmi/o60a6YHusbWKwPXtPKBeQ9Ggw4LJeeAGGdARaMOAyjaou5acLMA46Kfw6f43xTClXzvPx6a1UtHk5uonzh6Wsx9Hsw9w/e4mSc/JKixoqdRFv4L43VPIRS760AVF3rn2z8Y5jUZ8XAdjt9ydgUmkH5q1ALSWdDk5gKbwbLM0TXuxzZOgHXBfCtvenKEF/Oe4jYGLgusxcs2+WM6yGgNnLq0lNxlI6fLpcZLAYnFQyT0wKIX4OCq7goAbghIZQRkst+hW9tiUdE63ku5gAS3aq6h6jXodf5anxZ9dn/RPxCiVf54wUF5n7dBgiMVma+jLloqpqKSiM+RGzEV26cn5rCHt1grb31nbKZZWURZOWkUVzwolsyg0XPozKq2N2PwFjeghhg=="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/filterTools.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-04-11T19:50:41.722Z",
    "codeReview": {
      "detailedReview": {
        "tasks": [
          {
            "done": false,
            "titleTask": "inputSanitization",
            "violatingCode": "The code snippet `value = strings.TrimPrefix(value, \" \"); value = strings.TrimSuffix(value, \" \");` shows inadequate input sanitization.  While it removes leading and trailing spaces, it doesn't handle other potential issues like SQL injection or cross-site scripting (XSS) vulnerabilities if `value` were used in a database query or web context.  More robust sanitization techniques are needed depending on the context of `value`'s usage.\n",
            "codeResolution": "The current `inputSanitization` is insufficient.  It only trims leading/trailing whitespace.  To improve, use a parameterized query or a library that escapes special characters to prevent SQL injection vulnerabilities.  For example, replace `strings.ToUpper(history.AssessingTool) == strings.ToUpper(tool)` with a parameterized query using your database library.  This prevents injection attacks even if `tool` contains malicious SQL code.\n",
            "severity": "Critical",
            "rationale": "Improper input sanitization can lead to unexpected behavior or vulnerabilities.  In this code, while `strings.TrimPrefix` and `strings.TrimSuffix` handle leading/trailing spaces, it doesn't address other potential issues like SQL injection (though the comment claims it's not used for SQL queries, this should be verified).  Lack of comprehensive sanitization could impact correctness and maintainability, requiring future modifications to address unforeseen problems.  Thorough input validation is crucial for robust and secure code.\n",
            "lineStart": 20,
            "lineEnd": 21,
            "status": ""
          }
        ],
        "codeReviewTitle": "OWASP-TOP-10 Code Review"
      }
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 1,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "0f032ad74d18a38505760575c127b7fb0a0263f785710a4b517c2826b5826fe9",
    "id": "eJytVM9v0zAU/leefEApShO4VsphDAEHxArtxGGekEleEgvXDvbLRjT1f0eOnaal26RJnBLl+/X8viQPTDiHzkndbI1RbMWuvl9s1svt1Xr59g1LWWkqvDSaUBNbsU6Uv0SDUEtFaLnmWu46YwkSrjlx5shK3TjOuF54lIYO4cNI9vYOpCa0tSgRHrwiQMmdUD06uLkN+hRa6chYiQ4+TXeL+Zbr/cHc2wYXcGT7kh5GrO51CV/wfoaTxckgY7xF6q2GVzPLq2eDhOD1jE0GLx03ZIWVYTU/XhUzZ5yaamPhRwqjv4et0A1CjBtdOAWwgLjqbGvlbm2xln/CXClwBpwtnmZv+voJdp5TK10kxzGkA20IeocV+Pk2Xz/D7x7t4IKGDvv552yUhSO/G/wKp7jDqmLk+VoKEF2HukrOoBQeDcuybDTbH1V6pn2u1pM5fQT852LnaoPhMJfbnppxkvVclrnuOrRJFGUXx5/qAorijEkjEJ18nxarvkSgFqESJEAZUU3oZHtpKvyGdxLvoYCd6G6C663QQ3gtj8kfraikbt4jCanc44IoeVm1MSC+Fvup0OcrZSmrpcK1oJatWH7t0Lq8RW0HJXY/812vSHYKc/8XU1jTslQyD0bxMv4Nssaw/V/9reRo"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/read/configReader.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-04-11T19:51:52.411Z",
    "codeReview": {
      "detailedReview": {
        "tasks": [
          {
            "done": false,
            "titleTask": "openClosed",
            "violatingCode": "The `ConfigReader` type is tightly coupled to JSON configuration files.  Adding support for YAML or other formats would require modifying the `ReadConfig` function, violating the Open/Closed Principle.  Specifically, lines like `decoder := json.NewDecoder(file)` and `decoder.Decode(&config)` are hardcoded to JSON processing.\n",
            "codeResolution": "The `ConfigReader` is tightly coupled to JSON.  To improve the Open/Closed Principle, introduce an interface `ConfigSource` with methods `ReadConfig() (*types.Config, error)` and `Close() error`.  `ConfigReader` would implement this interface, and a new `YAMLConfigReader` could be added later without modifying existing code.  The `ReadConfig()` function in `ConfigReader` would then use the appropriate reader based on the file extension.\n",
            "severity": "Medium",
            "rationale": "The `ConfigReader` tightly couples the JSON file format and the file reading logic.  Adding support for a different configuration format (e.g., YAML) would require modifying the `ReadConfig` function, violating the Open/Closed Principle. This reduces maintainability and increases the risk of introducing bugs with each new format.  The solution is to introduce an abstraction for configuration reading, allowing different format handlers to be plugged in without altering the core `ConfigReader`.\n",
            "lineStart": 36,
            "lineEnd": 61,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "dependencyInversion",
            "violatingCode": "The `ConfigReader` directly uses `os.Open`, `os.Stat`, `json.NewDecoder`, and `filepath.Join`.  It should depend on abstractions for file I/O and JSON decoding instead of concrete implementations.  For example, an interface defining file reading and another for JSON decoding would improve dependency inversion.\n",
            "codeResolution": "The `ConfigReader` depends on concrete implementations (`os.Getwd`, `os.Open`, `json.NewDecoder`, `os.Stat`, `filepath.Join`).  To improve dependency inversion, inject these dependencies as interfaces.  For example, create interfaces like `FileSystem` (with methods like `Getwd`, `Open`, `Stat`) and `JSONDecoder` (with a `Decode` method).  `ConfigReader` would then depend on these abstractions, allowing for easier testing and swapping of implementations.\n",
            "severity": "Medium",
            "rationale": "The `ConfigReader` directly uses `os`, `filepath`, and `json` packages.  This tight coupling violates the Dependency Inversion Principle.  If these dependencies change (e.g., a different file system or JSON library), `ConfigReader` needs modification. This reduces maintainability and increases the risk of introducing bugs during updates.  Using interfaces for file I/O and JSON handling would improve flexibility and testability.\n",
            "lineStart": 12,
            "lineEnd": 32,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "interfaceSegregation",
            "violatingCode": "The `ConfigReader` type is responsible for both locating the configuration file and parsing its JSON content.  This violates the Interface Segregation Principle because these are distinct concerns.  The `ReadConfig` method does too much.  A better design would separate file location from JSON decoding into separate interfaces and types.\n",
            "codeResolution": "The `ConfigReader` currently handles file path resolution and JSON decoding.  To improve interface segregation, split `ConfigReader` into two interfaces: one for path resolution (`ConfigPathResolver`) and another for JSON reading (`ConfigJSONReader`).  `ConfigReader` would then implement both.  This separates concerns, allowing for easier testing and potential replacement of individual components.  For example:\n\n```go\ntype ConfigPathResolver interface {\n    ResolveConfigPath() (string, error)\n}\n\ntype ConfigJSONReader interface {\n    ReadConfigFromJSON(path string) (*types.Config, error)\n}\n\ntype ConfigReader struct {\n    RepoRoot     string\n    CodeleftPath string\n}\n\nfunc (cr *ConfigReader) ResolveConfigPath() (string, error) {\n    // ... (path resolution logic) ...\n}\n\nfunc (cr *ConfigReader) ReadConfigFromJSON(path string) (*types.Config, error) {\n    // ... (JSON decoding logic) ...\n}\n```\n",
            "severity": "Medium",
            "rationale": "The `ConfigReader` violates the Interface Segregation Principle (ISP) because it combines file system operations (finding the config file, checking its existence and type, opening it) with JSON decoding.  This coupling makes it harder to reuse parts of the functionality. For example, if you need to read configuration from a different source (e.g., environment variables), you'd have to rewrite the entire `ConfigReader`, even though the JSON decoding logic might be reusable.  This reduces maintainability and increases the risk of introducing bugs when modifying the code.\n",
            "lineStart": 11,
            "lineEnd": 72,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "liskovSubstitution",
            "violatingCode": "The provided code does not demonstrate a Liskov Substitution Principle violation.  The `ConfigReader` struct and its methods operate on a specific file (`config.json`) and its path, without defining an interface that would allow for substitution with alternative readers.  There's no indication of a base class or interface being violated by a subclass.\n",
            "codeResolution": "The Liskov Substitution Principle (LSP) isn't directly violated in this code.  The `ConfigReader` doesn't have any subclasses, so there's no substitution to consider.  The concern might be around error handling.  The numerous `fmt.Errorf` calls create specific error types, which might limit flexibility if different error handling strategies are needed later.  Consider using a more generic error type or an error wrapping mechanism to improve flexibility and adherence to the OCP as well.\n",
            "severity": "Medium",
            "rationale": "The Liskov Substitution Principle (LSP) is not directly applicable here because there are no interfaces or inheritance involved in the `ConfigReader` struct.  The code",
            "lineStart": 12,
            "lineEnd": 72,
            "status": ""
          }
        ],
        "codeReviewTitle": "SOLID Code Review"
      },
      "upgradedCode": {
        "oldCode": "package read\n\nimport (\n\t\"codeleft-cli/types\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\n// ConfigReader is responsible for reading the config.json file.\ntype ConfigReader struct {\n\tRepoRoot     string\n\tCodeleftPath string\n}\n\nfunc NewConfigReader() (*ConfigReader, error) {\n\trepoRoot, err := os.Getwd()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get current working directory: %w\", err)\n\t}\n\n\t// Recursively find .codeleft\n\tcodeleftPath, err := findCodeleftRecursive(repoRoot)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcr := &ConfigReader{\n\t\tRepoRoot:     repoRoot,\n\t\tCodeleftPath: codeleftPath,\n\t}\n\treturn cr, nil\n}\n\nfunc (cr *ConfigReader) ReadConfig() (*types.Config, error) {\n\t// Ensure the .codeleft path is set\n\tif cr.CodeleftPath == \"\" {\n\t\treturn nil, fmt.Errorf(\".codeLeft folder not found in the repository root: %s\", cr.RepoRoot)\n\t}\n\n\tconfigPath := filepath.Join(cr.CodeleftPath, \"config.json\")\n\n\t// Check if config.json exists\n\tinfo, err := os.Stat(configPath)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn nil, fmt.Errorf(\"config.json does not exist at path: %s\", configPath)\n\t\t}\n\t\treturn nil, fmt.Errorf(\"error accessing config.json: %w\", err)\n\t}\n\n\tif info.IsDir() {\n\t\treturn nil, fmt.Errorf(\"config.json exists but is a directory: %s\", configPath)\n\t}\n\n\t// Open the config.json file\n\tfile, err := os.Open(configPath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to open config.json: %w\", err)\n\t}\n\tdefer file.Close()\n\n\t// Decode the JSON into a Config struct\n\tvar config types.Config\n\tdecoder := json.NewDecoder(file)\n\tif err := decoder.Decode(&config); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to decode config.json: %w\", err)\n\t}\n\n\treturn &config, nil\n}\n",
        "newCode": "package read\n\nimport (\n\t\"codeleft-cli/types\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\n// FileSystem abstracts file system operations.\ntype FileSystem interface {\n\tGetwd() (string, error)\n\tOpen(name string) (*os.File, error)\n\tStat(name string) (os.FileInfo, error)\n\tJoin(elem ...string) string\n}\n\n// OSFileSystem implements the FileSystem interface using the os package.\ntype OSFileSystem struct{}\n\nfunc (o *OSFileSystem) Getwd() (string, error) {\n\treturn os.Getwd()\n}\n\nfunc (o *OSFileSystem) Open(name string) (*os.File, error) {\n\treturn os.Open(name)\n}\n\nfunc (o *OSFileSystem) Stat(name string) (os.FileInfo, error) {\n\treturn os.Stat(name)\n}\n\nfunc (o *OSFileSystem) Join(elem ...string) string {\n\treturn filepath.Join(elem...)\n}\n\n// JSONDecoder abstracts JSON decoding.\ntype JSONDecoder interface {\n\tDecode(v interface{}) error\n}\n\n// ConfigSource interface for reading configuration.\ntype ConfigSource interface {\n\tReadConfig() (*types.Config, error)\n}\n\n// ConfigPathResolver resolves the path to the config file.\ntype ConfigPathResolver interface {\n\tResolveConfigPath() (string, error)\n}\n\n// ConfigJSONReader reads the config from a JSON file.\ntype ConfigJSONReader interface {\n\tReadConfigFromJSON(path string) (*types.Config, error)\n}\n\n// ConfigReader is responsible for reading the config.json file.\ntype ConfigReader struct {\n\tRepoRoot     string\n\tCodeleftPath string\n\tFileSystem   FileSystem\n\t//\tJSONDecoder  JSONDecoder // Removed direct dependency on JSONDecoder\n}\n\n// NewConfigReader creates a new ConfigReader.\nfunc NewConfigReader(fs FileSystem) (*ConfigReader, error) {\n\tif fs == nil {\n\t\tfs = &OSFileSystem{} // Use OSFileSystem as default\n\t}\n\trepoRoot, err := fs.Getwd()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get current working directory: %w\", err)\n\t}\n\n\t// Recursively find .codeleft\n\tcodeleftPath, err := findCodeleftRecursive(repoRoot, fs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcr := &ConfigReader{\n\t\tRepoRoot:     repoRoot,\n\t\tCodeleftPath: codeleftPath,\n\t\tFileSystem:   fs,\n\t}\n\treturn cr, nil\n}\n\n// ResolveConfigPath resolves the path to the config.json file.\nfunc (cr *ConfigReader) ResolveConfigPath() (string, error) {\n\tif cr.CodeleftPath == \"\" {\n\t\treturn \"\", fmt.Errorf(\".codeLeft folder not found in the repository root: %s\", cr.RepoRoot)\n\t}\n\treturn filepath.Join(cr.CodeleftPath, \"config.json\"), nil\n}\n\n// ReadConfig reads the configuration from config.json.\nfunc (cr *ConfigReader) ReadConfig() (*types.Config, error) {\n\tconfigPath, err := cr.ResolveConfigPath()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check if config.json exists\n\tinfo, err := cr.FileSystem.Stat(configPath)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn nil, fmt.Errorf(\"config.json does not exist at path: %s\", configPath)\n\t\t}\n\t\treturn nil, fmt.Errorf(\"error accessing config.json: %w\", err)\n\t}\n\n\tif info.IsDir() {\n\t\treturn nil, fmt.Errorf(\"config.json exists but is a directory: %s\", configPath)\n\t}\n\n\t// Open the config.json file\n\tfile, err := cr.FileSystem.Open(configPath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to open config.json: %w\", err)\n\t}\n\tdefer file.Close()\n\n\t// Decode the JSON into a Config struct\n\tvar config types.Config\n\tdecoder := json.NewDecoder(file)\n\tif err := decoder.Decode(&config); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to decode config.json: %w\", err)\n\t}\n\n\treturn &config, nil\n}\n\n// findCodeleftRecursive recursively searches for the .codeleft directory.\nfunc findCodeleftRecursive(startDir string, fs FileSystem) (string, error) {\n\tcurrentDir := startDir\n\tfor {\n\t\tcodeleftPath := fs.Join(currentDir, \".codeleft\")\n\t\tif _, err := fs.Stat(codeleftPath); err == nil {\n\t\t\treturn currentDir, nil\n\t\t}\n\n\t\tparentDir := fs.Join(currentDir, \"..\")\n\t\tif parentDir == currentDir {\n\t\t\t// Reached the root directory\n\t\t\treturn \"\", fmt.Errorf(\".codeleft directory not found\")\n\t\t}\n\t\tcurrentDir = parentDir\n\t}\n}",
        "changes": [
          {
            "oldCode": "package read",
            "newCode": "package read",
            "reason": "Unchanged",
            "start": 1,
            "end": 1
          },
          {
            "reason": "Unchanged",
            "start": 2,
            "end": 2
          },
          {
            "oldCode": "import (",
            "newCode": "import (",
            "reason": "Unchanged",
            "start": 3,
            "end": 3
          },
          {
            "oldCode": "\t\"codeleft-cli/types\"",
            "newCode": "\t\"codeleft-cli/types\"",
            "reason": "Unchanged",
            "start": 4,
            "end": 4
          },
          {
            "oldCode": "\t\"encoding/json\"",
            "newCode": "\t\"encoding/json\"",
            "reason": "Unchanged",
            "start": 5,
            "end": 5
          },
          {
            "oldCode": "\t\"fmt\"",
            "newCode": "\t\"fmt\"",
            "reason": "Unchanged",
            "start": 6,
            "end": 6
          },
          {
            "oldCode": "\t\"os\"",
            "newCode": "\t\"os\"",
            "reason": "Unchanged",
            "start": 7,
            "end": 7
          },
          {
            "oldCode": "\t\"path/filepath\"",
            "newCode": "\t\"path/filepath\"",
            "reason": "Unchanged",
            "start": 8,
            "end": 8
          },
          {
            "oldCode": ")",
            "newCode": ")",
            "reason": "Unchanged",
            "start": 9,
            "end": 9
          },
          {
            "newCode": "\n// FileSystem abstracts file system operations.\ntype FileSystem interface {\n\tGetwd() (string, error)\n\tOpen(name string) (*os.File, error)\n\tStat(name string) (os.FileInfo, error)\n\tJoin(elem ...string) string\n}\n\n// OSFileSystem implements the FileSystem interface using the os package.\ntype OSFileSystem struct{}\n\nfunc (o *OSFileSystem) Getwd() (string, error) {\n\treturn os.Getwd()\n}\n\nfunc (o *OSFileSystem) Open(name string) (*os.File, error) {\n\treturn os.Open(name)\n}\n\nfunc (o *OSFileSystem) Stat(name string) (os.FileInfo, error) {\n\treturn os.Stat(name)\n}\n\nfunc (o *OSFileSystem) Join(elem ...string) string {\n\treturn filepath.Join(elem...)\n}\n\n// JSONDecoder abstracts JSON decoding.\ntype JSONDecoder interface {\n\tDecode(v interface{}) error\n}\n\n// ConfigSource interface for reading configuration.\ntype ConfigSource interface {\n\tReadConfig() (*types.Config, error)\n}\n\n// ConfigPathResolver resolves the path to the config file.\ntype ConfigPathResolver interface {\n\tResolveConfigPath() (string, error)\n}\n\n// ConfigJSONReader reads the config from a JSON file.\ntype ConfigJSONReader interface {\n\tReadConfigFromJSON(path string) (*types.Config, error)\n}\n",
            "reason": "Modified",
            "start": 10,
            "end": 10,
            "reasonDiff": "Interfaces for file system operations, JSON decoding, config sources, path resolution, and JSON reading were introduced to improve dependency inversion, adhere to the Open/Closed and Interface Segregation Principles, and improve testability.\n"
          },
          {
            "oldCode": "// ConfigReader is responsible for reading the config.json file.",
            "newCode": "// ConfigReader is responsible for reading the config.json file.",
            "reason": "Unchanged",
            "start": 11,
            "end": 11
          },
          {
            "oldCode": "type ConfigReader struct {",
            "newCode": "type ConfigReader struct {",
            "reason": "Unchanged",
            "start": 12,
            "end": 12
          },
          {
            "oldCode": "\tRepoRoot     string",
            "newCode": "\tRepoRoot     string",
            "reason": "Unchanged",
            "start": 13,
            "end": 13
          },
          {
            "oldCode": "\tCodeleftPath string",
            "newCode": "\tCodeleftPath string",
            "reason": "Unchanged",
            "start": 14,
            "end": 14
          },
          {
            "newCode": "\tFileSystem   FileSystem\n\t//\tJSONDecoder  JSONDecoder // Removed direct dependency on JSONDecoder",
            "reason": "Added",
            "start": 15,
            "end": 15,
            "reasonDiff": "To address dependency inversion principle violations, the `FileSystem` field was added to the `ConfigReader` struct, allowing for the injection of file system operations, promoting testability and flexibility.\n"
          },
          {
            "oldCode": "}",
            "newCode": "}",
            "reason": "Unchanged",
            "start": 15,
            "end": 15
          },
          {
            "reason": "Unchanged",
            "start": 16,
            "end": 16
          },
          {
            "oldCode": "func NewConfigReader() (*ConfigReader, error) {\n\trepoRoot, err := os.Getwd()",
            "newCode": "// NewConfigReader creates a new ConfigReader.\nfunc NewConfigReader(fs FileSystem) (*ConfigReader, error) {\n\tif fs == nil {\n\t\tfs = &OSFileSystem{} // Use OSFileSystem as default\n\t}\n\trepoRoot, err := fs.Getwd()",
            "reason": "Modified",
            "start": 17,
            "end": 18,
            "reasonDiff": "To address dependency inversion principle violations, the `NewConfigReader` now accepts a `FileSystem` interface, allowing for dependency injection and testability with mock file systems.  If no file system is provided, it defaults to `OSFileSystem`.\n"
          },
          {
            "oldCode": "\tif err != nil {",
            "newCode": "\tif err != nil {",
            "reason": "Unchanged",
            "start": 19,
            "end": 19
          },
          {
            "oldCode": "\t\treturn nil, fmt.Errorf(\"failed to get current working directory: %w\", err)",
            "newCode": "\t\treturn nil, fmt.Errorf(\"failed to get current working directory: %w\", err)",
            "reason": "Unchanged",
            "start": 20,
            "end": 20
          },
          {
            "oldCode": "\t}",
            "newCode": "\t}",
            "reason": "Unchanged",
            "start": 21,
            "end": 21
          },
          {
            "reason": "Unchanged",
            "start": 22,
            "end": 22
          },
          {
            "oldCode": "\t// Recursively find .codeleft",
            "newCode": "\t// Recursively find .codeleft",
            "reason": "Unchanged",
            "start": 23,
            "end": 23
          },
          {
            "oldCode": "\tcodeleftPath, err := findCodeleftRecursive(repoRoot)",
            "newCode": "\tcodeleftPath, err := findCodeleftRecursive(repoRoot, fs)",
            "reason": "Modified",
            "start": 24,
            "end": 24,
            "reasonDiff": "To adhere to the dependency inversion principle, the `findCodeleftRecursive` function now accepts a `FileSystem` interface as a parameter, allowing for the injection of different file system implementations.\n"
          },
          {
            "oldCode": "\tif err != nil {",
            "newCode": "\tif err != nil {",
            "reason": "Unchanged",
            "start": 25,
            "end": 25
          },
          {
            "oldCode": "\t\treturn nil, err",
            "newCode": "\t\treturn nil, err",
            "reason": "Unchanged",
            "start": 26,
            "end": 26
          },
          {
            "oldCode": "\t}",
            "newCode": "\t}",
            "reason": "Unchanged",
            "start": 27,
            "end": 27
          },
          {
            "reason": "Unchanged",
            "start": 28,
            "end": 28
          },
          {
            "oldCode": "\tcr := &ConfigReader{",
            "newCode": "\tcr := &ConfigReader{",
            "reason": "Unchanged",
            "start": 29,
            "end": 29
          },
          {
            "oldCode": "\t\tRepoRoot:     repoRoot,",
            "newCode": "\t\tRepoRoot:     repoRoot,",
            "reason": "Unchanged",
            "start": 30,
            "end": 30
          },
          {
            "oldCode": "\t\tCodeleftPath: codeleftPath,",
            "newCode": "\t\tCodeleftPath: codeleftPath,",
            "reason": "Unchanged",
            "start": 31,
            "end": 31
          },
          {
            "newCode": "\t\tFileSystem:   fs,",
            "reason": "Added",
            "start": 32,
            "end": 32,
            "reasonDiff": "To address dependency inversion principle violation, a FileSystem field was added to the ConfigReader struct and initialized in the NewConfigReader function. This allows injecting a mock file system for testing.\n"
          },
          {
            "oldCode": "\t}",
            "newCode": "\t}",
            "reason": "Unchanged",
            "start": 32,
            "end": 32
          },
          {
            "oldCode": "\treturn cr, nil",
            "newCode": "\treturn cr, nil",
            "reason": "Unchanged",
            "start": 33,
            "end": 33
          },
          {
            "oldCode": "}",
            "newCode": "}",
            "reason": "Unchanged",
            "start": 34,
            "end": 34
          },
          {
            "reason": "Unchanged",
            "start": 35,
            "end": 35
          },
          {
            "oldCode": "func (cr *ConfigReader) ReadConfig() (*types.Config, error) {\n\t// Ensure the .codeleft path is set",
            "newCode": "// ResolveConfigPath resolves the path to the config.json file.\nfunc (cr *ConfigReader) ResolveConfigPath() (string, error) {",
            "reason": "Modified",
            "start": 36,
            "end": 37,
            "reasonDiff": "To adhere to the Interface Segregation Principle, the `ReadConfig` function was split into `ResolveConfigPath` to handle path resolution logic separately. This improves code modularity and allows independent testing and reuse of path resolution.\n"
          },
          {
            "oldCode": "\tif cr.CodeleftPath == \"\" {",
            "newCode": "\tif cr.CodeleftPath == \"\" {",
            "reason": "Unchanged",
            "start": 38,
            "end": 38
          },
          {
            "oldCode": "\t\treturn nil, fmt.Errorf(\".codeLeft folder not found in the repository root: %s\", cr.RepoRoot)\n\t}\n\n\tconfigPath := filepath.Join(cr.CodeleftPath, \"config.json\")\n",
            "newCode": "\t\treturn \"\", fmt.Errorf(\".codeLeft folder not found in the repository root: %s\", cr.RepoRoot)\n\t}\n\treturn filepath.Join(cr.CodeleftPath, \"config.json\"), nil\n}\n\n// ReadConfig reads the configuration from config.json.\nfunc (cr *ConfigReader) ReadConfig() (*types.Config, error) {\n\tconfigPath, err := cr.ResolveConfigPath()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n",
            "reason": "Modified",
            "start": 39,
            "end": 43,
            "reasonDiff": "The `ResolveConfigPath` function was created to separate the logic of resolving the configuration file path from the `ReadConfig` function. This addresses the Interface Segregation Principle violation by separating the concerns of path resolution and config file reading.\n"
          },
          {
            "oldCode": "\t// Check if config.json exists",
            "newCode": "\t// Check if config.json exists",
            "reason": "Unchanged",
            "start": 44,
            "end": 44
          },
          {
            "oldCode": "\tinfo, err := os.Stat(configPath)",
            "newCode": "\tinfo, err := cr.FileSystem.Stat(configPath)",
            "reason": "Modified",
            "start": 45,
            "end": 45,
            "reasonDiff": "To adhere to the dependency inversion principle, the `ConfigReader` now uses the injected `FileSystem` interface for file system operations, allowing for easier testing and the ability to swap implementations.\n"
          },
          {
            "oldCode": "\tif err != nil {",
            "newCode": "\tif err != nil {",
            "reason": "Unchanged",
            "start": 46,
            "end": 46
          },
          {
            "oldCode": "\t\tif os.IsNotExist(err) {",
            "newCode": "\t\tif os.IsNotExist(err) {",
            "reason": "Unchanged",
            "start": 47,
            "end": 47
          },
          {
            "oldCode": "\t\t\treturn nil, fmt.Errorf(\"config.json does not exist at path: %s\", configPath)",
            "newCode": "\t\t\treturn nil, fmt.Errorf(\"config.json does not exist at path: %s\", configPath)",
            "reason": "Unchanged",
            "start": 48,
            "end": 48
          },
          {
            "oldCode": "\t\t}",
            "newCode": "\t\t}",
            "reason": "Unchanged",
            "start": 49,
            "end": 49
          },
          {
            "oldCode": "\t\treturn nil, fmt.Errorf(\"error accessing config.json: %w\", err)",
            "newCode": "\t\treturn nil, fmt.Errorf(\"error accessing config.json: %w\", err)",
            "reason": "Unchanged",
            "start": 50,
            "end": 50
          },
          {
            "oldCode": "\t}",
            "newCode": "\t}",
            "reason": "Unchanged",
            "start": 51,
            "end": 51
          },
          {
            "reason": "Unchanged",
            "start": 52,
            "end": 52
          },
          {
            "oldCode": "\tif info.IsDir() {",
            "newCode": "\tif info.IsDir() {",
            "reason": "Unchanged",
            "start": 53,
            "end": 53
          },
          {
            "oldCode": "\t\treturn nil, fmt.Errorf(\"config.json exists but is a directory: %s\", configPath)",
            "newCode": "\t\treturn nil, fmt.Errorf(\"config.json exists but is a directory: %s\", configPath)",
            "reason": "Unchanged",
            "start": 54,
            "end": 54
          },
          {
            "oldCode": "\t}",
            "newCode": "\t}",
            "reason": "Unchanged",
            "start": 55,
            "end": 55
          },
          {
            "reason": "Unchanged",
            "start": 56,
            "end": 56
          },
          {
            "oldCode": "\t// Open the config.json file",
            "newCode": "\t// Open the config.json file",
            "reason": "Unchanged",
            "start": 57,
            "end": 57
          },
          {
            "oldCode": "\tfile, err := os.Open(configPath)",
            "newCode": "\tfile, err := cr.FileSystem.Open(configPath)",
            "reason": "Modified",
            "start": 58,
            "end": 58,
            "reasonDiff": "To adhere to the dependency inversion principle, the `ConfigReader` now uses the injected `FileSystem` interface for file operations, promoting loose coupling and testability.\n"
          },
          {
            "oldCode": "\tif err != nil {",
            "newCode": "\tif err != nil {",
            "reason": "Unchanged",
            "start": 59,
            "end": 59
          },
          {
            "oldCode": "\t\treturn nil, fmt.Errorf(\"failed to open config.json: %w\", err)",
            "newCode": "\t\treturn nil, fmt.Errorf(\"failed to open config.json: %w\", err)",
            "reason": "Unchanged",
            "start": 60,
            "end": 60
          },
          {
            "oldCode": "\t}",
            "newCode": "\t}",
            "reason": "Unchanged",
            "start": 61,
            "end": 61
          },
          {
            "oldCode": "\tdefer file.Close()",
            "newCode": "\tdefer file.Close()",
            "reason": "Unchanged",
            "start": 62,
            "end": 62
          },
          {
            "reason": "Unchanged",
            "start": 63,
            "end": 63
          },
          {
            "oldCode": "\t// Decode the JSON into a Config struct",
            "newCode": "\t// Decode the JSON into a Config struct",
            "reason": "Unchanged",
            "start": 64,
            "end": 64
          },
          {
            "oldCode": "\tvar config types.Config",
            "newCode": "\tvar config types.Config",
            "reason": "Unchanged",
            "start": 65,
            "end": 65
          },
          {
            "oldCode": "\tdecoder := json.NewDecoder(file)",
            "newCode": "\tdecoder := json.NewDecoder(file)",
            "reason": "Unchanged",
            "start": 66,
            "end": 66
          },
          {
            "oldCode": "\tif err := decoder.Decode(&config); err != nil {",
            "newCode": "\tif err := decoder.Decode(&config); err != nil {",
            "reason": "Unchanged",
            "start": 67,
            "end": 67
          },
          {
            "oldCode": "\t\treturn nil, fmt.Errorf(\"failed to decode config.json: %w\", err)",
            "newCode": "\t\treturn nil, fmt.Errorf(\"failed to decode config.json: %w\", err)",
            "reason": "Unchanged",
            "start": 68,
            "end": 68
          },
          {
            "oldCode": "\t}",
            "newCode": "\t}",
            "reason": "Unchanged",
            "start": 69,
            "end": 69
          },
          {
            "reason": "Unchanged",
            "start": 70,
            "end": 70
          },
          {
            "oldCode": "\treturn &config, nil",
            "newCode": "\treturn &config, nil",
            "reason": "Unchanged",
            "start": 71,
            "end": 71
          },
          {
            "oldCode": "}\n",
            "newCode": "}\n\n// findCodeleftRecursive recursively searches for the .codeleft directory.\nfunc findCodeleftRecursive(startDir string, fs FileSystem) (string, error) {\n\tcurrentDir := startDir\n\tfor {\n\t\tcodeleftPath := fs.Join(currentDir, \".codeleft\")\n\t\tif _, err := fs.Stat(codeleftPath); err == nil {\n\t\t\treturn currentDir, nil\n\t\t}\n\n\t\tparentDir := fs.Join(currentDir, \"..\")\n\t\tif parentDir == currentDir {\n\t\t\t// Reached the root directory\n\t\t\treturn \"\", fmt.Errorf(\".codeleft directory not found\")\n\t\t}\n\t\tcurrentDir = parentDir\n\t}\n}",
            "reason": "Modified",
            "start": 72,
            "end": 73,
            "reasonDiff": "To address the dependency inversion principle violation, the `findCodeleftRecursive` function was updated to receive a `FileSystem` interface, allowing it to use different file system implementations.\n"
          }
        ]
      }
    },
    "gradingDetails": {
      "dependencyInversionScore": "B",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "B",
      "openClosedScore": "B",
      "singleResponsibilityScore": "A"
    },
    "hash": "56d65f4099339e570713a365a6225a57b1ece411b6dda73597e4bb517c90c2dc",
    "id": "eJydVU1v2zAM/SucgBbOkNl3DzmlxdCiSId0u/niypSj1ZEMiW5WFP3vA+WPyFs/gvlig6IeH/lI+lmU3qP32tQ/rG1ELu5ub64uxFJIW+HaGkJDIhdtKR/KGsFhWRWmMHrfWkeQFKagIvg2qOiLbHRGTy36QvQnaKSttKmzX96a0aj2NH7aybMtaZcp3SB/sHHBcbIM1tYoXW+xrNCB9uDQt9Z4fd8gKOsCJW1qoB2CDL4pBwPGSgvDdOYYnlwnCZ457hZbu7WWgB9PTpuazeshoe8l7SbzCxNSnZGwwUOMmCwg+RwbloDOWbfoY7ghRrBCvgLr029IhyrhFEmrYP+0AqOb/gbfoc4ZtixB7Sm9ZDyVFEKVusEKyEKNBLJzDg3BwboHrkGlHUqy7imHs0MhQsQQJHAvKMtgi7JzXj9i8wRKmwrSUT12kFHiE192GysyXU/GtE5LAp2LeMiAex7XbLgzCpIHRabS9YexLDnMuI7gY1Dplhw4Vi2RDmYyLYDfvSVoGFo37Q1zDbMMLo3vHIY2m0oG3KzclB5pKIN06ax7VisoRCE+FDZg3jCmsg23qbH82ZkKtAlRuRhes7rgQoXOPEssXbqNpRhLHLIIFIKE/WCl11ab5C+OS+ARnianEIupW9Y7lA/AaUWThb+1Jx/yNcrGbX1HJSXHyG+3hlbsfuU3li4ZLeFGHQ/fqVJMo7LoQ5UCHyh7NaayzFkM3fEOdJAbSin7dRhn/MY0aQVcgPTKX2heAh9J/G8N4b4jbp9yNrmv8T8O8G2L5tVlx+f8jgVh55MEOWHhWA78QVWoQoWu373rxnpMjr10gdzigfr13e0GtCEL5bCbh63Mro+lG8JAPJA9OkOE5JhBusFDj+oSDhmnl69g8E57l+S8B118/b/0e7QT2mLAGsId15BYCibJOohcZD89Op/t0LinptzfZ/uuId02mM3+pvx3y2S0tNLaipc/lerCIw=="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/read/configReader.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-04-11T19:53:15.286Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "dependencyInversionScore": "A*",
      "interfaceSegregationScore": "A*",
      "liskovSubstitutionScore": "A*",
      "openClosedScore": "A*",
      "singleResponsibilityScore": "A"
    },
    "hash": "a403637fb68b5bba3b1c63d95ed9720fb3d726d7284a01d415f068d2568d6bb1",
    "id": "eJydV01v4zgM/StcA1PYRda+Z5FTO7PoYNAOkp2bL6pMJdrakiHJyQZF/vuCkh3LSdME00sNiiIfH7+U94RZi9ZKtf5H6zqZJ6uXH0+PySzhusIHrRwql8yTlvE3tkYwyKpSlUo2rTYO0lKVrvS6NQr3J69l4fYt2jIJJ6i4rqRaF/9arQahaNzwqY+aLXObQsga6YOEGfkpCvgma1ztrcMG2Kt1hnFngRTBBqlu0TAntbJ5qch7fEUqh0YwjvBOfv5Gt6vSDFLrjFTrGaAx2pAr99KiShVrEMJZBum9tjnZitVWjrkTtV7rSQkda37XUqVYYwN5ng/K4X+pDn10L6sYbNPW2KByFtzmQhgd5cofawt9Woa4J8asMx13796R6BSHVMN9rJHBBTYCVQZdZxRom/dqPegLtm6g79Tu8coV07dRfmr9eOuK9U/SNDE51GZ+vJDneTZm8vvq5fkRqRVMVKgkhQpDFwx5ilVPCjSI0+0ofz9kIcLR1YNWQq5XujMcIwNCG9+ghJx7lS40xuD3wj3veImsCudUEPe+i/MgGIt6CuAnc5slWl1vkRz7j1C5xBM47b8DEk/fFMfk+hkaLx8VP+rZKRoilYLAQIKdODe6ARaScQ4kunmRlG9GN6SX+tDGEr+Fp8G2JZJarax8rafZGqHmNCg/wNjbCE09gGv1UmsH9DfMldI99MP45wiUxNFkgGiy0FFRlC4uyUl9FgUssdFbrKCSBrmDCltUFSq+B61i3THuZ9xNYHODzKEFBgp3k4jyvi9PbqTCQtyk6X18Om15KUBYWCxAyTpISkcCuIsb/f1AofyyJ1OSWahQsK52dPEQ+j3w6r3AfAEiGoHeHcn/mPjrZ4SS9QxE4/KvhE+kZSKYrLGiXlijA94Zg8rBTps3yntgVJv9HL7sysR7zAYgPjOwRN4ZK7dY70FIVUE+bFtS4FGyR7xSVUMVHK+nQ1i3BYHGRDi4t3sX56C/MxTh3FfhkbpwGJfiHCZYg8KYCLov7CxKgsfCzYzwjJV1NhiuDZ5JQ4UVwA1Myik7t3ppKUoB3OSTFlssoEzK5IREEp2Ugk/cDxQOhK6pK5Smz05VIJVHTPRZSfUAxnP6xZIVbvJlnLzDxa10gm0G9DY7slAm2Rmbw3w7m5n96gijMzLyKYtXV0hgiR95Ptasj/EsCb9RqjR1N8jfgFIVVQD+J62z3uDwaOj9jkUY3gwjusv+paAnxpN91u4rGU6pcYfDT8ZBjKjSaH0NeGjAnK/eY9KnKPqsf2LaEwyM8/Ccj4O/MF2kAOIif7KP0qTZ1Vl2Tie8do72GptMso/wj9mhV9+H/UnnYngunufGvxZvyc0Ns1gThisEuQoFmjA5Hmpt0ZdjiCEsPB+Ff1NI5TSwfrH1S5pUt8wMT5C4G4L1sF/nC/Bt9Yy7fo2m5DIOb76AXjvvn4d3wWj21++FH6zdUCG9rd7dMDySWUIQKQvJPCl+WTS22KAy+5o1r0XT1U62NRaTn4U0Xwoeb/61Tg7/A6n0M1Y="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/builder.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-04-11T19:53:55.709Z",
    "codeReview": {
      "detailedReview": {
        "tasks": [
          {
            "done": false,
            "titleTask": "liskovSubstitution",
            "violatingCode": "The provided code does not demonstrate a Liskov Substitution Principle violation.  The code uses composition and interfaces effectively, allowing for substitution of different implementations without altering the core functionality. There is no evidence of a violation in the given `TreeBuilder` and `ReportNode` structures.\n",
            "codeResolution": "The Liskov Substitution Principle (LSP) is not directly violated in this code.  The `ReportNode` struct is used consistently throughout the `TreeBuilder`, and there are no subclasses that would break substitutability.  However, the code could be improved for better extensibility.  Consider creating an interface for `ReportNode` if you anticipate needing different types of nodes in the future (e.g., nodes with different data or behavior).  This would allow for easy substitution without modifying the `TreeBuilder`.\n",
            "severity": "Medium",
            "rationale": "The provided code snippet does not directly demonstrate a Liskov Substitution Principle (LSP) violation.  The `TreeBuilder` struct has no inheritance or polymorphism involved.  Therefore, there's no opportunity for substitution to cause issues with maintainability, performance, or correctness in this specific context.  LSP concerns arise when substituting subtypes breaks the expected behavior of the base type, which isn't applicable here.\n",
            "lineStart": 17,
            "lineEnd": 109,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "dependencyInversion",
            "violatingCode": "The `TreeBuilder` type directly uses `filepath.ToSlash`, `strings.Split`, and `sort.Strings` without abstraction.  Dependency Inversion suggests depending on abstractions, not concrete implementations.  The code should use interfaces for path manipulation and sorting to allow for easier substitution of different implementations.\n",
            "codeResolution": "The `TreeBuilder` currently depends on the concrete `filter.GradeDetails` type.  To improve dependency inversion, introduce an interface, e.g., `GradeDetailer`, defining methods needed by `TreeBuilder`.  `filter.GradeDetails` would then implement this interface.  `TreeBuilder` would depend on the interface, allowing for flexible substitution of different detail implementations.  For example:\n\n```go\ntype GradeDetailer interface {\n    GetFileName() string\n    // ... other methods as needed\n}\n\nfunc (tb *TreeBuilder) BuildReportTree(groupedDetails map[string][]GradeDetailer) []*ReportNode {\n    // ... implementation using GradeDetailer interface methods ...\n}\n```\n",
            "severity": "Medium",
            "rationale": "The `TreeBuilder` depends on the concrete `filter.GradeDetails` type.  This violates the Dependency Inversion Principle because high-level modules (like `TreeBuilder`) should depend on abstractions, not concretions.  If the `filter` package changes its implementation, `TreeBuilder` might need modification, reducing maintainability.  While not directly impacting performance or correctness in this specific example, tighter coupling increases the risk of cascading changes and makes refactoring more difficult.\n",
            "lineStart": 4,
            "lineEnd": 108,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "interfaceSegregation",
            "violatingCode": "The `ReportNode` struct includes fields `ToolCoverages` and `ToolCoverageOk`, which are likely related to code coverage.  However, the `TreeBuilder`'s `BuildReportTree` function populates these fields with empty maps.  This suggests a violation of the Interface Segregation Principle because the `ReportNode` interface includes functionality (coverage data) that isn't always used.  A separate interface for nodes with coverage data would improve the design.\n",
            "codeResolution": "The `TreeBuilder` currently handles both building the report tree and grouping grade details.  To improve interface segregation, separate these concerns. Create a `GradeGrouper` interface:\n\n```go\ntype GradeGrouper interface {\n    GroupByPath([]filter.GradeDetails) map[string][]filter.GradeDetails\n}\n```\n\nImplement this interface with a `PathGrouper` struct.  Modify `TreeBuilder` to depend on `GradeGrouper`, injecting it via constructor.  This isolates path grouping logic, allowing for easier testing and potential alternative grouping strategies.\n",
            "severity": "Medium",
            "rationale": "The `TreeBuilder`'s `BuildReportTree` method has multiple responsibilities:  it parses paths, creates nodes, and manages parent-child relationships.  This violates the Interface Segregation Principle (ISP).  Separating these concerns into distinct methods or even separate classes would improve maintainability and reduce the complexity of testing and debugging.  A large, multifaceted method is harder to understand, modify, and test correctly than smaller, focused methods.\n",
            "lineStart": 11,
            "lineEnd": 76,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "openClosed",
            "violatingCode": "The `BuildReportTree` function processes file paths to construct a tree.  Adding a new way to organize or represent the report (e.g., by different criteria than file paths) would require modifying this function, violating the Open/Closed Principle.  The function directly manipulates the structure based on path splitting (`strings.Split(fullPath, \"/\")`), making it inflexible to alternative report structures.\n",
            "codeResolution": "The `BuildReportTree` function's Open/Closed Principle adherence can be improved.  Currently, adding a new type of coverage data (e.g.,  `ToolCoverage`) requires modifying the `ReportNode` struct and potentially the `BuildReportTree` function itself.\n\nTo improve this, introduce an interface for coverage data:\n\n```go\ntype CoverageData interface {\n    GetCoverage(tool string) (float64, bool) // Or a more specific method signature\n    SetCoverage(tool string, coverage float64, ok bool)\n}\n```\n\nModify `ReportNode` to use this interface:\n\n```go\ntype ReportNode struct {\n    // ... other fields\n    CoverageData CoverageData\n}\n```\n\nImplementations for different coverage types can then be created without changing `ReportNode` or `BuildReportTree`.  This enhances the OCP.\n",
            "severity": "Medium",
            "rationale": "The `TreeBuilder`'s `BuildReportTree` function directly manipulates the `ReportNode` structure.  Adding a new way to organize or represent report data (e.g., a different tree structure or a flat list) would require modifying this function.  This violates the Open/Closed Principle because the function is not open for extension without modification.  This impacts maintainability, as changes to data representation necessitate code changes in this core function, increasing the risk of introducing bugs.\n",
            "lineStart": 27,
            "lineEnd": 112,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "singleResponsibility",
            "violatingCode": "The `BuildReportTree` function violates the Single Responsibility Principle.  It's responsible for both constructing the tree structure from file paths and potentially sorting those paths (`sort.Strings(paths)`).  These are distinct concerns that should be separated into different functions or classes.\n",
            "codeResolution": "The `TreeBuilder` violates the Single Responsibility Principle (SRP) because it's responsible for both grouping grade details by path and building the report tree.  These are distinct operations.\n\n**Refactoring:** Separate the grouping logic into a dedicated function or type.\n\n```go\n// GroupGradeDetailsByPath groups grade details by file path.\nfunc GroupGradeDetailsByPath(details []filter.GradeDetails) map[string][]filter.GradeDetails {\n    // ... (Existing grouping logic remains unchanged)\n}\n\n// BuildReportTree builds the report tree from pre-grouped details.\nfunc (tb *TreeBuilder) BuildReportTree(groupedDetails map[string][]filter.GradeDetails) []*ReportNode {\n    // ... (Tree building logic remains unchanged)\n}\n```\n\nThis refactoring improves SRP by assigning each responsibility to a separate, more focused unit.  The `GroupGradeDetailsByPath` function can be used independently, enhancing reusability.\n",
            "severity": "Medium",
            "rationale": "The `TreeBuilder` violates the Single Responsibility Principle (SRP) because it's responsible for both grouping grade details by path and constructing the report tree.  This coupling makes the code harder to maintain, test, and understand.  Changes in one area (e.g., path normalization) could inadvertently affect the other (tree construction).  Separating these concerns into distinct classes would improve modularity and reduce the risk of introducing bugs.\n",
            "lineStart": 10,
            "lineEnd": 113,
            "status": ""
          }
        ],
        "codeReviewTitle": "SOLID Code Review"
      },
      "upgradedCode": {
        "oldCode": "package report\n\nimport (\n\t\"codeleft-cli/filter\" // Assuming this path is correct\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n)\n\n// TreeBuilder is responsible for constructing the ReportNode tree.\ntype TreeBuilder struct{}\n\nfunc NewTreeBuilder() *TreeBuilder {\n\treturn &TreeBuilder{}\n}\n\nfunc (tb *TreeBuilder) GroupGradeDetailsByPath(details []filter.GradeDetails) map[string][]filter.GradeDetails {\n\tgrouped := make(map[string][]filter.GradeDetails)\n\tfor _, d := range details {\n\t\t// Normalize path separators for consistency\n\t\tnormalizedPath := filepath.ToSlash(d.FileName)\n\t\tgrouped[normalizedPath] = append(grouped[normalizedPath], d)\n\t}\n\treturn grouped\n}\n\n// BuildReportTree constructs the basic tree hierarchy from file paths.\n// It does not calculate coverage here.\nfunc (tb *TreeBuilder) BuildReportTree(groupedDetails map[string][]filter.GradeDetails) []*ReportNode {\n    roots := []*ReportNode{}\n    dirs := make(map[string]*ReportNode)\n\n    // Sort paths for potentially more structured processing (optional but can help)\n    paths := make([]string, 0, len(groupedDetails))\n    for p := range groupedDetails {\n        paths = append(paths, p)\n    }\n    sort.Strings(paths)\n\n    for _, fullPath := range paths {\n        details := groupedDetails[fullPath] // Get the details for this file\n        parts := strings.Split(fullPath, \"/\")\n        if len(parts) == 0 {\n            continue // Skip empty paths\n        }\n\n        var parent *ReportNode\n        currentPath := \"\"\n\n        for i, part := range parts {\n            isLastPart := (i == len(parts)-1)\n            if currentPath == \"\" {\n                currentPath = part\n            } else {\n                currentPath = currentPath + \"/\" + part\n            }\n\n            // Check if node already exists (could be a dir created by a previous path)\n            existingNode, found := dirs[currentPath]\n\n            if isLastPart { // This is the file part\n                fileNode := &ReportNode{\n                    Name:           part,\n                    Path:           fullPath, // Store the full original path\n                    IsDir:          false,\n                    Details:        details, // Store associated details\n                    ToolCoverages:  make(map[string]float64),\n                    ToolCoverageOk: make(map[string]bool),\n                }\n                if parent == nil { // File in root\n                    roots = append(roots, fileNode)\n                } else {\n                    parent.Children = append(parent.Children, fileNode)\n                }\n                // Don't add files to the 'dirs' map\n            } else { // This is a directory part\n                if found {\n                    // Directory node already exists, just update parent pointer\n                    parent = existingNode\n                } else {\n                    // Create new directory node\n                    dirNode := &ReportNode{\n                        Name:           part,\n                        Path:           currentPath, // Path up to this directory\n                        IsDir:          true,\n                        Children:       []*ReportNode{},\n                        ToolCoverages:  make(map[string]float64),\n                        ToolCoverageOk: make(map[string]bool),\n                    }\n                    dirs[currentPath] = dirNode // Add to map for lookup\n\n                    if parent == nil { // Directory in root\n                        roots = append(roots, dirNode)\n                    } else {\n                        // Check if child already exists in parent (can happen with sorting/processing order)\n                        childExists := false\n                        for _, child := range parent.Children {\n                            if child.Path == dirNode.Path {\n                                childExists = true\n                                break\n                            }\n                        }\n                        if !childExists {\n                            parent.Children = append(parent.Children, dirNode)\n                        }\n                    }\n                    parent = dirNode // This new dir becomes the parent for the next part\n                }\n            }\n        }\n    }\n    return roots\n}",
        "newCode": "package report\n\nimport (\n\t\"codeleft-cli/filter\" // Assuming this path is correct\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n)\n\n// GradeDetailer interface for abstracting grade details.\ntype GradeDetailer interface {\n\tGetFileName() string\n\t// Add other methods from filter.GradeDetails as needed, e.g., GetGrade(), etc.\n}\n\n// Implement GradeDetailer for filter.GradeDetails\ntype GradeDetailsAdapter struct {\n\tfilter.GradeDetails\n}\n\nfunc (gda GradeDetailsAdapter) GetFileName() string {\n\treturn gda.FileName\n}\n\n// CoverageData interface for abstracting coverage data.\ntype CoverageData interface {\n\tGetCoverage(tool string) (float64, bool)\n\tSetCoverage(tool string, coverage float64, ok bool)\n}\n\n// ReportNode represents a node in the report tree.\ntype ReportNode struct {\n\tName           string\n\tPath           string\n\tIsDir          bool\n\tChildren       []*ReportNode\n\tDetails        []filter.GradeDetails // Store associated details\n\tCoverageData   CoverageData\n}\n\n// TreeBuilder is responsible for constructing the ReportNode tree.\ntype TreeBuilder struct{}\n\nfunc NewTreeBuilder() *TreeBuilder {\n\treturn &TreeBuilder{}\n}\n\n// GroupGradeDetailsByPath groups grade details by file path.\nfunc (tb *TreeBuilder) GroupGradeDetailsByPath(details []filter.GradeDetails) map[string][]filter.GradeDetails {\n\tgrouped := make(map[string][]filter.GradeDetails)\n\tfor _, d := range details {\n\t\t// Normalize path separators for consistency\n\t\tnormalizedPath := filepath.ToSlash(d.FileName)\n\t\tgrouped[normalizedPath] = append(grouped[normalizedPath], d)\n\t}\n\treturn grouped\n}\n\n// BuildReportTree constructs the basic tree hierarchy from file paths.\n// It does not calculate coverage here.\nfunc (tb *TreeBuilder) BuildReportTree(groupedDetails map[string][]filter.GradeDetails) []*ReportNode {\n\troots := []*ReportNode{}\n\tdirs := make(map[string]*ReportNode)\n\n\t// Sort paths for potentially more structured processing (optional but can help)\n\tpaths := make([]string, 0, len(groupedDetails))\n\tfor p := range groupedDetails {\n\t\tpaths = append(paths, p)\n\t}\n\tsort.Strings(paths)\n\n\tfor _, fullPath := range paths {\n\t\tdetails := groupedDetails[fullPath] // Get the details for this file\n\t\tparts := strings.Split(fullPath, \"/\")\n\t\tif len(parts) == 0 {\n\t\t\tcontinue // Skip empty paths\n\t\t}\n\n\t\tvar parent *ReportNode\n\t\tcurrentPath := \"\"\n\n\t\tfor i, part := range parts {\n\t\t\tisLastPart := (i == len(parts)-1)\n\t\t\tif currentPath == \"\" {\n\t\t\t\tcurrentPath = part\n\t\t\t} else {\n\t\t\t\tcurrentPath = currentPath + \"/\" + part\n\t\t\t}\n\n\t\t\t// Check if node already exists (could be a dir created by a previous path)\n\t\t\texistingNode, found := dirs[currentPath]\n\n\t\t\tif isLastPart { // This is the file part\n\t\t\t\tfileNode := &ReportNode{\n\t\t\t\t\tName:     part,\n\t\t\t\t\tPath:     fullPath, // Store the full original path\n\t\t\t\t\tIsDir:    false,\n\t\t\t\t\tDetails:  details, // Store associated details\n\t\t\t\t}\n\t\t\t\tif parent == nil { // File in root\n\t\t\t\t\troots = append(roots, fileNode)\n\t\t\t\t} else {\n\t\t\t\t\tparent.Children = append(parent.Children, fileNode)\n\t\t\t\t}\n\t\t\t\t// Don't add files to the 'dirs' map\n\t\t\t} else { // This is a directory part\n\t\t\t\tif found {\n\t\t\t\t\t// Directory node already exists, just update parent pointer\n\t\t\t\t\tparent = existingNode\n\t\t\t\t} else {\n\t\t\t\t\t// Create new directory node\n\t\t\t\t\tdirNode := &ReportNode{\n\t\t\t\t\t\tName:     part,\n\t\t\t\t\t\tPath:     currentPath, // Path up to this directory\n\t\t\t\t\t\tIsDir:    true,\n\t\t\t\t\t\tChildren: []*ReportNode{},\n\t\t\t\t\t}\n\t\t\t\t\tdirs[currentPath] = dirNode // Add to map for lookup\n\n\t\t\t\t\tif parent == nil { // Directory in root\n\t\t\t\t\t\troots = append(roots, dirNode)\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Check if child already exists in parent (can happen with sorting/processing order)\n\t\t\t\t\t\tchildExists := false\n\t\t\t\t\t\tfor _, child := range parent.Children {\n\t\t\t\t\t\t\tif child.Path == dirNode.Path {\n\t\t\t\t\t\t\t\tchildExists = true\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif !childExists {\n\t\t\t\t\t\t\tparent.Children = append(parent.Children, dirNode)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tparent = dirNode // This new dir becomes the parent for the next part\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn roots\n}",
        "changes": [
          {
            "oldCode": "package report",
            "newCode": "package report",
            "reason": "Unchanged",
            "start": 1,
            "end": 1
          },
          {
            "reason": "Unchanged",
            "start": 2,
            "end": 2
          },
          {
            "oldCode": "import (",
            "newCode": "import (",
            "reason": "Unchanged",
            "start": 3,
            "end": 3
          },
          {
            "oldCode": "\t\"codeleft-cli/filter\" // Assuming this path is correct",
            "newCode": "\t\"codeleft-cli/filter\" // Assuming this path is correct",
            "reason": "Unchanged",
            "start": 4,
            "end": 4
          },
          {
            "oldCode": "\t\"path/filepath\"",
            "newCode": "\t\"path/filepath\"",
            "reason": "Unchanged",
            "start": 5,
            "end": 5
          },
          {
            "oldCode": "\t\"sort\"",
            "newCode": "\t\"sort\"",
            "reason": "Unchanged",
            "start": 6,
            "end": 6
          },
          {
            "oldCode": "\t\"strings\"",
            "newCode": "\t\"strings\"",
            "reason": "Unchanged",
            "start": 7,
            "end": 7
          },
          {
            "oldCode": ")",
            "newCode": ")",
            "reason": "Unchanged",
            "start": 8,
            "end": 8
          },
          {
            "newCode": "\n// GradeDetailer interface for abstracting grade details.\ntype GradeDetailer interface {\n\tGetFileName() string\n\t// Add other methods from filter.GradeDetails as needed, e.g., GetGrade(), etc.\n}\n\n// Implement GradeDetailer for filter.GradeDetails\ntype GradeDetailsAdapter struct {\n\tfilter.GradeDetails\n}\n\nfunc (gda GradeDetailsAdapter) GetFileName() string {\n\treturn gda.FileName\n}\n\n// CoverageData interface for abstracting coverage data.\ntype CoverageData interface {\n\tGetCoverage(tool string) (float64, bool)\n\tSetCoverage(tool string, coverage float64, ok bool)\n}\n\n// ReportNode represents a node in the report tree.\ntype ReportNode struct {\n\tName           string\n\tPath           string\n\tIsDir          bool\n\tChildren       []*ReportNode\n\tDetails        []filter.GradeDetails // Store associated details\n\tCoverageData   CoverageData\n}\n",
            "reason": "Modified",
            "start": 9,
            "end": 9,
            "reasonDiff": "The `GradeDetailer` and `CoverageData` interfaces, along with the `GradeDetailsAdapter` type, were introduced to improve dependency inversion and the open/closed principle.  The `ReportNode` was modified to include `CoverageData` to support this change.\n"
          },
          {
            "oldCode": "// TreeBuilder is responsible for constructing the ReportNode tree.",
            "newCode": "// TreeBuilder is responsible for constructing the ReportNode tree.",
            "reason": "Unchanged",
            "start": 10,
            "end": 10
          },
          {
            "oldCode": "type TreeBuilder struct{}",
            "newCode": "type TreeBuilder struct{}",
            "reason": "Unchanged",
            "start": 11,
            "end": 11
          },
          {
            "reason": "Unchanged",
            "start": 12,
            "end": 12
          },
          {
            "oldCode": "func NewTreeBuilder() *TreeBuilder {",
            "newCode": "func NewTreeBuilder() *TreeBuilder {",
            "reason": "Unchanged",
            "start": 13,
            "end": 13
          },
          {
            "oldCode": "\treturn &TreeBuilder{}",
            "newCode": "\treturn &TreeBuilder{}",
            "reason": "Unchanged",
            "start": 14,
            "end": 14
          },
          {
            "oldCode": "}",
            "newCode": "}",
            "reason": "Unchanged",
            "start": 15,
            "end": 15
          },
          {
            "reason": "Unchanged",
            "start": 16,
            "end": 16
          },
          {
            "newCode": "// GroupGradeDetailsByPath groups grade details by file path.",
            "reason": "Added",
            "start": 17,
            "end": 17,
            "reasonDiff": "Added a comment to clarify the purpose of the `GroupGradeDetailsByPath` function, addressing the Single Responsibility Principle feedback by improving code clarity and separating concerns.\n"
          },
          {
            "oldCode": "func (tb *TreeBuilder) GroupGradeDetailsByPath(details []filter.GradeDetails) map[string][]filter.GradeDetails {",
            "newCode": "func (tb *TreeBuilder) GroupGradeDetailsByPath(details []filter.GradeDetails) map[string][]filter.GradeDetails {",
            "reason": "Unchanged",
            "start": 17,
            "end": 17
          },
          {
            "oldCode": "\tgrouped := make(map[string][]filter.GradeDetails)",
            "newCode": "\tgrouped := make(map[string][]filter.GradeDetails)",
            "reason": "Unchanged",
            "start": 18,
            "end": 18
          },
          {
            "oldCode": "\tfor _, d := range details {",
            "newCode": "\tfor _, d := range details {",
            "reason": "Unchanged",
            "start": 19,
            "end": 19
          },
          {
            "oldCode": "\t\t// Normalize path separators for consistency",
            "newCode": "\t\t// Normalize path separators for consistency",
            "reason": "Unchanged",
            "start": 20,
            "end": 20
          },
          {
            "oldCode": "\t\tnormalizedPath := filepath.ToSlash(d.FileName)",
            "newCode": "\t\tnormalizedPath := filepath.ToSlash(d.FileName)",
            "reason": "Unchanged",
            "start": 21,
            "end": 21
          },
          {
            "oldCode": "\t\tgrouped[normalizedPath] = append(grouped[normalizedPath], d)",
            "newCode": "\t\tgrouped[normalizedPath] = append(grouped[normalizedPath], d)",
            "reason": "Unchanged",
            "start": 22,
            "end": 22
          },
          {
            "oldCode": "\t}",
            "newCode": "\t}",
            "reason": "Unchanged",
            "start": 23,
            "end": 23
          },
          {
            "oldCode": "\treturn grouped",
            "newCode": "\treturn grouped",
            "reason": "Unchanged",
            "start": 24,
            "end": 24
          },
          {
            "oldCode": "}",
            "newCode": "}",
            "reason": "Unchanged",
            "start": 25,
            "end": 25
          },
          {
            "reason": "Unchanged",
            "start": 26,
            "end": 26
          },
          {
            "oldCode": "// BuildReportTree constructs the basic tree hierarchy from file paths.",
            "newCode": "// BuildReportTree constructs the basic tree hierarchy from file paths.",
            "reason": "Unchanged",
            "start": 27,
            "end": 27
          },
          {
            "oldCode": "// It does not calculate coverage here.",
            "newCode": "// It does not calculate coverage here.",
            "reason": "Unchanged",
            "start": 28,
            "end": 28
          },
          {
            "oldCode": "func (tb *TreeBuilder) BuildReportTree(groupedDetails map[string][]filter.GradeDetails) []*ReportNode {",
            "newCode": "func (tb *TreeBuilder) BuildReportTree(groupedDetails map[string][]filter.GradeDetails) []*ReportNode {",
            "reason": "Unchanged",
            "start": 29,
            "end": 29
          },
          {
            "oldCode": "    roots := []*ReportNode{}\n    dirs := make(map[string]*ReportNode)\n\n    // Sort paths for potentially more structured processing (optional but can help)\n    paths := make([]string, 0, len(groupedDetails))\n    for p := range groupedDetails {\n        paths = append(paths, p)\n    }\n    sort.Strings(paths)\n\n    for _, fullPath := range paths {\n        details := groupedDetails[fullPath] // Get the details for this file\n        parts := strings.Split(fullPath, \"/\")\n        if len(parts) == 0 {\n            continue // Skip empty paths\n        }\n\n        var parent *ReportNode\n        currentPath := \"\"\n\n        for i, part := range parts {\n            isLastPart := (i == len(parts)-1)\n            if currentPath == \"\" {\n                currentPath = part\n            } else {\n                currentPath = currentPath + \"/\" + part\n            }\n\n            // Check if node already exists (could be a dir created by a previous path)\n            existingNode, found := dirs[currentPath]\n\n            if isLastPart { // This is the file part\n                fileNode := &ReportNode{\n                    Name:           part,\n                    Path:           fullPath, // Store the full original path\n                    IsDir:          false,\n                    Details:        details, // Store associated details\n                    ToolCoverages:  make(map[string]float64),\n                    ToolCoverageOk: make(map[string]bool),\n                }\n                if parent == nil { // File in root\n                    roots = append(roots, fileNode)\n                } else {\n                    parent.Children = append(parent.Children, fileNode)\n                }\n                // Don't add files to the 'dirs' map\n            } else { // This is a directory part\n                if found {\n                    // Directory node already exists, just update parent pointer\n                    parent = existingNode\n                } else {\n                    // Create new directory node\n                    dirNode := &ReportNode{\n                        Name:           part,\n                        Path:           currentPath, // Path up to this directory\n                        IsDir:          true,\n                        Children:       []*ReportNode{},\n                        ToolCoverages:  make(map[string]float64),\n                        ToolCoverageOk: make(map[string]bool),\n                    }\n                    dirs[currentPath] = dirNode // Add to map for lookup\n\n                    if parent == nil { // Directory in root\n                        roots = append(roots, dirNode)\n                    } else {\n                        // Check if child already exists in parent (can happen with sorting/processing order)\n                        childExists := false\n                        for _, child := range parent.Children {\n                            if child.Path == dirNode.Path {\n                                childExists = true\n                                break\n                            }\n                        }\n                        if !childExists {\n                            parent.Children = append(parent.Children, dirNode)\n                        }\n                    }\n                    parent = dirNode // This new dir becomes the parent for the next part\n                }\n            }\n        }\n    }\n    return roots",
            "newCode": "\troots := []*ReportNode{}\n\tdirs := make(map[string]*ReportNode)\n\n\t// Sort paths for potentially more structured processing (optional but can help)\n\tpaths := make([]string, 0, len(groupedDetails))\n\tfor p := range groupedDetails {\n\t\tpaths = append(paths, p)\n\t}\n\tsort.Strings(paths)\n\n\tfor _, fullPath := range paths {\n\t\tdetails := groupedDetails[fullPath] // Get the details for this file\n\t\tparts := strings.Split(fullPath, \"/\")\n\t\tif len(parts) == 0 {\n\t\t\tcontinue // Skip empty paths\n\t\t}\n\n\t\tvar parent *ReportNode\n\t\tcurrentPath := \"\"\n\n\t\tfor i, part := range parts {\n\t\t\tisLastPart := (i == len(parts)-1)\n\t\t\tif currentPath == \"\" {\n\t\t\t\tcurrentPath = part\n\t\t\t} else {\n\t\t\t\tcurrentPath = currentPath + \"/\" + part\n\t\t\t}\n\n\t\t\t// Check if node already exists (could be a dir created by a previous path)\n\t\t\texistingNode, found := dirs[currentPath]\n\n\t\t\tif isLastPart { // This is the file part\n\t\t\t\tfileNode := &ReportNode{\n\t\t\t\t\tName:     part,\n\t\t\t\t\tPath:     fullPath, // Store the full original path\n\t\t\t\t\tIsDir:    false,\n\t\t\t\t\tDetails:  details, // Store associated details\n\t\t\t\t}\n\t\t\t\tif parent == nil { // File in root\n\t\t\t\t\troots = append(roots, fileNode)\n\t\t\t\t} else {\n\t\t\t\t\tparent.Children = append(parent.Children, fileNode)\n\t\t\t\t}\n\t\t\t\t// Don't add files to the 'dirs' map\n\t\t\t} else { // This is a directory part\n\t\t\t\tif found {\n\t\t\t\t\t// Directory node already exists, just update parent pointer\n\t\t\t\t\tparent = existingNode\n\t\t\t\t} else {\n\t\t\t\t\t// Create new directory node\n\t\t\t\t\tdirNode := &ReportNode{\n\t\t\t\t\t\tName:     part,\n\t\t\t\t\t\tPath:     currentPath, // Path up to this directory\n\t\t\t\t\t\tIsDir:    true,\n\t\t\t\t\t\tChildren: []*ReportNode{},\n\t\t\t\t\t}\n\t\t\t\t\tdirs[currentPath] = dirNode // Add to map for lookup\n\n\t\t\t\t\tif parent == nil { // Directory in root\n\t\t\t\t\t\troots = append(roots, dirNode)\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Check if child already exists in parent (can happen with sorting/processing order)\n\t\t\t\t\t\tchildExists := false\n\t\t\t\t\t\tfor _, child := range parent.Children {\n\t\t\t\t\t\t\tif child.Path == dirNode.Path {\n\t\t\t\t\t\t\t\tchildExists = true\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif !childExists {\n\t\t\t\t\t\t\tparent.Children = append(parent.Children, dirNode)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tparent = dirNode // This new dir becomes the parent for the next part\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn roots",
            "reason": "Modified",
            "start": 30,
            "end": 112,
            "reasonDiff": "The `ToolCoverages` and `ToolCoverageOk` fields were removed from the `ReportNode` struct and a `CoverageData` interface was added to the `ReportNode` struct. This change adheres to the Interface Segregation Principle and the Open/Closed Principle by decoupling coverage data from the `ReportNode` and allowing for different coverage data implementations.\n"
          },
          {
            "oldCode": "}",
            "newCode": "}",
            "reason": "Unchanged",
            "start": 113,
            "end": 113
          }
        ]
      }
    },
    "gradingDetails": {
      "dependencyInversionScore": "B",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "B",
      "openClosedScore": "B",
      "singleResponsibilityScore": "B"
    },
    "hash": "08a54e99dc83d09a705517c593382c919c9e7527398ae9da9329a17c062f0e36",
    "id": "eJylWEuP2zYQ/itTHRI7cawUKHowoEOz2y4WCDZBd3uyjIKWRjZrihRIKom78H8vhqRsWivZCaqTKc7jm8c3pPycMGPQGC43T0qJZJE8fvp4f5vMkkKVeKOkRWmTRdKwYsc2CBobpW0uc8lr+gWTXOY2d9ICK/uuEDytuLCo8wTSFH4zpq253IDdcgMNs1vgBgqlNRbW69JL0kH6kSf+pSE33W+rudwYWk7JdZrCk0b80HJRoiZ7Gk2jpOFrgVApDYWSxuq2sN4zwp8O94MqEaxGnOfS7hs8M+MVng/koWplAQ/4NdqfTOFNLP5M2DTaVkt4FW2QgZONiV2fqU3hTqu2udOsxFu0jAvzYf+Z2e2k9CtYrnz65rHMFGrWLH0eVoMSHs+GjGMJiwxqtsPJNS1Kp6WE/T0Dp6WZ3CCUsc3cpik8KF0zwf9FX0KDDdPMKm2O6ebGoiz2XkN24iXFRoa7+s6f1KNgZjsp539wgQ+sxqnXCdiX57oryIA1DcpyMiIwg9JZOEQFCaKhEmkKLv2+CagapwYxrj3WzPDCdQZsOWqmi+0eKq1qh9vFbObO0L2FUqEBqSwUTBStYJbMfUFN/NiipuYaqX0PRRdRV8Kr1YLl6k3Uyc+5BADQSllDOT7bpT6k3ZJrM9QPkagjFcmmKTwSqV28rrKNogHAmRB7qJXGwJJWYwmNVoUfHTBRjeVKMgHrlvIiYYuimXqr3loHYbnyAGbwfgYCZS8J06DknJ86spepEPnJ+rFJ3HIGne+QBJom80c/RrzIMebQ/VUrRNer3qU3HHnqWLHIenCWnfKKMniH1vVUJ04O3PCjVopxa1+1MN3mj43gdtKZmkGepHkyPSnwyqXL6U0hy+B9DI6eQknLZYuujjveANaN3ftATpKHLnJ6vjBNSFBaiBritF+0mja7zOSJm8nHbYqNz1wsceIosh42bj4yYz8HwQmnAE7hvPt52hOvzlxn3nXfaB9h5nyfyxwAhcHrmvHqrU8+vB2yF8cfSHOzxWJHmCXRkgmNrNwDfuPGGpgUqhUlrBEYkREKjcxiCes9MGg0fuGq9SdjLwdOn8sNVWQGlWqlG9FE6GWEdtUHxKs4288E8In6j/tZFyZaPy5XTprIFMIig1fRKHkpSQ/N7kW0JpuzYVHCGYueupxa1dJgcdBaIUBpvuE0Stx1YNDcvbnlOrJXMWFwxHXg6FE60DLyzIxRBXc1CZvDluiCdBMGPdnrT9RKKGZ//WU6AiRW/7RbvFBfKyWGdA8vX/GqI22WgeTCF5nOU+DSnQfDEPxJcZyVbjk7Vn064HuUPOALjtLOb7ZclBplPITPNi67ePkqTeFWydcWWFk6VQNWuQZ5Tc3/mg7KYZLHve7YhoVVej/S7rwKrBqJj3AcTQxQewb/tMZC25R0BwgVaRSXdPu9kDHIzrj9o2mngeNmCEj8GgUpB22BvwN8P63hx6gNA/SOppPjmRuqbeOryM0J87jJPsWtbscYTk/Xap1G7yp0QfN/srpv4keYDcPtD+HWdjbkITtWkb6qypKSWbPGHcFCqV3b9M+B7hmeFqfOvjgyYHRsBDgDlIarLQy9c7Og8vUPTi473BN3o3Tu4Sun7w+liT1pdAVVmq7Y4+6ci9+9ZfoeoSNjXDrcCj2u+GZzNvAuRBcS7wzMuztMSJlfX1HuY84cBa7rrDWy3WWxkZ67ssUr+CkGdAX/9x8OlxvpAqqR18chGxHGHQphXMIaC1Wjvw0FYX9Jp4n6zY6cFj1v0fJw9q0RPkEdS3J5SGYJHWFU8mSRpH8Z1CbdotR7wep1WrfC8kZgevYPiv+bJV37D8f5RiWH/wA5djGU"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/builder.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-04-11T19:59:06.567Z",
    "codeReview": {
      "detailedReview": {
        "tasks": [
          {
            "done": false,
            "titleTask": "interfaceSegregation",
            "violatingCode": "The `GradeDetailer` interface only has `GetFileName()`.  If other grade-related data is needed,  it violates the Interface Segregation Principle (ISP) by forcing implementations to include methods they don't use.  A better approach would be to create more specific interfaces for different aspects of grade details.\n",
            "codeResolution": "The `GradeDetailer` interface only needs the `GetFileName()` method.  The `GradeDetailsAdapter` is unnecessary because `filter.GradeDetails` already contains the `FileName` field.  Remove the adapter and directly use `filter.GradeDetails` where `GradeDetailer` is expected.  This eliminates the adapter and simplifies the code.\n",
            "severity": "Medium",
            "rationale": "The `GradeDetailer` interface only exposes `GetFileName()`.  If other methods related to grade details are needed later,  violating the Interface Segregation Principle,  the interface would need to be modified, impacting maintainability.  Adding unnecessary methods to an interface increases coupling and can lead to unnecessary dependencies and potential performance issues if unused methods are accessed.\n",
            "lineStart": 11,
            "lineEnd": 28,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "singleResponsibility",
            "violatingCode": "The `TreeBuilder`'s `BuildReportTree` function has multiple responsibilities:  it parses file paths, constructs a tree structure (`ReportNode`), and handles sorting.  The lines `func (tb *TreeBuilder) BuildReportTree(...)` and the entire function body demonstrate this violation.  Separating path parsing, tree construction, and sorting into distinct functions would improve the Single Responsibility Principle.\n",
            "codeResolution": "The `TreeBuilder` violates the Single Responsibility Principle (SRP).  It's responsible for grouping grade details, building the report tree, and (implicitly) path normalization and sorting.  Refactor it into separate components: `GradeGrouper`, `TreeBuilder`, and potentially a `PathNormalizer`.\n\n`GradeGrouper` would handle `GroupGradeDetailsByPath`.  `TreeBuilder` would focus solely on constructing the tree from the grouped data.  Path normalization and sorting could be handled by a dedicated utility function or a separate `PathNormalizer` if needed.  This separation improves maintainability and testability.\n",
            "severity": "Medium",
            "rationale": "The `TreeBuilder` violates the Single Responsibility Principle (SRP) because it's responsible for both grouping grade details by path and constructing the report tree.  This coupling makes the code harder to maintain, test, and potentially less performant.  Separating these concerns into distinct classes would improve modularity, making it easier to modify or extend one aspect without affecting the other.  For example, changes to path handling wouldn't necessitate changes to tree construction logic.\n",
            "lineStart": 30,
            "lineEnd": 126,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "dependencyInversion",
            "violatingCode": "`TreeBuilder` depends on the concrete `filter.GradeDetails` type, violating",
            "codeResolution": "The `TreeBuilder` currently depends on the concrete `filter.GradeDetails` type.  To improve dependency inversion, introduce an abstraction (interface) for grade details,  `GradeDetailer`, which `filter.GradeDetails` implements via an adapter.  `TreeBuilder` should then depend on `GradeDetailer`, not `filter.GradeDetails` directly.  This allows substituting different grade detail implementations without modifying `TreeBuilder`.  The `GroupGradeDetailsByPath` function signature would change to accept `[]GradeDetailer`.\n",
            "severity": "Medium",
            "rationale": "The `TreeBuilder` depends on the concrete `filter.GradeDetails` type.  This violates the Dependency Inversion Principle because high-level modules (like `TreeBuilder`) should depend on abstractions, not concretions.  This tight coupling makes it difficult to substitute different grade detail implementations without modifying `TreeBuilder`.  Adding a new grading system would require code changes in `TreeBuilder`, reducing maintainability.\n",
            "lineStart": 30,
            "lineEnd": 125,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "openClosed",
            "violatingCode": "The `TreeBuilder`'s `BuildReportTree` function directly manipulates the structure of `ReportNode`, making it difficult to extend the report generation process to handle different report formats or data sources without modifying this function.  Adding a new report type would require changes within this function's logic.  The function tightly couples the report structure creation with the specific details processing.\n",
            "codeResolution": "The `TreeBuilder`'s `BuildReportTree` function is not easily extensible to handle different report structures or data sources.  To improve the Open/Closed Principle, introduce an interface for defining how grade details are grouped.  For example:\n\n```go\ntype Grouper interface {\n    Group(details []filter.GradeDetails) map[string][]filter.GradeDetails\n}\n\ntype PathGrouper struct{}\n\nfunc (pg *PathGrouper) Group(details []filter.GradeDetails) map[string][]filter.GradeDetails {\n    // Existing grouping logic here\n}\n\nfunc (tb *TreeBuilder) BuildReportTree(grouper Grouper, details []filter.GradeDetails) []*ReportNode {\n    grouped := grouper.Group(details)\n    // ... rest of the function\n}\n```\n\nNow, adding a new grouping strategy (e.g., grouping by module instead of path) only requires implementing the `Grouper` interface without modifying `BuildReportTree`.\n",
            "severity": "Medium",
            "rationale": "The `TreeBuilder`'s `BuildReportTree` function directly manipulates the `filter.GradeDetails` type.  If a new type of grading detail needs to be processed,  `BuildReportTree` would require modification. This violates the Open/Closed Principle because the function is not open for extension (adding new detail types) without modification. This impacts maintainability, as changes to grading details necessitate changes to the core reporting logic.  Correctness could also be affected if the modifications are not handled properly.\n",
            "lineStart": 37,
            "lineEnd": 128,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "liskovSubstitution",
            "violatingCode": "The `GradeDetailsAdapter` implements the `GradeDetailer` interface, but it directly exposes the `FileName` field from the embedded `filter.GradeDetails` struct.  This violates the Liskov Substitution Principle because a change in the underlying `filter.GradeDetails` struct (e.g., renaming `FileName`) would require modification of the adapter.  A better approach would be to explicitly define and manage the filename within the adapter, decoupling it from the internal structure of `filter.GradeDetails`.\n",
            "codeResolution": "The Liskov Substitution Principle (LSP) is violated because `GradeDetailsAdapter` is not a true substitute for `filter.GradeDetails`.  While it implements the `GradeDetailer` interface,  `TreeBuilder` uses `filter.GradeDetails` directly in several places (`GroupGradeDetailsByPath`, `BuildReportTree`),  making it impossible to replace `filter.GradeDetails` instances with `GradeDetailsAdapter` without modification.\n\nTo fix this, refactor `TreeBuilder` to consistently use the `GradeDetailer` interface instead of the concrete `filter.GradeDetails` type.  This allows any type implementing `GradeDetailer` (including `GradeDetailsAdapter`) to be used interchangeably.  The `GetFileName()` method should be added to the `filter.GradeDetails` interface if possible.  If not, the `TreeBuilder` needs to be updated to use the interface consistently.\n",
            "severity": "Medium",
            "rationale": "The `GradeDetailsAdapter` implements the `GradeDetailer` interface, but it only uses the `FileName` field from the `filter.GradeDetails` struct.  If `filter.GradeDetails` were to be modified to remove or rename `FileName`,  `GradeDetailsAdapter` would break, violating Liskov Substitution.  This impacts maintainability because changes in `filter.GradeDetails` require changes in the adapter, and correctness because the adapter might not function as expected after such changes.\n",
            "lineStart": 11,
            "lineEnd": 126,
            "status": ""
          }
        ],
        "codeReviewTitle": "SOLID Code Review"
      },
      "upgradedCode": {
        "oldCode": "package report\n\nimport (\n\t\"codeleft-cli/filter\" // Assuming this path is correct\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n)\n\n// GradeDetailer interface for abstracting grade details.\ntype GradeDetailer interface {\n\tGetFileName() string\n}\n\n// Implement GradeDetailer for filter.GradeDetails\ntype GradeDetailsAdapter struct {\n\tfilter.GradeDetails\n}\n\nfunc (gda GradeDetailsAdapter) GetFileName() string {\n\treturn gda.FileName\n}\n\n// CoverageData interface for abstracting coverage data.\ntype CoverageData interface {\n\tGetCoverage(tool string) (float64, bool)\n\tSetCoverage(tool string, coverage float64, ok bool)\n}\n\n// TreeBuilder is responsible for constructing the ReportNode tree.\ntype TreeBuilder struct{}\n\nfunc NewTreeBuilder() *TreeBuilder {\n\treturn &TreeBuilder{}\n}\n\n// GroupGradeDetailsByPath groups grade details by file path.\nfunc (tb *TreeBuilder) GroupGradeDetailsByPath(details []filter.GradeDetails) map[string][]filter.GradeDetails {\n\tgrouped := make(map[string][]filter.GradeDetails)\n\tfor _, d := range details {\n\t\t// Normalize path separators for consistency\n\t\tnormalizedPath := filepath.ToSlash(d.FileName)\n\t\tgrouped[normalizedPath] = append(grouped[normalizedPath], d)\n\t}\n\treturn grouped\n}\n\n// BuildReportTree constructs the basic tree hierarchy from file paths.\n// It does not calculate coverage here.\nfunc (tb *TreeBuilder) BuildReportTree(groupedDetails map[string][]filter.GradeDetails) []*ReportNode {\n\troots := []*ReportNode{}\n\tdirs := make(map[string]*ReportNode)\n\n\t// Sort paths for potentially more structured processing (optional but can help)\n\tpaths := make([]string, 0, len(groupedDetails))\n\tfor p := range groupedDetails {\n\t\tpaths = append(paths, p)\n\t}\n\tsort.Strings(paths)\n\n\tfor _, fullPath := range paths {\n\t\tdetails := groupedDetails[fullPath] // Get the details for this file\n\t\tparts := strings.Split(fullPath, \"/\")\n\t\tif len(parts) == 0 {\n\t\t\tcontinue // Skip empty paths\n\t\t}\n\n\t\tvar parent *ReportNode\n\t\tcurrentPath := \"\"\n\n\t\tfor i, part := range parts {\n\t\t\tisLastPart := (i == len(parts)-1)\n\t\t\tif currentPath == \"\" {\n\t\t\t\tcurrentPath = part\n\t\t\t} else {\n\t\t\t\tcurrentPath = currentPath + \"/\" + part\n\t\t\t}\n\n\t\t\t// Check if node already exists (could be a dir created by a previous path)\n\t\t\texistingNode, found := dirs[currentPath]\n\n\t\t\tif isLastPart { // This is the file part\n\t\t\t\tfileNode := &ReportNode{\n\t\t\t\t\tName:     part,\n\t\t\t\t\tPath:     fullPath, // Store the full original path\n\t\t\t\t\tIsDir:    false,\n\t\t\t\t\tDetails:  details, // Store associated details\n\t\t\t\t}\n\t\t\t\tif parent == nil { // File in root\n\t\t\t\t\troots = append(roots, fileNode)\n\t\t\t\t} else {\n\t\t\t\t\tparent.Children = append(parent.Children, fileNode)\n\t\t\t\t}\n\t\t\t\t// Don't add files to the 'dirs' map\n\t\t\t} else { // This is a directory part\n\t\t\t\tif found {\n\t\t\t\t\t// Directory node already exists, just update parent pointer\n\t\t\t\t\tparent = existingNode\n\t\t\t\t} else {\n\t\t\t\t\t// Create new directory node\n\t\t\t\t\tdirNode := &ReportNode{\n\t\t\t\t\t\tName:     part,\n\t\t\t\t\t\tPath:     currentPath, // Path up to this directory\n\t\t\t\t\t\tIsDir:    true,\n\t\t\t\t\t\tChildren: []*ReportNode{},\n\t\t\t\t\t}\n\t\t\t\t\tdirs[currentPath] = dirNode // Add to map for lookup\n\n\t\t\t\t\tif parent == nil { // Directory in root\n\t\t\t\t\t\troots = append(roots, dirNode)\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Check if child already exists in parent (can happen with sorting/processing order)\n\t\t\t\t\t\tchildExists := false\n\t\t\t\t\t\tfor _, child := range parent.Children {\n\t\t\t\t\t\t\tif child.Path == dirNode.Path {\n\t\t\t\t\t\t\t\tchildExists = true\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif !childExists {\n\t\t\t\t\t\t\tparent.Children = append(parent.Children, dirNode)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tparent = dirNode // This new dir becomes the parent for the next part\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn roots\n}",
        "newCode": "package report\n\nimport (\n\t\"codeleft-cli/filter\" // Assuming this path is correct\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n)\n\n// GradeDetailer interface for abstracting grade details.\ntype GradeDetailer interface {\n\tGetFileName() string\n}\n\n// PathGrouper groups grade details by file path.\ntype PathGrouper struct{}\n\nfunc (pg *PathGrouper) Group(details []filter.GradeDetails) map[string][]filter.GradeDetails {\n\tgrouped := make(map[string][]filter.GradeDetails)\n\tfor _, d := range details {\n\t\t// Normalize path separators for consistency\n\t\tnormalizedPath := filepath.ToSlash(d.FileName)\n\t\tgrouped[normalizedPath] = append(grouped[normalizedPath], d)\n\t}\n\treturn grouped\n}\n\n// TreeBuilder is responsible for constructing the ReportNode tree.\ntype TreeBuilder struct{}\n\nfunc NewTreeBuilder() *TreeBuilder {\n\treturn &TreeBuilder{}\n}\n\n// BuildReportTree constructs the basic tree hierarchy from file paths.\n// It does not calculate coverage here.\nfunc (tb *TreeBuilder) BuildReportTree(groupedDetails map[string][]filter.GradeDetails) []*ReportNode {\n\troots := []*ReportNode{}\n\tdirs := make(map[string]*ReportNode)\n\n\t// Sort paths for potentially more structured processing (optional but can help)\n\tpaths := make([]string, 0, len(groupedDetails))\n\tfor p := range groupedDetails {\n\t\tpaths = append(paths, p)\n\t}\n\tsort.Strings(paths)\n\n\tfor _, fullPath := range paths {\n\t\tdetails := groupedDetails[fullPath] // Get the details for this file\n\t\tparts := strings.Split(fullPath, \"/\")\n\t\tif len(parts) == 0 {\n\t\t\tcontinue // Skip empty paths\n\t\t}\n\n\t\tvar parent *ReportNode\n\t\tcurrentPath := \"\"\n\n\t\tfor i, part := range parts {\n\t\t\tisLastPart := (i == len(parts)-1)\n\t\t\tif currentPath == \"\" {\n\t\t\t\tcurrentPath = part\n\t\t\t} else {\n\t\t\t\tcurrentPath = currentPath + \"/\" + part\n\t\t\t}\n\n\t\t\t// Check if node already exists (could be a dir created by a previous path)\n\t\t\texistingNode, found := dirs[currentPath]\n\n\t\t\tif isLastPart { // This is the file part\n\t\t\t\tfileNode := &ReportNode{\n\t\t\t\t\tName:     part,\n\t\t\t\t\tPath:     fullPath, // Store the full original path\n\t\t\t\t\tIsDir:    false,\n\t\t\t\t\tDetails:  details, // Store associated details\n\t\t\t\t}\n\t\t\t\tif parent == nil { // File in root\n\t\t\t\t\troots = append(roots, fileNode)\n\t\t\t\t} else {\n\t\t\t\t\tparent.Children = append(parent.Children, fileNode)\n\t\t\t\t}\n\t\t\t\t// Don't add files to the 'dirs' map\n\t\t\t} else { // This is a directory part\n\t\t\t\tif found {\n\t\t\t\t\t// Directory node already exists, just update parent pointer\n\t\t\t\t\tparent = existingNode\n\t\t\t\t} else {\n\t\t\t\t\t// Create new directory node\n\t\t\t\t\tdirNode := &ReportNode{\n\t\t\t\t\t\tName:     part,\n\t\t\t\t\t\tPath:     currentPath, // Path up to this directory\n\t\t\t\t\t\tIsDir:    true,\n\t\t\t\t\t\tChildren: []*ReportNode{},\n\t\t\t\t\t}\n\t\t\t\t\tdirs[currentPath] = dirNode // Add to map for lookup\n\n\t\t\t\t\tif parent == nil { // Directory in root\n\t\t\t\t\t\troots = append(roots, dirNode)\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Check if child already exists in parent (can happen with sorting/processing order)\n\t\t\t\t\t\tchildExists := false\n\t\t\t\t\t\tfor _, child := range parent.Children {\n\t\t\t\t\t\t\tif child.Path == dirNode.Path {\n\t\t\t\t\t\t\t\tchildExists = true\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif !childExists {\n\t\t\t\t\t\t\tparent.Children = append(parent.Children, dirNode)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tparent = dirNode // This new dir becomes the parent for the next part\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn roots\n}",
        "changes": [
          {
            "oldCode": "package report",
            "newCode": "package report",
            "reason": "Unchanged",
            "start": 1,
            "end": 1
          },
          {
            "reason": "Unchanged",
            "start": 2,
            "end": 2
          },
          {
            "oldCode": "import (",
            "newCode": "import (",
            "reason": "Unchanged",
            "start": 3,
            "end": 3
          },
          {
            "oldCode": "\t\"codeleft-cli/filter\" // Assuming this path is correct",
            "newCode": "\t\"codeleft-cli/filter\" // Assuming this path is correct",
            "reason": "Unchanged",
            "start": 4,
            "end": 4
          },
          {
            "oldCode": "\t\"path/filepath\"",
            "newCode": "\t\"path/filepath\"",
            "reason": "Unchanged",
            "start": 5,
            "end": 5
          },
          {
            "oldCode": "\t\"sort\"",
            "newCode": "\t\"sort\"",
            "reason": "Unchanged",
            "start": 6,
            "end": 6
          },
          {
            "oldCode": "\t\"strings\"",
            "newCode": "\t\"strings\"",
            "reason": "Unchanged",
            "start": 7,
            "end": 7
          },
          {
            "oldCode": ")",
            "newCode": ")",
            "reason": "Unchanged",
            "start": 8,
            "end": 8
          },
          {
            "reason": "Unchanged",
            "start": 9,
            "end": 9
          },
          {
            "oldCode": "// GradeDetailer interface for abstracting grade details.",
            "newCode": "// GradeDetailer interface for abstracting grade details.",
            "reason": "Unchanged",
            "start": 10,
            "end": 10
          },
          {
            "oldCode": "type GradeDetailer interface {",
            "newCode": "type GradeDetailer interface {",
            "reason": "Unchanged",
            "start": 11,
            "end": 11
          },
          {
            "oldCode": "\tGetFileName() string",
            "newCode": "\tGetFileName() string",
            "reason": "Unchanged",
            "start": 12,
            "end": 12
          },
          {
            "oldCode": "}\n\n// Implement GradeDetailer for filter.GradeDetails\ntype GradeDetailsAdapter struct {\n\tfilter.GradeDetails\n}\n\nfunc (gda GradeDetailsAdapter) GetFileName() string {\n\treturn gda.FileName\n}\n\n// CoverageData interface for abstracting coverage data.\ntype CoverageData interface {\n\tGetCoverage(tool string) (float64, bool)\n\tSetCoverage(tool string, coverage float64, ok bool)\n}\n\n// TreeBuilder is responsible for constructing the ReportNode tree.\ntype TreeBuilder struct{}\n\nfunc NewTreeBuilder() *TreeBuilder {\n\treturn &TreeBuilder{}\n}\n\n// GroupGradeDetailsByPath groups grade details by file path.\nfunc (tb *TreeBuilder) GroupGradeDetailsByPath(details []filter.GradeDetails) map[string][]filter.GradeDetails {",
            "newCode": "}\n\n// PathGrouper groups grade details by file path.\ntype PathGrouper struct{}\n\nfunc (pg *PathGrouper) Group(details []filter.GradeDetails) map[string][]filter.GradeDetails {",
            "reason": "Modified",
            "start": 13,
            "end": 38,
            "reasonDiff": "The `GradeDetailsAdapter` and associated interface were removed, and the `GroupGradeDetailsByPath` function was extracted into a new `PathGrouper` type. This addresses the Single Responsibility and Interface Segregation principles.\n"
          },
          {
            "oldCode": "\tgrouped := make(map[string][]filter.GradeDetails)",
            "newCode": "\tgrouped := make(map[string][]filter.GradeDetails)",
            "reason": "Unchanged",
            "start": 39,
            "end": 39
          },
          {
            "oldCode": "\tfor _, d := range details {",
            "newCode": "\tfor _, d := range details {",
            "reason": "Unchanged",
            "start": 40,
            "end": 40
          },
          {
            "oldCode": "\t\t// Normalize path separators for consistency",
            "newCode": "\t\t// Normalize path separators for consistency",
            "reason": "Unchanged",
            "start": 41,
            "end": 41
          },
          {
            "oldCode": "\t\tnormalizedPath := filepath.ToSlash(d.FileName)",
            "newCode": "\t\tnormalizedPath := filepath.ToSlash(d.FileName)",
            "reason": "Unchanged",
            "start": 42,
            "end": 42
          },
          {
            "oldCode": "\t\tgrouped[normalizedPath] = append(grouped[normalizedPath], d)",
            "newCode": "\t\tgrouped[normalizedPath] = append(grouped[normalizedPath], d)",
            "reason": "Unchanged",
            "start": 43,
            "end": 43
          },
          {
            "oldCode": "\t}",
            "newCode": "\t}",
            "reason": "Unchanged",
            "start": 44,
            "end": 44
          },
          {
            "oldCode": "\treturn grouped",
            "newCode": "\treturn grouped",
            "reason": "Unchanged",
            "start": 45,
            "end": 45
          },
          {
            "oldCode": "}\n",
            "newCode": "}\n\n// TreeBuilder is responsible for constructing the ReportNode tree.\ntype TreeBuilder struct{}\n\nfunc NewTreeBuilder() *TreeBuilder {\n\treturn &TreeBuilder{}\n}\n",
            "reason": "Modified",
            "start": 46,
            "end": 47,
            "reasonDiff": "The `GroupGradeDetailsByPath` function was extracted from the `TreeBuilder` and placed in a new struct `PathGrouper` to adhere to the Single Responsibility Principle. This change improves code organization and maintainability by separating the grouping logic from the tree-building logic.\n"
          },
          {
            "oldCode": "// BuildReportTree constructs the basic tree hierarchy from file paths.",
            "newCode": "// BuildReportTree constructs the basic tree hierarchy from file paths.",
            "reason": "Unchanged",
            "start": 48,
            "end": 48
          },
          {
            "oldCode": "// It does not calculate coverage here.",
            "newCode": "// It does not calculate coverage here.",
            "reason": "Unchanged",
            "start": 49,
            "end": 49
          },
          {
            "oldCode": "func (tb *TreeBuilder) BuildReportTree(groupedDetails map[string][]filter.GradeDetails) []*ReportNode {",
            "newCode": "func (tb *TreeBuilder) BuildReportTree(groupedDetails map[string][]filter.GradeDetails) []*ReportNode {",
            "reason": "Unchanged",
            "start": 50,
            "end": 50
          },
          {
            "oldCode": "\troots := []*ReportNode{}",
            "newCode": "\troots := []*ReportNode{}",
            "reason": "Unchanged",
            "start": 51,
            "end": 51
          },
          {
            "oldCode": "\tdirs := make(map[string]*ReportNode)",
            "newCode": "\tdirs := make(map[string]*ReportNode)",
            "reason": "Unchanged",
            "start": 52,
            "end": 52
          },
          {
            "reason": "Unchanged",
            "start": 53,
            "end": 53
          },
          {
            "oldCode": "\t// Sort paths for potentially more structured processing (optional but can help)",
            "newCode": "\t// Sort paths for potentially more structured processing (optional but can help)",
            "reason": "Unchanged",
            "start": 54,
            "end": 54
          },
          {
            "oldCode": "\tpaths := make([]string, 0, len(groupedDetails))",
            "newCode": "\tpaths := make([]string, 0, len(groupedDetails))",
            "reason": "Unchanged",
            "start": 55,
            "end": 55
          },
          {
            "oldCode": "\tfor p := range groupedDetails {",
            "newCode": "\tfor p := range groupedDetails {",
            "reason": "Unchanged",
            "start": 56,
            "end": 56
          },
          {
            "oldCode": "\t\tpaths = append(paths, p)",
            "newCode": "\t\tpaths = append(paths, p)",
            "reason": "Unchanged",
            "start": 57,
            "end": 57
          },
          {
            "oldCode": "\t}",
            "newCode": "\t}",
            "reason": "Unchanged",
            "start": 58,
            "end": 58
          },
          {
            "oldCode": "\tsort.Strings(paths)",
            "newCode": "\tsort.Strings(paths)",
            "reason": "Unchanged",
            "start": 59,
            "end": 59
          },
          {
            "reason": "Unchanged",
            "start": 60,
            "end": 60
          },
          {
            "oldCode": "\tfor _, fullPath := range paths {",
            "newCode": "\tfor _, fullPath := range paths {",
            "reason": "Unchanged",
            "start": 61,
            "end": 61
          },
          {
            "oldCode": "\t\tdetails := groupedDetails[fullPath] // Get the details for this file",
            "newCode": "\t\tdetails := groupedDetails[fullPath] // Get the details for this file",
            "reason": "Unchanged",
            "start": 62,
            "end": 62
          },
          {
            "oldCode": "\t\tparts := strings.Split(fullPath, \"/\")",
            "newCode": "\t\tparts := strings.Split(fullPath, \"/\")",
            "reason": "Unchanged",
            "start": 63,
            "end": 63
          },
          {
            "oldCode": "\t\tif len(parts) == 0 {",
            "newCode": "\t\tif len(parts) == 0 {",
            "reason": "Unchanged",
            "start": 64,
            "end": 64
          },
          {
            "oldCode": "\t\t\tcontinue // Skip empty paths",
            "newCode": "\t\t\tcontinue // Skip empty paths",
            "reason": "Unchanged",
            "start": 65,
            "end": 65
          },
          {
            "oldCode": "\t\t}",
            "newCode": "\t\t}",
            "reason": "Unchanged",
            "start": 66,
            "end": 66
          },
          {
            "reason": "Unchanged",
            "start": 67,
            "end": 67
          },
          {
            "oldCode": "\t\tvar parent *ReportNode",
            "newCode": "\t\tvar parent *ReportNode",
            "reason": "Unchanged",
            "start": 68,
            "end": 68
          },
          {
            "oldCode": "\t\tcurrentPath := \"\"",
            "newCode": "\t\tcurrentPath := \"\"",
            "reason": "Unchanged",
            "start": 69,
            "end": 69
          },
          {
            "reason": "Unchanged",
            "start": 70,
            "end": 70
          },
          {
            "oldCode": "\t\tfor i, part := range parts {",
            "newCode": "\t\tfor i, part := range parts {",
            "reason": "Unchanged",
            "start": 71,
            "end": 71
          },
          {
            "oldCode": "\t\t\tisLastPart := (i == len(parts)-1)",
            "newCode": "\t\t\tisLastPart := (i == len(parts)-1)",
            "reason": "Unchanged",
            "start": 72,
            "end": 72
          },
          {
            "oldCode": "\t\t\tif currentPath == \"\" {",
            "newCode": "\t\t\tif currentPath == \"\" {",
            "reason": "Unchanged",
            "start": 73,
            "end": 73
          },
          {
            "oldCode": "\t\t\t\tcurrentPath = part",
            "newCode": "\t\t\t\tcurrentPath = part",
            "reason": "Unchanged",
            "start": 74,
            "end": 74
          },
          {
            "oldCode": "\t\t\t} else {",
            "newCode": "\t\t\t} else {",
            "reason": "Unchanged",
            "start": 75,
            "end": 75
          },
          {
            "oldCode": "\t\t\t\tcurrentPath = currentPath + \"/\" + part",
            "newCode": "\t\t\t\tcurrentPath = currentPath + \"/\" + part",
            "reason": "Unchanged",
            "start": 76,
            "end": 76
          },
          {
            "oldCode": "\t\t\t}",
            "newCode": "\t\t\t}",
            "reason": "Unchanged",
            "start": 77,
            "end": 77
          },
          {
            "reason": "Unchanged",
            "start": 78,
            "end": 78
          },
          {
            "oldCode": "\t\t\t// Check if node already exists (could be a dir created by a previous path)",
            "newCode": "\t\t\t// Check if node already exists (could be a dir created by a previous path)",
            "reason": "Unchanged",
            "start": 79,
            "end": 79
          },
          {
            "oldCode": "\t\t\texistingNode, found := dirs[currentPath]",
            "newCode": "\t\t\texistingNode, found := dirs[currentPath]",
            "reason": "Unchanged",
            "start": 80,
            "end": 80
          },
          {
            "reason": "Unchanged",
            "start": 81,
            "end": 81
          },
          {
            "oldCode": "\t\t\tif isLastPart { // This is the file part",
            "newCode": "\t\t\tif isLastPart { // This is the file part",
            "reason": "Unchanged",
            "start": 82,
            "end": 82
          },
          {
            "oldCode": "\t\t\t\tfileNode := &ReportNode{",
            "newCode": "\t\t\t\tfileNode := &ReportNode{",
            "reason": "Unchanged",
            "start": 83,
            "end": 83
          },
          {
            "oldCode": "\t\t\t\t\tName:     part,",
            "newCode": "\t\t\t\t\tName:     part,",
            "reason": "Unchanged",
            "start": 84,
            "end": 84
          },
          {
            "oldCode": "\t\t\t\t\tPath:     fullPath, // Store the full original path",
            "newCode": "\t\t\t\t\tPath:     fullPath, // Store the full original path",
            "reason": "Unchanged",
            "start": 85,
            "end": 85
          },
          {
            "oldCode": "\t\t\t\t\tIsDir:    false,",
            "newCode": "\t\t\t\t\tIsDir:    false,",
            "reason": "Unchanged",
            "start": 86,
            "end": 86
          },
          {
            "oldCode": "\t\t\t\t\tDetails:  details, // Store associated details",
            "newCode": "\t\t\t\t\tDetails:  details, // Store associated details",
            "reason": "Unchanged",
            "start": 87,
            "end": 87
          },
          {
            "oldCode": "\t\t\t\t}",
            "newCode": "\t\t\t\t}",
            "reason": "Unchanged",
            "start": 88,
            "end": 88
          },
          {
            "oldCode": "\t\t\t\tif parent == nil { // File in root",
            "newCode": "\t\t\t\tif parent == nil { // File in root",
            "reason": "Unchanged",
            "start": 89,
            "end": 89
          },
          {
            "oldCode": "\t\t\t\t\troots = append(roots, fileNode)",
            "newCode": "\t\t\t\t\troots = append(roots, fileNode)",
            "reason": "Unchanged",
            "start": 90,
            "end": 90
          },
          {
            "oldCode": "\t\t\t\t} else {",
            "newCode": "\t\t\t\t} else {",
            "reason": "Unchanged",
            "start": 91,
            "end": 91
          },
          {
            "oldCode": "\t\t\t\t\tparent.Children = append(parent.Children, fileNode)",
            "newCode": "\t\t\t\t\tparent.Children = append(parent.Children, fileNode)",
            "reason": "Unchanged",
            "start": 92,
            "end": 92
          },
          {
            "oldCode": "\t\t\t\t}",
            "newCode": "\t\t\t\t}",
            "reason": "Unchanged",
            "start": 93,
            "end": 93
          },
          {
            "oldCode": "\t\t\t\t// Don't add files to the 'dirs' map",
            "newCode": "\t\t\t\t// Don't add files to the 'dirs' map",
            "reason": "Unchanged",
            "start": 94,
            "end": 94
          },
          {
            "oldCode": "\t\t\t} else { // This is a directory part",
            "newCode": "\t\t\t} else { // This is a directory part",
            "reason": "Unchanged",
            "start": 95,
            "end": 95
          },
          {
            "oldCode": "\t\t\t\tif found {",
            "newCode": "\t\t\t\tif found {",
            "reason": "Unchanged",
            "start": 96,
            "end": 96
          },
          {
            "oldCode": "\t\t\t\t\t// Directory node already exists, just update parent pointer",
            "newCode": "\t\t\t\t\t// Directory node already exists, just update parent pointer",
            "reason": "Unchanged",
            "start": 97,
            "end": 97
          },
          {
            "oldCode": "\t\t\t\t\tparent = existingNode",
            "newCode": "\t\t\t\t\tparent = existingNode",
            "reason": "Unchanged",
            "start": 98,
            "end": 98
          },
          {
            "oldCode": "\t\t\t\t} else {",
            "newCode": "\t\t\t\t} else {",
            "reason": "Unchanged",
            "start": 99,
            "end": 99
          },
          {
            "oldCode": "\t\t\t\t\t// Create new directory node",
            "newCode": "\t\t\t\t\t// Create new directory node",
            "reason": "Unchanged",
            "start": 100,
            "end": 100
          },
          {
            "oldCode": "\t\t\t\t\tdirNode := &ReportNode{",
            "newCode": "\t\t\t\t\tdirNode := &ReportNode{",
            "reason": "Unchanged",
            "start": 101,
            "end": 101
          },
          {
            "oldCode": "\t\t\t\t\t\tName:     part,",
            "newCode": "\t\t\t\t\t\tName:     part,",
            "reason": "Unchanged",
            "start": 102,
            "end": 102
          },
          {
            "oldCode": "\t\t\t\t\t\tPath:     currentPath, // Path up to this directory",
            "newCode": "\t\t\t\t\t\tPath:     currentPath, // Path up to this directory",
            "reason": "Unchanged",
            "start": 103,
            "end": 103
          },
          {
            "oldCode": "\t\t\t\t\t\tIsDir:    true,",
            "newCode": "\t\t\t\t\t\tIsDir:    true,",
            "reason": "Unchanged",
            "start": 104,
            "end": 104
          },
          {
            "oldCode": "\t\t\t\t\t\tChildren: []*ReportNode{},",
            "newCode": "\t\t\t\t\t\tChildren: []*ReportNode{},",
            "reason": "Unchanged",
            "start": 105,
            "end": 105
          },
          {
            "oldCode": "\t\t\t\t\t}",
            "newCode": "\t\t\t\t\t}",
            "reason": "Unchanged",
            "start": 106,
            "end": 106
          },
          {
            "oldCode": "\t\t\t\t\tdirs[currentPath] = dirNode // Add to map for lookup",
            "newCode": "\t\t\t\t\tdirs[currentPath] = dirNode // Add to map for lookup",
            "reason": "Unchanged",
            "start": 107,
            "end": 107
          },
          {
            "reason": "Unchanged",
            "start": 108,
            "end": 108
          },
          {
            "oldCode": "\t\t\t\t\tif parent == nil { // Directory in root",
            "newCode": "\t\t\t\t\tif parent == nil { // Directory in root",
            "reason": "Unchanged",
            "start": 109,
            "end": 109
          },
          {
            "oldCode": "\t\t\t\t\t\troots = append(roots, dirNode)",
            "newCode": "\t\t\t\t\t\troots = append(roots, dirNode)",
            "reason": "Unchanged",
            "start": 110,
            "end": 110
          },
          {
            "oldCode": "\t\t\t\t\t} else {",
            "newCode": "\t\t\t\t\t} else {",
            "reason": "Unchanged",
            "start": 111,
            "end": 111
          },
          {
            "oldCode": "\t\t\t\t\t\t// Check if child already exists in parent (can happen with sorting/processing order)",
            "newCode": "\t\t\t\t\t\t// Check if child already exists in parent (can happen with sorting/processing order)",
            "reason": "Unchanged",
            "start": 112,
            "end": 112
          },
          {
            "oldCode": "\t\t\t\t\t\tchildExists := false",
            "newCode": "\t\t\t\t\t\tchildExists := false",
            "reason": "Unchanged",
            "start": 113,
            "end": 113
          },
          {
            "oldCode": "\t\t\t\t\t\tfor _, child := range parent.Children {",
            "newCode": "\t\t\t\t\t\tfor _, child := range parent.Children {",
            "reason": "Unchanged",
            "start": 114,
            "end": 114
          },
          {
            "oldCode": "\t\t\t\t\t\t\tif child.Path == dirNode.Path {",
            "newCode": "\t\t\t\t\t\t\tif child.Path == dirNode.Path {",
            "reason": "Unchanged",
            "start": 115,
            "end": 115
          },
          {
            "oldCode": "\t\t\t\t\t\t\t\tchildExists = true",
            "newCode": "\t\t\t\t\t\t\t\tchildExists = true",
            "reason": "Unchanged",
            "start": 116,
            "end": 116
          },
          {
            "oldCode": "\t\t\t\t\t\t\t\tbreak",
            "newCode": "\t\t\t\t\t\t\t\tbreak",
            "reason": "Unchanged",
            "start": 117,
            "end": 117
          },
          {
            "oldCode": "\t\t\t\t\t\t\t}",
            "newCode": "\t\t\t\t\t\t\t}",
            "reason": "Unchanged",
            "start": 118,
            "end": 118
          },
          {
            "oldCode": "\t\t\t\t\t\t}",
            "newCode": "\t\t\t\t\t\t}",
            "reason": "Unchanged",
            "start": 119,
            "end": 119
          },
          {
            "oldCode": "\t\t\t\t\t\tif !childExists {",
            "newCode": "\t\t\t\t\t\tif !childExists {",
            "reason": "Unchanged",
            "start": 120,
            "end": 120
          },
          {
            "oldCode": "\t\t\t\t\t\t\tparent.Children = append(parent.Children, dirNode)",
            "newCode": "\t\t\t\t\t\t\tparent.Children = append(parent.Children, dirNode)",
            "reason": "Unchanged",
            "start": 121,
            "end": 121
          },
          {
            "oldCode": "\t\t\t\t\t\t}",
            "newCode": "\t\t\t\t\t\t}",
            "reason": "Unchanged",
            "start": 122,
            "end": 122
          },
          {
            "oldCode": "\t\t\t\t\t}",
            "newCode": "\t\t\t\t\t}",
            "reason": "Unchanged",
            "start": 123,
            "end": 123
          },
          {
            "oldCode": "\t\t\t\t\tparent = dirNode // This new dir becomes the parent for the next part",
            "newCode": "\t\t\t\t\tparent = dirNode // This new dir becomes the parent for the next part",
            "reason": "Unchanged",
            "start": 124,
            "end": 124
          },
          {
            "oldCode": "\t\t\t\t}",
            "newCode": "\t\t\t\t}",
            "reason": "Unchanged",
            "start": 125,
            "end": 125
          },
          {
            "oldCode": "\t\t\t}",
            "newCode": "\t\t\t}",
            "reason": "Unchanged",
            "start": 126,
            "end": 126
          },
          {
            "oldCode": "\t\t}",
            "newCode": "\t\t}",
            "reason": "Unchanged",
            "start": 127,
            "end": 127
          },
          {
            "oldCode": "\t}",
            "newCode": "\t}",
            "reason": "Unchanged",
            "start": 128,
            "end": 128
          },
          {
            "oldCode": "\treturn roots",
            "newCode": "\treturn roots",
            "reason": "Unchanged",
            "start": 129,
            "end": 129
          },
          {
            "oldCode": "}",
            "newCode": "}",
            "reason": "Unchanged",
            "start": 130,
            "end": 130
          }
        ]
      }
    },
    "gradingDetails": {
      "dependencyInversionScore": "B",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "B",
      "openClosedScore": "B",
      "singleResponsibilityScore": "B"
    },
    "hash": "0129a1e9ebba8064a186c2e8f7549291f45f7e0c66e17fd02c26a28dd60155cc",
    "id": "eJyNWE2P2zYQ/StTHRI5cawUKHow4EOy2wYBgm1Qb0+WUdDSyGZNkQRJJXEX/u/FkKJFae2ke5LEmXnz8WaG66eMWYvWcrl/VEpky2z9x6eP99k8q1SNd0o6lC5bZppVR7ZHMKiVcaUsJW/pCfJSlq700gIb96YSvGi4cGjKDIoC3lnbtVzuwR24Bc3cAbiFShmDlQu69JF0kB7KLHy0BBOfneFyb+l1RtBFAR8Mq/EeHeMCDXDp0DSsQmiUAbazzrDKEeqe5KD2gnZRSnfSeFP5ieA+oPudC3xgLeYzCNClPPe4H1stsEXpJkYIN4S9SA7sc0D7rmbaoSHLXeUC5lVND9l0soJ8X7NrNmZwzdlg0qDrjIR9zRZRYojiTn1Bw/Z4zxz7TvKqXgxq5lhM3g3dmLt4nDulRO/RDPJGKOZ+/WUOO6UEFdGtr8vOB9SLjjpGtRjAo0F833FRU/0sGLRaSct3IgRRKRnSG4iH8Ken7YOqEZxBjLGkZoLC05D1B/yanOczeJWKp0l+kRyQgfOFpKrTad3enz5TA+zpux1zE3YnIhD6FlnEwrvdCHV2y2QerWy2V7g0g5bpTcjv9qpECMf7hTUsV9CyI+Y/0vJ1pHz/PQevZZjcDxF5m6UrCnhQpmWC/xuiA4uaGeaUsZdqcetQVqegIaN47dO1XEGcDotHtRbMHvL6wupZ0Ol934x1t7ACpjXKOr8hMIfaWzinTRNEh0L69AcOUTUGflnPrh2zvPLEggNHw0x1OEFjVDtUlGYPjQ8HtUILUjmomKg6wRwOjD+gwdu1n3gRI4ol/GG1YLN9lTRCYLBSzlKGR2e+C1zNjb3GhUTQj2Nf4jUtAx+pr6lWtDg4E+IErTLYt1dnsAZtVBVWDuRKO64kE7DrKCMSDii0L0iwFeE32zge3s5BoJwEP7tQUQ88nOSnp2Owe6GFf52DHkhAm2exDisnHPdR9kxvOiEiLwNQMNnbj+xfriYObKLilvbiB3SeO1GcjPsVSZSJnppQm37/LdZacJdHM3Mos6LMev7zxqfF68xgtYK30aHSVUo6Ljsk3PWRa8BWu1NwO8icQ4Sl+8IMaGZowSVlDmdVZ+ggxl5mfj/7I/Kez0nTpWkh/y9ecPuJWfe5F8k5OTm4/Obn2UWwgRRqFaAGQ2NPVh4nnp0BhcXbsunb65BAeD22EGPytL47YHUE3oCklmHCIKtPgN+4dRbySnWihh0Cg5obqAwyhzWNcgba4BeuunDnucTmNbncU1bn0KhO+sFJrbZJfNsOTvAGksw9UQ0fiSc8zJ5+wgz++9sE+g5fruBF0tSDROloci6B/kh3nh4RfjgamEbEcdTGHrITApThe06N6y9tifpHe8+N12+YsDgy3XfCEiLtE8vMWlVxn786XoGi3nl45E3k52oFkouQEVoGwCXQOEsBw3i7NLt/nUNM0CxBeMYb338o3eLuwEVtUKYzY3Rw3eDwWBRwr+RLB6yuvagFp3wmX1LdX9LknvI3LbMnF1ZOmdOk0rzpKTTym/AuCld4O4d/Ouug0zUtnz6bWvm73PP4YQUpab+fMuoY3wQg8Wvithxp+tXyI4Z+l6MpS5O28XTyvd3pkGNuBy/GBgaeOtPhxHos7XK6F0dy50lI4xYG39Y+TPo/qK7Jo5ZpP+qFUsdOD11+m9pDKa/w+xbDe+DZyNsr9RrPuIqing45LqNXud/PHgi+crrHKUO0KJKFrgxdVcYQ3uxvwRrd5WgsjCX6zRrw0/0x6r+J52FR0OEi7ok+7PD+THzsycrX/bnMziA7Tj+fxx8mr7yBn1LTz5D//yS5VrgJ3vlqjyZU83Oj7z/YYaVaDLuiFw5XDWrRb24yUC62z8O9YHQ19vwq5TmbZzTJKNHZMiv+smhscUBpToK1u6LthONaYDH6XSD8eFDswoV2sVfZ+T+RYBAY"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/builder.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-04-11T19:59:50.145Z",
    "codeReview": {
      "detailedReview": {
        "tasks": [
          {
            "done": false,
            "titleTask": "openClosed",
            "violatingCode": "The `TreeBuilder`'s `BuildReportTree` function directly manipulates the structure of `ReportNode` to build the tree.  Adding a new way to structure the report (e.g., grouping by different criteria than file path) would require modifying this function.  The function's logic is tightly coupled to the file path-based grouping.  Specifically, lines like `parts := strings.Split(fullPath, \"/\")` and the nested loop processing `parts` are directly tied to the path structure and would need changes for alternative grouping methods.\n",
            "codeResolution": "The `TreeBuilder`'s `BuildReportTree` function violates the Open/Closed Principle.  Adding a new way to structure the report (e.g., grouping by something other than path) requires modifying this function. To improve this, introduce an interface `ReportTreeBuilder` with a `BuildTree` method.  `TreeBuilder` would implement this interface.  New builders (e.g., `CategoryGrouper`) can then be created to implement the interface without altering `BuildReportTree`.\n",
            "severity": "Medium",
            "rationale": "The `TreeBuilder`'s `BuildReportTree` function processes grade details and constructs a tree structure.  Adding a new way to group or structure the report (e.g., grouping by coverage percentage instead of path) would require modifying this function.  This violates the Open/Closed Principle because the function is not open for extension without modification, impacting maintainability and potentially requiring extensive testing after any change.\n",
            "lineStart": 37,
            "lineEnd": 115,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "liskovSubstitution",
            "violatingCode": "The provided code does not violate the Liskov Substitution Principle (LSP).  The",
            "codeResolution": "The Liskov Substitution Principle (LSP) is not directly violated in this code.  The `GradeDetailer` interface is simple and any type implementing it can be substituted. However, the code's structure could be improved for better extensibility.  Consider creating a more robust interface that includes methods for retrieving relevant data (e.g., file name, grade information) instead of relying solely on `GetFileName()`. This would allow for more flexible implementations of `GradeDetailer` without modifying the `PathGrouper` or `TreeBuilder`.\n",
            "severity": "Medium",
            "rationale": "The Liskov Substitution Principle (LSP) is not directly violated in this code, as there are no obvious cases where a subtype cannot be substituted for its supertype without altering the correctness of the program.  However, the design could be improved for better adherence to LSP.  For example, the `GradeDetailer` interface is very simple and might not capture all the necessary information for future extensions.  Adding more methods to `GradeDetailer` later could break existing implementations of `PathGrouper` or `TreeBuilder` if they don't implement the new methods.  This would necessitate changes throughout the codebase, reducing maintainability.\n",
            "lineStart": 11,
            "lineEnd": 115,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "interfaceSegregation",
            "violatingCode": "The `GradeDetailer` interface only has `GetFileName()`.  The `PathGrouper` and `TreeBuilder` use `filter.GradeDetails`, which likely contains more methods than just getting the filename. This violates the Interface Segregation Principle because `PathGrouper` and `TreeBuilder` are forced to depend on methods of `filter.GradeDetails` that they don't use.  A more granular interface, perhaps one that only exposes `FileName`, would improve adherence to ISP.\n",
            "codeResolution": "The `GradeDetailer` interface is too generic.  It only has `GetFileName()`, which is used only by `PathGrouper`.  This violates the Interface Segregation Principle (ISP).  Refactor by creating separate interfaces for different functionalities. For example, create a `FileDetails` interface with `GetFileName()` and other file-specific methods if needed.  `PathGrouper` would then depend on `FileDetails` instead of `GradeDetailer`.  This improves cohesion and reduces unnecessary dependencies.\n",
            "severity": "Medium",
            "rationale": "The `GradeDetailer` interface only defines `GetFileName()`.  If other operations are needed on grade details (e.g., accessing metrics), adding them",
            "lineStart": 11,
            "lineEnd": 114,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "singleResponsibility",
            "violatingCode": "The `TreeBuilder`'s `BuildReportTree` function has multiple responsibilities:  it parses file paths, constructs a tree structure (`ReportNode`), and handles sorting.  The lines iterating through `paths`, splitting paths (`strings.Split`), creating and adding `ReportNode` instances, and managing parent-child relationships all contribute to this violation.  Separating path parsing, tree construction, and sorting into distinct functions would improve the SRP.\n",
            "codeResolution": "The `TreeBuilder`'s `BuildReportTree` method has multiple responsibilities:  it parses paths, creates `ReportNode` objects, and manages the tree structure.  To improve SRP, separate path parsing and node creation. Create a new function, e.g., `createReportNodes`, that takes parsed path components and details as input and returns the corresponding `ReportNode`s.  `BuildReportTree` would then focus solely on assembling the tree structure using the nodes created by `createReportNodes`.\n",
            "severity": "Medium",
            "rationale": "The `TreeBuilder`'s `BuildReportTree` function has multiple responsibilities:  it parses file paths, constructs a tree structure (`ReportNode`), and handles path normalization and sorting. This violates the Single Responsibility Principle (SRP).  Separating these concerns into distinct functions or classes would improve maintainability (easier to understand, test, and modify individual parts) and potentially performance (by optimizing individual tasks).  For example, path parsing could be a separate function, improving readability and reducing the complexity of the main tree-building logic.\n",
            "lineStart": 28,
            "lineEnd": 115,
            "status": ""
          }
        ],
        "codeReviewTitle": "SOLID Code Review"
      }
    },
    "gradingDetails": {
      "dependencyInversionScore": "A",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "B",
      "openClosedScore": "B",
      "singleResponsibilityScore": "B"
    },
    "hash": "de2ef7d33cbee7bd6c8c6c796e76ea485f14845275ab64ef7556fe3746c68f52",
    "id": "eJyNV9+P2zYM/lc4P7RJm8bda4A8bL3tUKC4FbvbUxwMik0n2imSIMlts0P+94GUFcu+XLt7Odvij4/kR1J5KoT36L3U+wdjVLEq7v/49PGmWBS1afCD0QF1KFaFFfWj2CM4tMaFSldaHukJZpWuQsXSCtvwrlaybKUK6KoCyhJ+8b47Sr2HcJAerAgHkB5q4xzWIerSR9JBeqiK+NGTm/QcnNR7T69zcl2WcOtEgzcYhFToQOqArhU1QmsciJ0PTtSBvO5JDhoW9MtKh5PFF5WfyN0tht+lwjtxxNkcoutKn3u/n0U43DrTWXSwp/9+7AJ2J6BQONLkL1fywXV1eGJ7badrmNk9vMkk5sAPs2Rws43pXGao/RyOwm4iuO1ViRgMQ8QGVms4ikec/UiL0hsoh38vgLWc0PshOLZZhbKEO+OOQsl/Y6Dg0QongnGeK1Ab7aUPqOtT1NBJvKFIyXCq9/LB3CvhD7NmmdI+jzo99s1YdwtrENaibmYvCCygYQuU4uAwdE5DLzrU8cEh/tpJ1RABPDj0ljDvFF4C4EJF5iL8yby/Mw1CcIipsrmZZ5W9w6/Z+WwOb3Lxpwzeq+yADCSU/Cm6JokBlmdQO+FlzXjgINEJVx9O0DpzHChInC9L+BigMehBmwC1UHWnRCBzX9BRVx/QUUiRj2E3Ajqfokh5T0T7Iadgs32T5S8GbkzwxIPRGScvNNL5a4zNBHkMMBHvaQhxpFw4a2hgSaHUCY7GYV+VzmED1pk6jjqYGRuk0ULBrqOMaDigskybaCu532yj8wW8X4BCPQl+fmkYO3TLJD9900S7F/Ly6wLsQFWaeMv7OOricR9l349tp1Tqnugomuztpx5drScANklxS/P4FgNzJ4mTcR7NRJmE1MXa9HN3eW+VDLNkZgFVUVZF36Wy5bSwzhzWa3ifAFWhNjpI3SH5vX+UFvBowynCjjLnGGEVvggHVjjUAbIyx7O6c3SQYq8K3gt8ROjlgjRDnhbCf0Eh/Sfhw+deZCYJ5AD53c/zi2ALuat1dDUYGiNZs590dgZUHl+Wzd/exgTC27GFFBPT+sMB60eQLWhqGaEciuYE+E364GFWm041sEMQ0EgHtUMRsKHdI8A6/CJNF3ftJTbWlHpPWV1AazrN451abZNh2w4gZAtZ5p6ohg/EExlnTz9hBvxVoE/c4as1vMqaepCoAs33FdAf6S7yI/IfjwamEXECtTG77JQC4+ReUuPyZSFT/+hvpGP9ViiPI9N9J6wg0T6zLLw3teT89YeD5nl4lG3i53oNWqqYEVpZIDXQOMsdxvF2aXZ+XUBK0Dzz8Iw33H+ow/LDQarGoc5nxujgusHhsSzhxujXAUTTsKiHYDiTr6nur2lyT/mbl5nJhXUw7jSptGx7Co1wk7+LwhXeLuCfzgfobEPLp8+mNXz/eh4/rCEn7fdTRh3DTQAav2aw9UiTV8uPGPpdjuYszdqG6cS93dmYY+kHFGMDA0+D63BiPZV2Nd2LI7nzJKRxCwO3NYdJ9++mIURHYXnUK2MeOzt0+cvUHkp5hd8vMbx3PB+hvVKv8YyrKerpkJM6oZrxfmZH8FXSbdM4okWZLXTj6KoydsFmf4vW6MZJY2Es0W/W6D/fH6P+myCPi4IOl2lP9GHH92fiYyRrrvtzmZ1D8Tj9fB5/mLzKFn7KTT/z/P8nybXCTfydr/ZoRjWeG33/wQ5rc8S4K3rheNWgFv0WJgPlYvs83AtGF3jmV6XPxaKgSUaJLlZF+ZdH58sDandS4rgrj50K0iosR79H44/WchcvtMu9Kc7/AfsEgA8="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/builder.go",
    "grade": "A",
    "username": "Hlamb",
    "timestamp": "2025-04-11T20:02:54.661Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "dependencyInversionScore": "A*",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "A*",
      "openClosedScore": "A*",
      "singleResponsibilityScore": "B"
    },
    "hash": "6765a9ad9c1c3283ef90ba6d21e2c1663dde7e01cb92c1fd14daa0e6bbed74fb",
    "id": "eJy1WEuP2zYQ/itTHQppo9gpUPRgwJdk2yBAkAR1erKMgJJGNrE0KZDjTd3F/veAL4nS2pu0QG/mcN7zzQzlh4wZg8Zwuf+slMhW2ebj+3e3WZk1qsU3ShJKylZZz5o7tkfQ2CtNlawkP9pfkFeyospxC+zoZSP4suOCUFeZv+oZHSwJ7Y9INFZL/E2ay72xx8JqXi7hjbpHzfZ4y4gBl4S6Yw1CpzSw2pBmDXG5hyawQcuILSpJ5x6vyT5YY2+R4nVOSgnwtgvIO6EY/fZrCbVSwrpBm8u85Wh1kFF3UewxBPCJ0WHTC06EehaAcWTrvk0K2KyY6PsVMee7o+eWffB6u/O/Rrsb7JlmpPREkzNpvCmoz0AHhI+bl6bHhne8AROloh9X1JA+NfTgbHUn2UBu4OYiawHPeOvD0UgnLcOlWYz8ZaDlETOLwUSRZPiDxadGS54luLFUa+dPB1bLCFwaYrLBIdOXxZ1njox/cIGWKZfsiEPtk4BKaJEYFwa2O4/4xVvNWrz11AJuRvuj2luusSGlz8/qngnHmG+xYydBE98NMGiUbDQSAj/2Ao8oiRFXElSXxhlDv6DlaWUbuHnKV8D/kJsJHH4e6Y5c0Qd2xBUAgLVVepqFmqM5vHjaO3PLtSV2TJjIGOytojuO/BgS+gOB/odq/Wg4F+O5GBCQPkXONwcuWo1yBdtdYvThcRLZcgmfNeLrExctOoxoNL2Shtci9IiSvua2T+w4SAIgjRixkqrxAj6+Pp0LaefbS5kgKwVg0rz4NdXsOhYtkiV+ndj8yukAvVb3vMUWWuxRtigb7hrZFXCqKr/qWAmpW5Na36QWJ+VLLkL9Uv0rSE+hQomVFaQ25xV6q9WpT7vi9dn6C3tLN7C3N0Mb1edxW8TIc6onrhfXVObfacYj67ceybuLHD4nzi9sYbWGI7vD/HtSbolarH0pwUlpJvdjRCGfbpLrIxP8Hww9Fae9GZDKDaFszjHBgb116VqtYVgUn9VGMHPI24WbUOyIhZcJvm+nsjtYA+stpPIrDCW0RSjbAIrAOhaytum3dQCNzUkbfo/i7KnG9ZZ/NLm+gk6ro4+zZ5rM9VoOWnOtFJlpv5fQcm3Swk0uneph35bQnYT49C+m88SWrxTvQKDMneYC1mt4FSsY0uK8jLmSFd0zbf1ASfNF2Jy0JcfqVZl7CAawcO/9iBcfS7DFzXtm6FNgyLl1ZHTr5S+h3LyD1MjaG4lKph6snQV/8wgoDF7jS08voMqWVQYvUmkfRUX4Nzd2sPpidOokHf5tybaJkl3k5x0kgQ3Wu7BlrSzVi2SULGZr2PowVnkobxE18S6WYr0GycVooyKPrqER3LGEaHtQMU+NnYRW4yJupFHF7OKSssvp5l1I1hMrsIY0qdedarl+NmXThe7zlpSkmGiaVgtcBYP5ge251F5LblCTGHsaSEWNzd/vNmrjhpx91qT3YbQ6tkm7TKoyUek7w14tYmMEX/x5xjz1Ye3eIXOOWiO7mxIf0+PkwDv4KVU5s/fjiHqawYmlxwv4GWs3geB8uocxFme7G8d+fLkJP7yb/GSvmeGNH+wHjprp5nD2I37ybbdcwjuCVqEBqQgaJpqTYITjp+QBNV7fBTMv4raK6/m7m/jSQPfQXK3nD0l755bLhT2fMBa+CfwnZWQdN86r0s3lqaPF8CToR8DOYkmeWSYFAB1MCf24jO0fCIuN/3j018W4RL4kKy/pDKsy6I8LcLWeObCNgrvoiPZponqRvvbCB2vkHhfPlS1ZUaMkcRk7KOAvDgiqF7OF71d82OXXhntYOTPsZmVm4WfZs1W2/MugNssDSn0W7FgvjydBvBe4nPxp4x8py9pjbrFX2eM3/V22Dw=="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/builder.go",
    "grade": "A",
    "username": "Hlamb",
    "timestamp": "2025-04-11T20:05:32.780Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "dependencyInversionScore": "A*",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "A*",
      "openClosedScore": "A",
      "singleResponsibilityScore": "B"
    },
    "hash": "6180c2931aca8f9653a419b685cf197adad5abaa4491657a0a6f6da30ceee532",
    "id": "eJy1WN1v2zYQ/1duehikVLU7YNiDAb+02YoCRVss2ZNlFLR0sonIpECek3lB/veBXxKpyGk7YG/m8b7vd3eUHzOmNWrNxf5Wyi5bZTefP364zsqslg2+k4JQULbKelbfsT2Cwl4qqkQl+NH8grwSFVWWu8OWXtcdX7a8I1RV5q56RgdDQvMjELXREn6T4mKvzbEwmpdLeCfvUbE9XjNiwAWhalmN0EoFbKdJsZq42EPt2aBhxBaVoHOPl2QfjbH3SOE6Jyk7cLYLyNtOMvrt1xJ2UnbGDbqZ5y1Hq4OMvAtiTz6AL4wON33HiVBNAtCWbNw3SQGTFR18vyBmfbf03LAPXm+27tdo9wZ7phhJlWiyJrUzBbsz0AHh881r3WPNW16DDlLBjwtqSJ1qerS22pOo4RM+zHLmRRqJ9V8hnZSAn2cljNJRb67hapatgBeykJjxoFqM/KWn5QGLi8FEEVXuk8G9QkOeFK42VGPnT9sEhhG40MREjUMF58WtZ5aMf/AODVMu2BEHTEUBldAgMd5p2GxdJy3eK9bgtaMWcDXaH9Vec4U1SXV+UfdEOMR8jS07dZT4roFBLUWtkBD4se/wiIIYcSlAtnGcIfQZLXOIec6WF0naErQ8555ApYar5zwF/A/JTh0b6ZZc0Sd2xBUAgLFVOprBrqVZADraB33NlSG2rNOB0dtbBXcs+QcC/Q/l/95wZuOZDQhInQLnuwPvGoViBZttZPTxKYlsuYRbhfj2xLsGLegU6l4KzXedbzopHIhM45m5FQVACjGAL1bjBFx8fTyH4lFiLkWEuhiC0TTAh1izHQFoWkPgQ2LzgdMBeiXveYMNNNijaFDU3E6GAP1IIL/oWAmxW0mtr2KLSfmiC1+/WP8K4pOvUGRlBbHNaYXeK3nq4654ezb+wt7QNezNzdBGu/O41kLkOe0S14tLKvNvNOOR9RuH5O0sh8uJ9QsbWK3hyO4w/5aU3fYGa19LsFKKif0Ykc+nXQ3qyDr+D/qeCutDD0jlmlDU55Bgz97YdK3WMGyeW3nTMX3Im4WdUOyIhZPxvm9S2S2sgfUGUvkFhhKawpdtAIVnHQu5M+k3dQCF9Ulpfo/d2VG17S33urN9Ba2SRxdnzxTpy7UctOZKStJpv5fQcKXjwiWXVvWwwEtoT1335Qemc2LLVYq30KHIreYC1mt4Eyro02K9DLkSFd0zZfxAQdPNWp+UIYfqVZl9sXqwcOf9iBcXi7fF9Uem6YtnyLlxZHTr9S++3LyF2MjaGQlKUg/W1oK7eQLsNF7ii0+voMqWVQavYmkXRUX4N9dmsLpitPIkLP5NyTaRkm3g5y1EgQ3WW79ljSztFtEoWUzWsPFhrPJQ3iJo4m0oxXoNgnejjYocuoZGsMcSgu1BxTQ1ZhIajYuwkUYVk4s5ZfPp5q1P1jMrsIY4qZedarh6MWXpQnd5i0pSJJrSaoGtoDc/sL2U2kvJ9WoiY88Dqag2+fvdRK3tkDPPmvjej1bLlrRLUpVEpesMc7UIjeF9cecJc+rD2r5Dphw7hewuJT7Fx+TAW/gpVjmx9/2Iep7BxNLTDH7G2iUQnE53P8bCbLfj2I0vO+GHd5Ob7Dumee0G+4GjYqo+nN2ITz5Cl0v4QNBI1CAkQc26+tQxwvGb94AKL++CiRdhW4X1/M1NPDfQHTRX6+lD0tzZ5TKz5yPGwjWB+/YNrOPGeVPauZw6WgxPgn4E7CSW6JmlYwDQQZfQj8vY/NOxuHFfo+66GJfI12jlRZ1hVHr9YQGu1hMHNkFwGxxRLk20W8SvPf8FHLjHxXNhS1ZUS0FchA7y+AsDgnaLycJ3K97v8kvD3a+cCXazMjPwM+zZKlv+pVHp5QGFOnfsuFseTx3xvsNl8u+Se6Qsdw5zi73Mnv4FChP3Uw=="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/main.go",
    "grade": "A+",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:05:52.491Z",
    "codeReview": {
      "review": "Congratulations! Your most recent code changes passed."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "codeDiff": {
      "oldCode": "package main\n\nimport (\n\t\"codeleft-cli/assessment\"\n\t\"codeleft-cli/filter\"\n\t\"codeleft-cli/read\"\n\t\"codeleft-cli/report\"\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\n// Version of the CLI tool\nconst Version = \"1.0.6\"\n\n// main is the entry point for your CLI tool.\nfunc main() {\n\t// Define flags\n\tthresholdGrade := flag.String(\"threshold-grade\", \"\", \"Sets the grade threshold.\")\n\tthresholdPercent := flag.Int(\"threshold-percent\", 0, \"Sets the percentage threshold.\")\n\ttoolsFlag := flag.String(\"tools\", \"\", \"Comma-separated list of tooling (e.g., SOLID,OWASP-Top-10,Clean-Code,...)\")\n\tversionFlag := flag.Bool(\"version\", false, \"Displays the current version of the CLI tool.\")\n\tassessGrade := flag.Bool(\"asses-grade\", false, \"Assess the grade threshold.\")\n\tassessCoverage := flag.Bool(\"asses-coverage\", false, \"Assess the coverage threshold.\")\n\tcreateReport := flag.Bool(\"create-report\", false, \"Create a report of the assessment.\")\n\n\t// Customize the usage message to include version information\n\tflag.Usage = func() {\n\t\tusageText := `codeleft-cli Version ` + Version + `\n\nUsage:\n  codeleft-cli [options]\n\nOptions:\n`\n\t\tfmt.Fprintln(flag.CommandLine.Output(), usageText)\n\t\tflag.PrintDefaults()\n\t}\n\n\t// Parse command-line flags\n\tflag.Parse()\n\n\t// Handle version flag\n\tif *versionFlag {\n\t\tfmt.Fprintf(os.Stderr, \"codeleft-cli Version %s\\n\", Version)\n\t\tos.Exit(0)\n\t}\n\n\t// Convert tools into a string slice\n\tif toolsFlag == nil {\n\t\tfmt.Fprintf(os.Stderr, \"tools flag is nil\")\n\t\tos.Exit(1)\n\t}\n\ttoolsList := parseTools(*toolsFlag)\n\n\t// Initialize HistoryReader\n\thistoryReader, err := read.NewHistoryReader()\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error initializing history reader: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\t// Read history\n\thistory, err := historyReader.ReadHistory()\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error reading history: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\t// Apply filters and assessments\n\tlatestGradeFilter := filter.NewLatestGrades()\n\thistory = latestGradeFilter.FilterLatestGrades(history)\n\n\ttoolFilter := filter.NewToolFilter()\n\thistory = toolFilter.Filter(toolsList, history)\n\n\t//config filtering\n\tconfigReader, err := read.NewConfigReader(read.NewOSFileSystem())\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error initializing config reader: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\tconfig, err := configReader.ReadConfig()\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error reading config: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\tif config.Ignore.Folders != nil || config.Ignore.Files != nil {\n\t\tpathFilter := filter.NewPathFilter(config.Ignore.Files, config.Ignore.Folders)\n\t\thistory = pathFilter.Filter(history)\n\t}\n\n\t// Collect grades and assess\n\tviolationCounter := assessment.NewConsoleViolationReporter()\n\n\tcalculator := filter.NewGradeStringCalculator()\n\tgradeCollector := filter.NewGradeCollection(calculator)\n\tgradeDetails := gradeCollector.CollectGrades(history, *thresholdGrade)\n\n\taccessorGrade := assessment.NewCoverageAssessment(violationCounter)\n\tif *assessGrade && !accessorGrade.AssessCoverage(*thresholdPercent, gradeDetails) {\n\t\tfmt.Fprintf(os.Stderr, \"Grade threshold failed :( \\n\")\n\t\tos.Exit(1)\n\t}\n\n\taccessorCoverage := assessment.NewCoverageAssessment(violationCounter)\n\tif *assessCoverage && !accessorCoverage.AssessCoverage(*thresholdPercent, gradeDetails) {\n\t\tfmt.Fprintf(os.Stderr, \"Coverage threshold failed :( \\n\")\n\t\tos.Exit(1)\n\t}\n\n\tif *createReport {\n\t\treporter := report.NewHtmlReport()\n\t\tif err := reporter.GenerateReport(gradeDetails, *thresholdGrade); err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Error generating report: %v\\n\", err)\n\t\t\tos.Exit(1)\n\t\t}\t\t\n\t\tfmt.Fprintf(os.Stderr, \"Report generated successfully!\\n\")\n\t}\n\n\tfmt.Fprintf(os.Stderr, \"All checks passed!\\n\")\n\tos.Exit(0)\n}\n\n// parseTools splits the comma-separated tools flag into a slice of strings.\nfunc parseTools(toolsFlag string) []string {\n\tif toolsFlag == \"\" {\n\t\treturn []string{}\n\t}\n\t// Split on comma and trim spaces\n\ttools := strings.Split(toolsFlag, \",\")\n\tfor i := range tools {\n\t\ttools[i] = strings.TrimSpace(tools[i])\n\t}\n\n\treturn tools\n}\n",
      "newCode": "package main\n\nimport (\n\t\"codeleft-cli/assessment\"\n\t\"codeleft-cli/filter\"\n\t\"codeleft-cli/read\"\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\t\"codeleft-cli/report\"\n)\n\n// Version of the CLI tool\nconst Version = \"1.0.6\"\n\n// main is the entry point for your CLI tool.\nfunc main() {\n\t// Define flags\n\tthresholdGrade := flag.String(\"threshold-grade\", \"\", \"Sets the grade threshold.\")\n\tthresholdPercent := flag.Int(\"threshold-percent\", 0, \"Sets the percentage threshold.\")\n\ttoolsFlag := flag.String(\"tools\", \"\", \"Comma-separated list of tooling (e.g., SOLID,OWASP-Top-10,Clean-Code,...)\")\n\tversionFlag := flag.Bool(\"version\", false, \"Displays the current version of the CLI tool.\")\n\tassessGrade := flag.Bool(\"asses-grade\", false, \"Assess the grade threshold.\")\n\tassessCoverage := flag.Bool(\"asses-coverage\", false, \"Assess the coverage threshold.\")\n\tcreateReport := flag.Bool(\"create-report\", false, \"Create a report of the assessment.\")\n\n\t// Customize the usage message to include version information\n\tflag.Usage = func() {\n\t\tusageText := `codeleft-cli Version ` + Version + `\n\nUsage:\n  codeleft-cli [options]\n\nOptions:\n`\n\t\tfmt.Fprintln(flag.CommandLine.Output(), usageText)\n\t\tflag.PrintDefaults()\n\t}\n\n\t// Parse command-line flags\n\tflag.Parse()\n\n\t// Handle version flag\n\tif *versionFlag {\n\t\tfmt.Fprintf(os.Stderr, \"codeleft-cli Version %s\\n\", Version)\n\t\tos.Exit(0)\n\t}\n\n\t// Convert tools into a string slice\n\tif toolsFlag == nil {\n\t\tfmt.Fprintf(os.Stderr, \"tools flag is nil\")\n\t\tos.Exit(1)\n\t}\n\ttoolsList := parseTools(*toolsFlag)\n\n\t// Initialize HistoryReader\n\thistoryReader, err := read.NewHistoryReader()\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error initializing history reader: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\t// Read history\n\thistory, err := historyReader.ReadHistory()\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error reading history: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\t// Apply filters and assessments\n\tlatestGradeFilter := filter.NewLatestGrades()\n\thistory = latestGradeFilter.FilterLatestGrades(history)\n\n\ttoolFilter := filter.NewToolFilter()\n\thistory = toolFilter.Filter(toolsList, history)\n\n\t//config filtering\n\tconfigReader, err := read.NewConfigReader()\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error initializing config reader: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\tconfig, err := configReader.ReadConfig()\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error reading config: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\tif config.Ignore.Folders != nil || config.Ignore.Files != nil {\n\t\tpathFilter := filter.NewPathFilter(config.Ignore.Files, config.Ignore.Folders)\n\t\thistory = pathFilter.Filter(history)\n\t}\n\n\t// Collect grades and assess\n\tviolationCounter := assessment.NewViolation()\n\n\tcalculator := filter.NewGradeStringCalculator()\n\tgradeCollector := filter.NewGradeCollection(calculator)\n\tgradeDetails := gradeCollector.CollectGrades(history, *thresholdGrade)\n\n\taccessorGrade := assessment.NewAccessorGrade(calculator, violationCounter)\n\tif *assessGrade && !accessorGrade.Assess(*thresholdGrade, gradeDetails) {\n\t\tfmt.Fprintf(os.Stderr, \"Grade threshold failed :( \\n\")\n\t\tos.Exit(1)\n\t}\n\n\taccessorCoverage := assessment.NewAccessorAverageCoverage(violationCounter)\n\tif *assessCoverage && !accessorCoverage.Assess(*thresholdPercent, gradeDetails) {\n\t\tfmt.Fprintf(os.Stderr, \"Coverage threshold failed :( \\n\")\n\t\tos.Exit(1)\n\t}\n\n\tif *createReport {\n\t\treporter := report.NewHtmlReport()\n\t\tif err := reporter.GenerateReport(gradeDetails, *thresholdGrade); err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Error generating report: %v\\n\", err)\n\t\t\tos.Exit(1)\n\t\t}\t\t\n\t\tfmt.Fprintf(os.Stderr, \"Report generated successfully!\\n\")\n\t}\n\n\tfmt.Fprintf(os.Stderr, \"All checks passed!\\n\")\n\tos.Exit(0)\n}\n\n// parseTools splits the comma-separated tools flag into a slice of strings.\nfunc parseTools(toolsFlag string) []string {\n\tif toolsFlag == \"\" {\n\t\treturn []string{}\n\t}\n\t// Split on comma and trim spaces\n\ttools := strings.Split(toolsFlag, \",\")\n\tfor i := range tools {\n\t\ttools[i] = strings.TrimSpace(tools[i])\n\t}\n\treturn tools\n}\n",
      "changes": [
        {
          "newCode": "\t\"codeleft-cli/report\"",
          "reason": "Added",
          "start": 12,
          "end": 12
        },
        {
          "oldCode": "\tconfigReader, err := read.NewConfigReader(read.NewOSFileSystem())",
          "newCode": "\tconfigReader, err := read.NewConfigReader()",
          "reason": "Modified",
          "start": 79,
          "end": 79
        },
        {
          "oldCode": "\tviolationCounter := assessment.NewConsoleViolationReporter()",
          "newCode": "\tviolationCounter := assessment.NewViolation()",
          "reason": "Modified",
          "start": 96,
          "end": 96
        },
        {
          "oldCode": "\taccessorGrade := assessment.NewCoverageAssessment(violationCounter)\n\tif *assessGrade && !accessorGrade.AssessCoverage(*thresholdPercent, gradeDetails) {",
          "newCode": "\taccessorGrade := assessment.NewAccessorGrade(calculator, violationCounter)\n\tif *assessGrade && !accessorGrade.Assess(*thresholdGrade, gradeDetails) {",
          "reason": "Modified",
          "start": 102,
          "end": 103
        },
        {
          "oldCode": "\taccessorCoverage := assessment.NewCoverageAssessment(violationCounter)\n\tif *assessCoverage && !accessorCoverage.AssessCoverage(*thresholdPercent, gradeDetails) {",
          "newCode": "\taccessorCoverage := assessment.NewAccessorAverageCoverage(violationCounter)\n\tif *assessCoverage && !accessorCoverage.Assess(*thresholdPercent, gradeDetails) {",
          "reason": "Modified",
          "start": 108,
          "end": 109
        }
      ]
    },
    "hash": "ade30af76fc9afdc03b8ce843ad44c3d248e45d2f4507a6253c359c6c5973f1f",
    "id": "eJytWE1v2zgQ/StTAS3k1JaTyx688CHrNG2AYBPUafdQFQhXGtlEKVIgqWy9af77YkiKkhynH9teEoXDefNm+EgOc58wY9AYLjc3SolkkVz9dbq+nt1cXc9OjpNpUqgSV0palDZZJA0rPrENQs24zGUued0obSHNZW5zN1dgZWeF4HOPW6O0eXLAXHFhUR80aWTlEwaK1pkqwTbxu47DynRfxmouN+7PCZGdz+E9asOVBFWB3SKsLi/AKiVyWShpbDQvIU9OsuPsNwdFjpQwcOO8UFq9g0ZxaaFSGnaq1REqy2XVysI5pBO4JyrzOZxhxSUCcTY0ZLcazVaJ8rVmJcJi6UzZ2lFO8yTaZxuakCdTyBP/c43W83AWiDOzPJmMoK9RFyhtBL+QdoTceDuhHo+Ag4EW+jG6UsKcC7Y5wJlMQ6YrVddsZrBhmlksQXBjXemVElxuIMVsk01hfXV5cTYNulPN7OR4uhLI5GylSpxmWTYJse/88oyi/6GUSPMkmChuxYRBCn/GTSPYzudUtFpTMe4OK6BLz6t2vCghhDP1yxHDnDqXr62IB12pO9RU04O4RbA+Bd3ZH6MXGpnFt25v7GN726zbOAPolbMAA2/r6tHv2gDv5btqjVU1/xfdpNa4MwCN+20VcFmItsRYXC4rpWtmaUVkbh2jd27yEmh3dBsjtw7qBj875rfD3R434y28jN8v4ZY4OaxFLgFGHh9UQyHNR5pz5b8Xubz1oaraZueN5tIKmTpKTp+yvOQSs6vWNq1NJ1OIlCbBj6Zek98ZVqwV1qTO8hCrc820oRVyaDMx2ujemyakfTnfMFmKvlzuJJO55RUcDTV+v0+8SpXJ1rZErWkND5bruclztw/CQMhCmezVZ27T4z3uKyXvUFu3CQxwaRUw8CcnGMELDMT6fb9cguTim+Q8IKVG56bkIsi1p3ISqfhT5ZKOh8USGqoW3UYmPYph++JdSG45EyTGN9xYpXdvkZWoybwdDkwBtSZAulCyP/Gf0XS/iLxyk559X06vtFYaeEeAahQiuhioF/D8LpQftX4yX58I8ej8B+Qj7VEyGf0KCfx/6sRywPqH6J42jdiBv7cNMFkODgsndcEsGuvOznM3y51G7ouqf9mbww7qareER66Z/zXyCdODEkgZh8LcxPH9IL1HQE+j7KYwBp/PCyUrvgm4XLr96ceeENdqYEy7wav1ORe43hmLdTr5NYoLzH5IcIF6JD3MxCnLs/95YXng79cVr4JLdrGRSmN2rkRJ+grRv3zZt3OBZo9bw+z2kBSu43h6AGR6OHJg28umR+9kM9DK6CQVAgvrm4DhBnGtC1fC3Ycr1cpAdHDXev0YJfB9N9Ff6EHFtIJMFK1gVu0l6TaH78FWcYpfSMck0DroFmxcybSH713P0DIuDDmOobLwNd6YUzgat7WBOSsKNEbp2FXtJ+47m9M4mu5Xq5Pl0bA9e/ECno2gs9NRn5Ue7XfCUximNfmmtF+P2zmoGBdYwiIFJ+6v6bojNmz6fjbtiDXMvBv85cmvHjWcP5I/sR41piGcDqr2Jyd9u4vZ1sLPSwNoOIPiLNTZa5SoI2A6zOax8n4/cIR98xDb+Ah0jvmoB8+x/YwpZxr+ejlDGUIILMG0bgWrVojds76eoX5P4pwKAcUWi08GGpJFOfAd9ngP4eHaN1NgGsFt95oYv8yGzVpoAan3o1dBeEV379pBc9a3hH7OBD58DJ3j/aGukZ6FvQ5sq2V0uH+IN9V8DmsiCkp6mu4ktZrXYBpWoIn9IqmjY+dcekZUqWmoCj3RuVMSk+65Qq6BhvvjA/8IPdKN5vWaAqWdcbgugbd/6lKRk2lScYF01SSLZP7OoDbzLUq9E6z+e163wvJG4Hz0jwz650C2UcnDf/IyUAM="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/types/model.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:05:55.101Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "1b411b63a434aa572c13faa330aaa4bfe38f9bab6bb31405421a11ec857f12d2",
    "id": "eJx1U01vm0AQ/SujPcemufpWIUXqoTWtHeUQImUNA2y77NCdQS6K/N+r5SsGJ5zQe29m3gyPN6WZkdm48khk1U7tn74eks1xn2zuv6g7lVGOMTlBJ2qnGp390SWCdA1y6lIXRRCTK0wJHhuPjE4YpEJg8W0mrUegogeyXrb9zeSgMBa3qQtdpvJBD2+pS+VYeeSKbB5Q40p4DVW7VMlEpOo1CA+Ytd5IB4vyVPZnzQ2ciOxcSgEay1KJzwhLPjvjyF5mjMf2I/Gz1TYMW846kDU5hGfRjwM8z0v8L9R5txY1A/xuy6J2MeW48jbB70KqG4v/gpulcsY/kCaePlMnnm62/zusO51aFyhd7I2YTNvVDb4b9jpuVievR/T2roteI/2tdORx1fjBWGQAeH4JbwBzi5Agnnd8IJujZ3h+WQWmGIgbB6Yf1sOXMcb9gKsQ6z6lIAQnhEGfg3HXWR4T3Fde+/6ha1xH1+l6+nyJlmpNN1qqyY6669cLMrVT0SOj56hC5zur61NUt1ZMYzEKv6bFQjaZNVH/R0Z1gLYlqct/bMFpJg=="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/types/model.go",
    "grade": "A",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:05:55.157Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "dependencyInversionScore": "A*",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "A*",
      "openClosedScore": "B",
      "singleResponsibilityScore": "A"
    },
    "hash": "b1368f696c1b955a0e7618d8323f83bb4d0bde63aa80a3fc711e9be8c71a60df",
    "id": "eJx1U11v2zAM/CuEnrv4Pa8eChTY1mzpnqoCVWza1iaLmkgjM4r890H+aux0fjLujuSRPr8pw4zM1tdPRE7t1fHxy8NndacKKjEnL+hF7VUwxW9TI0gfkLXXPssgJ1/ZGiKGiIxeGKRBYIldIV1EoGoAikG2+8XkobIOd9qnLnP5qIc37bU8NRG5IVcm1PoaXlPVXiuZCa1ek/CIRRet9LAq1/J4NhzgROSWUkrQVKYlPyOs+eKME3tZMJ7aT8T3zrg0bD3rSM6WkJ5VP07wMu8Qf6Ap+60ojPC7LYfG51TixtsMvwupDQ7/Jjdr5YJ/ID1E+p/6EOlm+z/juvOpTYXS59GKLYzb3OCr5WjysDl5O6G3d131muiH2lPETeN765AB4PklvQEsLVKCeNnxnlyJkeH5ZROYaiRuHNhh2ABfphgPA65CbIaUghCcEEZ9CdZfZ3lK8FB57fubaXEbXW/a+fMdjDRbOhhpZjvqblgvydReZT8ZI2cN+tg7056ytnNig8Ms/ZoOK/lUOJsNf2TWJmhXk7r8A7CbZ2k="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/main.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:05:55.877Z",
    "codeReview": {
      "detailedReview": {
        "tasks": [
          {
            "done": false,
            "titleTask": "openClosed",
            "violatingCode": "The `openClosed` principle is not directly violated in the provided code snippet. The code demonstrates the creation and usage of different assessment and reporting components, such as `NewConfigReader`, `NewConsoleViolationReporter`, and `NewCoverageAssessment`. The code is designed to be extensible, allowing for the addition of new assessment types or reporting mechanisms without modifying existing code.\n",
            "codeResolution": "The code demonstrates a lack of the Open/Closed Principle (OCP). The `assessment.NewCoverageAssessment` is duplicated.\n\nRefactoring Strategy:\n\nCreate a function to handle the assessment logic, accepting the `thresholdPercent` and `gradeDetails` as parameters. This reduces code duplication and makes it easier to add new assessment types without modifying the existing code.\n\n```go\nfunc assessCoverage(thresholdPercent int, gradeDetails []assessment.GradeDetail, violationCounter assessment.ViolationReporter) bool {\n    accessorCoverage := assessment.NewCoverageAssessment(violationCounter)\n    return accessorCoverage.AssessCoverage(thresholdPercent, gradeDetails)\n}\n\n// Usage\nif *assessGrade && !assessCoverage(*thresholdPercent, gradeDetails, violationCounter) {\n    // ...\n}\nif *assessCoverage && !assessCoverage(*thresholdPercent, gradeDetails, violationCounter) {\n    // ...\n}\n```\n",
            "severity": "Low",
            "rationale": "The Open/Closed Principle (OCP) is relevant here because the code's design could make it difficult to extend or modify without changing existing code. For example, if new assessment types or reporting methods are needed, the `assessment` package might require modifications. This could affect maintainability by increasing the risk of introducing bugs when changes are made. It could also affect correctness if new assessment types are not properly integrated.\n",
            "lineStart": 85,
            "lineEnd": 90,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "liskovSubstitution",
            "violatingCode": "The provided code snippet does not directly demonstrate a violation of the Liskov Substitution Principle (LSP). The LSP focuses on the substitutability of subtypes for their base types. The code shows the instantiation of different objects, such as `configReader`, `violationCounter`, and `accessorGrade`, but it does not show any inheritance or interface implementations where a subtype could potentially break the contract of its base type.\n",
            "codeResolution": "The code snippet demonstrates good adherence to the Liskov Substitution Principle (LSP). The `assessment.NewCoverageAssessment` function is used consistently, and there's no indication of subtypes behaving unexpectedly when substituted for a base type. The code is well-structured, and the use of interfaces or abstract types (implied by the `assessment` package) allows for interchangeable implementations. No specific refactoring is needed to improve LSP adherence in this context.\n",
            "severity": "Low",
            "rationale": "Rationale:\n\nThe code demonstrates good adherence to the Liskov Substitution Principle (LSP). The `assessment.NewCoverageAssessment` function is used in multiple places, and it can be substituted without breaking the code. This substitutability enhances maintainability because different implementations of the assessment can be used interchangeably. This design choice does not directly affect performance or correctness, but it does allow for flexibility in how assessments are performed.\n",
            "lineStart": 84,
            "lineEnd": 90,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "interfaceSegregation",
            "violatingCode": "The `assessment.NewCoverageAssessment` function is called twice, each time with the same `violationCounter` instance. This suggests that the `CoverageAssessment` might be taking on too many responsibilities, potentially violating the Interface Segregation Principle.\n\n```go\n84: \taccessorGrade := assessment.NewCoverageAssessment(violationCounter)\n89: \taccessorCoverage := assessment.NewCoverageAssessment(violationCounter)\n```\n",
            "codeResolution": "The `assessment.NewCoverageAssessment` is being instantiated with the same `violationCounter` in lines 84 and 89. This suggests a potential violation of the Interface Segregation Principle if `CoverageAssessment` has methods that are not strictly related to coverage assessment.\n\n**Refactoring Strategy:**\n\n1.  **Review `CoverageAssessment`:** Ensure the interface and implementation are focused solely on coverage assessment.\n2.  **Consider Separate Reporters:** If `CoverageAssessment` uses `violationCounter` for unrelated tasks, create a separate reporter specifically for coverage-related violations.\n\n**Example (Conceptual):**\n\nIf `CoverageAssessment` also handles general violation reporting, create a `CoverageViolationReporter` that implements a specific interface for coverage-related issues.\n",
            "severity": "Low",
            "rationale": "The `Interface Segregation Principle` isn't directly violated in this snippet. The code demonstrates good separation of concerns by using interfaces like `ConfigReader` and `ViolationReporter`. This design choice enhances maintainability because changes to one component (e.g., the way configuration is read) are less likely to affect others. It also improves testability, as you can easily mock these interfaces. The code's structure promotes correctness by clearly defining responsibilities.\n",
            "lineStart": 80,
            "lineEnd": 90,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "dependencyInversion",
            "violatingCode": "The `violationCounter` is a concrete implementation of `assessment.ConsoleViolationReporter` and is directly injected into `assessment.NewCoverageAssessment` on lines 80, 84, and 89. This violates the Dependency Inversion Principle because the `assessment.NewCoverageAssessment` depends on a concrete implementation instead of an abstraction.\n",
            "codeResolution": "```markdown\n**Dependency Inversion Principle (DIP) - Code Resolution**\n\nThe `assessment.NewCoverageAssessment` function is directly coupled with the `violationCounter` (concrete implementation).\n\n**Refactoring Strategy:**\n\nIntroduce an interface for `ViolationReporter` and inject the interface into `CoverageAssessment`.\n\n**Example:**\n\n```go\n// Define an interface for ViolationReporter\ntype ViolationReporter interface {\n    ReportViolation() // Example method\n}\n\n// In assessment package\ntype CoverageAssessment struct {\n    reporter ViolationReporter\n}\n\nfunc NewCoverageAssessment(reporter ViolationReporter) *CoverageAssessment {\n    return &CoverageAssessment{reporter: reporter}\n}\n\n// In main or calling function\nviolationCounter := assessment.NewConsoleViolationReporter() // Assuming this is a concrete type\naccessorGrade := assessment.NewCoverageAssessment(violationCounter)\n```\n\nThis change allows for different `ViolationReporter` implementations (e.g., a file reporter) without modifying `CoverageAssessment`.\n```\n",
            "severity": "Low",
            "rationale": "Rationale:\n\nThe code snippet demonstrates a dependency on concrete implementations of `read.NewConfigReader` and `assessment.NewCoverageAssessment`. This violates the Dependency Inversion Principle (DIP). This matters because it tightly couples the `report` package to specific implementations, hindering flexibility. If the implementations change, it could affect maintainability, as changes in the concrete classes would necessitate modifications in the `report` package. This could also affect testability, as it would be harder to mock dependencies.\n",
            "lineStart": 84,
            "lineEnd": 90,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "singleResponsibility",
            "violatingCode": "The `codeleft-cli/report` package's `assessment` package, specifically lines 80, 84, 89, and 90, shows a violation of the Single Responsibility Principle. The `NewConsoleViolationReporter` is being used by both `NewCoverageAssessment` instances. This indicates that the `assessment` package is responsible for both reporting violations and assessing coverage, which are distinct responsibilities.\n",
            "codeResolution": "The `codeResolution` is focused on improving the Single Responsibility Principle (SRP).\n\n**Analysis and Remedies:**\n\nThe `assessment.NewCoverageAssessment` is being called multiple times within the same scope. This suggests a potential violation of SRP if the repeated calls are performing distinct, unrelated tasks.\n\n**Refactoring Strategy:**\n\nConsolidate the calls to `assessment.NewCoverageAssessment` if they are performing similar operations. If they are distinct, consider creating separate functions or methods to encapsulate each assessment, improving readability and maintainability.\n\n**Example:**\n\n```go\n// Refactored code (example)\nfunc assessCoverage(thresholdPercent int, gradeDetails []string, violationCounter assessment.ViolationReporter) bool {\n    accessorCoverage := assessment.NewCoverageAssessment(violationCounter)\n    return accessorCoverage.AssessCoverage(thresholdPercent, gradeDetails)\n}\n\n// Usage\nif *assessGrade && !assessCoverage(*thresholdPercent, gradeDetails, violationCounter) {\n    // ...\n}\nif *assessCoverage && !assessCoverage(*thresholdPercent, gradeDetails, violationCounter) {\n    // ...\n}\n```\n",
            "severity": "Low",
            "rationale": "Rationale:\n\nThe `assessment.NewCoverageAssessment` is instantiated multiple times within the same scope (lines 84 and 89). This violates the Single Responsibility Principle because it suggests that the code is responsible for more than one thing. This can affect maintainability because any changes to the assessment logic would require modifications in multiple places. It could also affect performance if the instantiation is resource-intensive, as it's being done redundantly.\n",
            "lineStart": 65,
            "lineEnd": 90,
            "status": ""
          }
        ],
        "codeReviewTitle": "SOLID Code Review"
      }
    },
    "gradingDetails": {
      "dependencyInversionScore": "B",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "B",
      "openClosedScore": "B",
      "singleResponsibilityScore": "B"
    },
    "codeDiff": {
      "oldCode": "package main\n\nimport (\n\t\"codeleft-cli/assessment\"\n\t\"codeleft-cli/filter\"\n\t\"codeleft-cli/read\"\n\t\"codeleft-cli/report\"\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\n// Version of the CLI tool\nconst Version = \"1.0.6\"\n\n// main is the entry point for your CLI tool.\nfunc main() {\n\t// Define flags\n\tthresholdGrade := flag.String(\"threshold-grade\", \"\", \"Sets the grade threshold.\")\n\tthresholdPercent := flag.Int(\"threshold-percent\", 0, \"Sets the percentage threshold.\")\n\ttoolsFlag := flag.String(\"tools\", \"\", \"Comma-separated list of tooling (e.g., SOLID,OWASP-Top-10,Clean-Code,...)\")\n\tversionFlag := flag.Bool(\"version\", false, \"Displays the current version of the CLI tool.\")\n\tassessGrade := flag.Bool(\"asses-grade\", false, \"Assess the grade threshold.\")\n\tassessCoverage := flag.Bool(\"asses-coverage\", false, \"Assess the coverage threshold.\")\n\tcreateReport := flag.Bool(\"create-report\", false, \"Create a report of the assessment.\")\n\n\t// Customize the usage message to include version information\n\tflag.Usage = func() {\n\t\tusageText := `codeleft-cli Version ` + Version + `\n\nUsage:\n  codeleft-cli [options]\n\nOptions:\n`\n\t\tfmt.Fprintln(flag.CommandLine.Output(), usageText)\n\t\tflag.PrintDefaults()\n\t}\n\n\t// Parse command-line flags\n\tflag.Parse()\n\n\t// Handle version flag\n\tif *versionFlag {\n\t\tfmt.Fprintf(os.Stderr, \"codeleft-cli Version %s\\n\", Version)\n\t\tos.Exit(0)\n\t}\n\n\t// Convert tools into a string slice\n\tif toolsFlag == nil {\n\t\tfmt.Fprintf(os.Stderr, \"tools flag is nil\")\n\t\tos.Exit(1)\n\t}\n\ttoolsList := parseTools(*toolsFlag)\n\n\t// Initialize HistoryReader\n\thistoryReader, err := read.NewHistoryReader()\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error initializing history reader: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\t// Read history\n\thistory, err := historyReader.ReadHistory()\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error reading history: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\t// Apply filters and assessments\n\tlatestGradeFilter := filter.NewLatestGrades()\n\thistory = latestGradeFilter.FilterLatestGrades(history)\n\n\ttoolFilter := filter.NewToolFilter()\n\thistory = toolFilter.Filter(toolsList, history)\n\n\t//config filtering\n\tconfigReader, err := read.NewConfigReader(read.NewOSFileSystem())\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error initializing config reader: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\tconfig, err := configReader.ReadConfig()\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error reading config: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\tif config.Ignore.Folders != nil || config.Ignore.Files != nil {\n\t\tpathFilter := filter.NewPathFilter(config.Ignore.Files, config.Ignore.Folders)\n\t\thistory = pathFilter.Filter(history)\n\t}\n\n\t// Collect grades and assess\n\tviolationCounter := assessment.NewConsoleViolationReporter()\n\n\tcalculator := filter.NewGradeStringCalculator()\n\tgradeCollector := filter.NewGradeCollection(calculator)\n\tgradeDetails := gradeCollector.CollectGrades(history, *thresholdGrade)\n\n\taccessorGrade := assessment.NewCoverageAssessment(violationCounter)\n\tif *assessGrade && !accessorGrade.AssessCoverage(*thresholdPercent, gradeDetails) {\n\t\tfmt.Fprintf(os.Stderr, \"Grade threshold failed :( \\n\")\n\t\tos.Exit(1)\n\t}\n\n\taccessorCoverage := assessment.NewCoverageAssessment(violationCounter)\n\tif *assessCoverage && !accessorCoverage.AssessCoverage(*thresholdPercent, gradeDetails) {\n\t\tfmt.Fprintf(os.Stderr, \"Coverage threshold failed :( \\n\")\n\t\tos.Exit(1)\n\t}\n\n\tif *createReport {\n\t\treporter := report.NewHtmlReport()\n\t\tif err := reporter.GenerateReport(gradeDetails, *thresholdGrade); err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Error generating report: %v\\n\", err)\n\t\t\tos.Exit(1)\n\t\t}\t\t\n\t\tfmt.Fprintf(os.Stderr, \"Report generated successfully!\\n\")\n\t}\n\n\tfmt.Fprintf(os.Stderr, \"All checks passed!\\n\")\n\tos.Exit(0)\n}\n\n// parseTools splits the comma-separated tools flag into a slice of strings.\nfunc parseTools(toolsFlag string) []string {\n\tif toolsFlag == \"\" {\n\t\treturn []string{}\n\t}\n\t// Split on comma and trim spaces\n\ttools := strings.Split(toolsFlag, \",\")\n\tfor i := range tools {\n\t\ttools[i] = strings.TrimSpace(tools[i])\n\t}\n\n\treturn tools\n}\n",
      "newCode": "package main\n\nimport (\n\t\"codeleft-cli/assessment\"\n\t\"codeleft-cli/filter\"\n\t\"codeleft-cli/read\"\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\t\"codeleft-cli/report\"\n)\n\n// Version of the CLI tool\nconst Version = \"1.0.6\"\n\n// main is the entry point for your CLI tool.\nfunc main() {\n\t// Define flags\n\tthresholdGrade := flag.String(\"threshold-grade\", \"\", \"Sets the grade threshold.\")\n\tthresholdPercent := flag.Int(\"threshold-percent\", 0, \"Sets the percentage threshold.\")\n\ttoolsFlag := flag.String(\"tools\", \"\", \"Comma-separated list of tooling (e.g., SOLID,OWASP-Top-10,Clean-Code,...)\")\n\tversionFlag := flag.Bool(\"version\", false, \"Displays the current version of the CLI tool.\")\n\tassessGrade := flag.Bool(\"asses-grade\", false, \"Assess the grade threshold.\")\n\tassessCoverage := flag.Bool(\"asses-coverage\", false, \"Assess the coverage threshold.\")\n\tcreateReport := flag.Bool(\"create-report\", false, \"Create a report of the assessment.\")\n\n\t// Customize the usage message to include version information\n\tflag.Usage = func() {\n\t\tusageText := `codeleft-cli Version ` + Version + `\n\nUsage:\n  codeleft-cli [options]\n\nOptions:\n`\n\t\tfmt.Fprintln(flag.CommandLine.Output(), usageText)\n\t\tflag.PrintDefaults()\n\t}\n\n\t// Parse command-line flags\n\tflag.Parse()\n\n\t// Handle version flag\n\tif *versionFlag {\n\t\tfmt.Fprintf(os.Stderr, \"codeleft-cli Version %s\\n\", Version)\n\t\tos.Exit(0)\n\t}\n\n\t// Convert tools into a string slice\n\tif toolsFlag == nil {\n\t\tfmt.Fprintf(os.Stderr, \"tools flag is nil\")\n\t\tos.Exit(1)\n\t}\n\ttoolsList := parseTools(*toolsFlag)\n\n\t// Initialize HistoryReader\n\thistoryReader, err := read.NewHistoryReader()\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error initializing history reader: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\t// Read history\n\thistory, err := historyReader.ReadHistory()\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error reading history: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\t// Apply filters and assessments\n\tlatestGradeFilter := filter.NewLatestGrades()\n\thistory = latestGradeFilter.FilterLatestGrades(history)\n\n\ttoolFilter := filter.NewToolFilter()\n\thistory = toolFilter.Filter(toolsList, history)\n\n\t//config filtering\n\tconfigReader, err := read.NewConfigReader()\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error initializing config reader: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\tconfig, err := configReader.ReadConfig()\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Error reading config: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\tif config.Ignore.Folders != nil || config.Ignore.Files != nil {\n\t\tpathFilter := filter.NewPathFilter(config.Ignore.Files, config.Ignore.Folders)\n\t\thistory = pathFilter.Filter(history)\n\t}\n\n\t// Collect grades and assess\n\tviolationCounter := assessment.NewViolation()\n\n\tcalculator := filter.NewGradeStringCalculator()\n\tgradeCollector := filter.NewGradeCollection(calculator)\n\tgradeDetails := gradeCollector.CollectGrades(history, *thresholdGrade)\n\n\taccessorGrade := assessment.NewAccessorGrade(calculator, violationCounter)\n\tif *assessGrade && !accessorGrade.Assess(*thresholdGrade, gradeDetails) {\n\t\tfmt.Fprintf(os.Stderr, \"Grade threshold failed :( \\n\")\n\t\tos.Exit(1)\n\t}\n\n\taccessorCoverage := assessment.NewAccessorAverageCoverage(violationCounter)\n\tif *assessCoverage && !accessorCoverage.Assess(*thresholdPercent, gradeDetails) {\n\t\tfmt.Fprintf(os.Stderr, \"Coverage threshold failed :( \\n\")\n\t\tos.Exit(1)\n\t}\n\n\tif *createReport {\n\t\treporter := report.NewHtmlReport()\n\t\tif err := reporter.GenerateReport(gradeDetails, *thresholdGrade); err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Error generating report: %v\\n\", err)\n\t\t\tos.Exit(1)\n\t\t}\t\t\n\t\tfmt.Fprintf(os.Stderr, \"Report generated successfully!\\n\")\n\t}\n\n\tfmt.Fprintf(os.Stderr, \"All checks passed!\\n\")\n\tos.Exit(0)\n}\n\n// parseTools splits the comma-separated tools flag into a slice of strings.\nfunc parseTools(toolsFlag string) []string {\n\tif toolsFlag == \"\" {\n\t\treturn []string{}\n\t}\n\t// Split on comma and trim spaces\n\ttools := strings.Split(toolsFlag, \",\")\n\tfor i := range tools {\n\t\ttools[i] = strings.TrimSpace(tools[i])\n\t}\n\treturn tools\n}\n",
      "changes": [
        {
          "newCode": "\t\"codeleft-cli/report\"",
          "reason": "Added",
          "start": 12,
          "end": 12,
          "grade": "B"
        },
        {
          "oldCode": "\tconfigReader, err := read.NewConfigReader(read.NewOSFileSystem())",
          "newCode": "\tconfigReader, err := read.NewConfigReader()",
          "reason": "Modified",
          "start": 79,
          "end": 79,
          "grade": "B"
        },
        {
          "oldCode": "\tviolationCounter := assessment.NewConsoleViolationReporter()",
          "newCode": "\tviolationCounter := assessment.NewViolation()",
          "reason": "Modified",
          "start": 96,
          "end": 96,
          "grade": "B"
        },
        {
          "oldCode": "\taccessorGrade := assessment.NewCoverageAssessment(violationCounter)\n\tif *assessGrade && !accessorGrade.AssessCoverage(*thresholdPercent, gradeDetails) {",
          "newCode": "\taccessorGrade := assessment.NewAccessorGrade(calculator, violationCounter)\n\tif *assessGrade && !accessorGrade.Assess(*thresholdGrade, gradeDetails) {",
          "reason": "Modified",
          "start": 102,
          "end": 103,
          "grade": "B"
        },
        {
          "oldCode": "\taccessorCoverage := assessment.NewCoverageAssessment(violationCounter)\n\tif *assessCoverage && !accessorCoverage.AssessCoverage(*thresholdPercent, gradeDetails) {",
          "newCode": "\taccessorCoverage := assessment.NewAccessorAverageCoverage(violationCounter)\n\tif *assessCoverage && !accessorCoverage.Assess(*thresholdPercent, gradeDetails) {",
          "reason": "Modified",
          "start": 108,
          "end": 109,
          "grade": "B"
        }
      ]
    },
    "hash": "086f47d53e93e945ae875fe22a4a02371c7622595afb1c4f43a45c90587d3da5",
    "id": "eJytWE1v2zgQ/StTAS3k1JbTyx688CHrNG2AYBPUafcQFQhXGtlEKVIgqWy9af77YkiKkhynH9teEoXDefNm+EgOc58wY9AYLjfXSolkkawvL85Pk2lSqBJXSlqUNlkkDSs+sQ1CzbjMZS553ShtIc1lbnM3V2BlZ4Xgcw9Yo7R5csBccWFRHzRpZOUTBorWmSrBNvG7jsPKdF/Gai437s8JkZ3P4QNqw5UEVYHdIqwuzsEqJXJZKGlsNC8hT15lx9lvDoocKWHgxnmhtHoHjeLSQqU07FSrI1SWy6qVhXNIJ3BPVOZzOMWKSwTibGjIbjWarRLlG81KhMXSmbK1o5zmSbTPNjQhT6aQJ/7nGq3n4SwQZ2Z5MhlBX6EuUNoIfi7tCLnxdkI9HgEHAy30Y3SlhDkTbHOAM5mGTFeqrtnMYMM0s1iC4Ma60isluNxAitkmm4KT2vTyr5P11exaNbNXx9OVQCZnK1XiNMuySYh955dnFP0PpUSaJ8FEcSsmDFL4U24awXY+p6LVmopxd1gBXXpeteNFCSGcqV+OGObEuXxtRTzoSt2hppoexC2C9Snozv4YvdDILL5ze2Mf29tm3cYZQK+cBRh4W1ePftcGeC/fVWusqvm/6Ca1xp0BaNxvq4DLQrQlxuJyWSldM0srInPrGL13k5dAu6PbGLl1UNf42TG/He72uBlv4WX8fgm3xMlhLXIJMPK4UQ2FNB9pzqX/XuTy1oeqapudNZpLK2TqKDl9yvKCS8wuW9u0Np1MIVKaBD+aekV+p1ixVliTOstDrM4V04ZWyKHNxGije2+akPblfMtkKfpyuZNM5pZXcDTU+P0+8SpVJlvbErWmNTxYrucmz90+CAMhC2Wy15+5TY/3uK+UvENt3SYwwKVVwMCfnGAELzAQ6/f9cgmSi2+S84CUGp2bkosg157Kq0jFnyoXdDwsltBQtegaMulRDNsX71xyy5kgMb7lxiq9e4esRE3m7XBgCqg1AdKFkv2J/4ym+0XklZv07Ptyeq210sA7AlSjENHFQL2A53eh/Kj1k/n6RIhH5z8gH2mPksnoV0jg/1MnlgPWP0T3pGnEDvy9bYDJcnBYOKkLZtFYd3aeuVnuNHJfVP2L3hx2UFe7JTxyzfyvkU+YHpRAyjgU5jqO7wfpPQJ6GmU3hTH4fF4oWfFNwOXS7U8/9oS4VgNj2g1ers+4wPXOWKzTya9RXGD2Q4IL1CPpYSZOWZ79zwvLA3+/rngVXLLzjVQaszMlStJXiP7ly76dCzR73Bpmt4ekcBXH0wMg08ORA9teNj16J5uBVkYnqRBYWN8EDDeIa124Eu4+XKlWBqKDu9brxyiBH7qJ/kIPKqYVZKJoBbNqL0m3OXwPtopT/EI6JoHWQbdg40qmPXzveoqWcWHIcQyVha/xxpzC0bitDcxZUaAxSseuaj9x39mcxNF0v1qdLI+G7dmLF/BsBJ2djPqs9Gi/E57CMK3JN6X9ZtzOQcW4wBIWKThxf03XHbFh0/ezaUesYebd4C9PfvWo4fyR/In1qDEN4XRQtT856dtdzLYWfl4aQMMZFGehzt6gRB0B02E2j5X3+4Ej7JuH2MZHoHPMRz14ju1nTDnT8NfLGcoQQmAJpnUrWLVC7J719Qz1exLnRAgotlh8MtCQLMqB77DHewgP176ZAtMIbrvXxPhlNmzWQgtIvR+9CsIrunvXDpqzviX0cyZw8zF0jveHukZ6FvY6sK2W0eH+Id5U8zmsiSgo6Wm6k9RqXoNpWIEm9oukjo6dc+kZUaWmoSr0ROdOSUy65wq5Bhrujxv+EXqka83rNQVKO+NwXQJv/9SlIifTpOIC6apJFsn8vUFt5luUeidY/fe8boXljcD56B8Z9M+BbKOSh/8AeyVORg=="
  },
  {
    "assessingTool": "Complexity",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/types/model.go",
    "grade": "A",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:05:56.807Z",
    "codeReview": {
      "review": "Congratulations! Your most recent code changes passed."
    },
    "gradingDetails": {
      "grades": {
        "maintainabilityIndex": "A+",
        "qualityDesign": "A+",
        "readability": "A+",
        "testability": "A-"
      },
      "issues": {
        "cyclomaticComplexity": 0,
        "dependenciesModules": 0,
        "functionMethodCounts": 1,
        "linesOfCode": 31,
        "nestingDepth": 0
      }
    },
    "hash": "4ffd359c650e0ed2dcd899804073aff2b35a587f2a36d0fd83c9a5cf5815143e",
    "id": "eJx1U8tu2zAQ/JUFz6l191VAgBzSukl6CgOEllYSE4qrcFdwhMD/XpB6xJJbnoiZ2SeHX8owI7P19RORU3uVU9s5/LQyqBtVUIk5eUEvaq86U7ybGkGGDll77bMMcvKVrSFgF5DRC4M0CCyhL6QPCFQloEiy3RuTh8o63Gkfs8zhox6+tNfy1ATkhlwZUetreI1Re61kJrR6jcJHLPpgZYBVuJZfJ8MdHIncEkoRmsK05CeENV+ccGLPC8ZT+on43RsXi61rPZKzJcSzyscRXuodwgOactiKuhH+bsuh8TmVuOlthr+FyxNtlAv+D+kh0P/Uh0BX03+M486rNhXKkAcrtjBus4N7y8Hk3Wbl7YRe73WVa6Lvak8BN4lvrUMGgOeXeANYUkQH8TLjLbkSA8Pzy8Yw1UhcdWBTsQSfJxunAhcmNsmlIARHhFFfgvWXXp4cnCIv+/5pWtxa15t2fr6DkWZLd0aauR11k8aLMrVX2R/GwFmDPgzOtMes7Z3YzmEWv6bDSn4UzmbpR2ZthHY1qfNf9QlqHA=="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/model.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:05:56.859Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "8c19ab4bca04d647d7719eba01aafe8bb049f114ff17f258df3774a1b7a9fe79",
    "id": "eJyFk02L2zAQhv/KoJMNTtxeAz1st7RbKGxoUnqIAqu1x/ak+jDSuEtY9r8XOYrXKc3WF4PmeV7JmvGzUCFgCGTbrXNarMT9z5vNerG9Xy/evxOFqFyNt84yWhYr0avql2oRGtKMXlppyfTOM2TSSpaCyaAU0uaxxMce4Y4CO3+EwH6oGJ4jdzPfEmKJbAvn5+EQnF3Jy4NJ8RDNz6RxrbhL6BWzSVSSvnhV4wRdk9pIJeNHQG+VwbeNIVFJ2pLBDSvTn6h4Fcu4dinxmUrWravxO/4mfBoxo/rdabu9ssfJqiZq9k1k20/IinS4prUXVFLvVOjgv9fRqXC+v681SJZ8FaV6BF/+6jlhgN0+9T/WmsFWkHWv5Ry+oc1yIJsGwyMP3oJGm3V5SvynFUJGBRyimcNjnKK53+1ov5zasfyIjfOYdbvDbPWN+M2T6mfxY3KMLCBGwIfxVYy7jCGimCZOrEQZhyeUHVp/1Mo8lmbQTL3GMjZRY8OLSlN5+oNKE9eWrRMvfwCMOTN5"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/model.go",
    "grade": "A",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:05:56.913Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "dependencyInversionScore": "B",
      "interfaceSegregationScore": "A*",
      "liskovSubstitutionScore": "A*",
      "openClosedScore": "B",
      "singleResponsibilityScore": "B"
    },
    "hash": "9de394bbe878c7849fc21ccb46cf81f39e49f1e57316817a17df57a087b566a9",
    "id": "eJyFk1Fr2zAQx7/KoScbvPg9sIetZWuh0LJ0T1Ggqn22L5NPRjqvhNLvPuQonlOWzi8G3e/3l6w7vyoTAoZA3D46Z9Vabe7vbq9VoSpX45VjQRa1VoOpfpkWoSEr6DVrpn5wXiDTrEUroR610pzHkhwGhBsK4vwBgvixEniN3JflXhBLxC2cnqd9cLzW5yfS6ima38jig5EuoRfMJlFJ+u5NjTN0SWojlYyfAT2bHj82xkQl6ZF63IjphyMVr2IV184lOVHJunI1/sDfhC8T1pthe9xuZ/gwW9VMLb6JuL1GMWTDJa09o5J6Y0IH/72OzoTT/d3WoEXLRZTqCXx713PCANtd6n+sNSNXkHV/yzncIWc5EKfB8CijZ7DIWZenxH9aIWRUwD6aOTzHKVr63ZZ2q7kdq6/YOI9Zt90vVj+I37yYYRE/JcfIAmIEfJ5exbTLFKKKeeLUWpVxeELZIfuDNf1z2Y9WaLBYxiZabORTZak8/kFlH9dWrVNvfwBZdTG8"
  },
  {
    "assessingTool": "Complexity",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/main.go",
    "grade": "B+",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:05:58.023Z",
    "codeReview": {
      "detailedReview": {
        "tasks": [
          {
            "done": false,
            "titleTask": "qualityDesign",
            "violatingCode": "The `main` function in the provided code snippet demonstrates a lack of modularity and potential code duplication, specifically in lines 103 and 109. The `assessment.NewCoverageAssessment` is instantiated twice, and the `AssessCoverage` method is called with the same parameters in both instances. This duplication could be refactored to improve code design.\n",
            "codeResolution": "The `codeResolution` for qualityDesign focuses on improving the error handling and separation of concerns. The current code uses `fmt.Fprintf(os.Stderr, ...)` repeatedly for error reporting, which can be improved by centralizing error handling.\n\nRefactoring Strategy: Create a dedicated error handling function to reduce code duplication and improve readability.\n\n```go\n// Helper function to handle errors\nfunc handleError(err error, message string) {\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"%s: %v\\n\", message, err)\n        os.Exit(1)\n    }\n}\n\n// Example of how to use the new function\nhistoryReader, err := read.NewHistoryReader()\nhandleError(err, \"Error initializing history reader\")\n```\n",
            "severity": "Low",
            "rationale": "The code's structure, particularly the `main` function, exhibits a lack of modularity, which impacts design quality. The `main` function's length and the number of responsibilities it handles make it harder to understand, test, and maintain. This monolithic design can affect maintainability because changes in one part of the function may have unintended consequences elsewhere. Performance could be indirectly affected if the function becomes a bottleneck due to its size. Correctness is also at risk, as the complexity increases the likelihood of introducing bugs.\n",
            "lineStart": 96,
            "lineEnd": 119,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "readability",
            "violatingCode": "The code snippet demonstrates a potential issue in error handling and flag handling. Specifically, the code checks if `toolsFlag` is nil and exits if it is, but this check is redundant because `flag.String` will never return nil.\n\nKey lines:\n```go\n51: \tif toolsFlag == nil {\n52: \t\tfmt.Fprintf(os.Stderr, \"tools flag is nil\")\n53: \t\tos.Exit(1)\n54: \t}\n```\n",
            "codeResolution": "The `parseTools` function (lines 127-139) can be improved for readability. The current implementation checks for an empty string and returns an empty slice. The loop to trim spaces could be simplified using `strings.Fields` which handles splitting and trimming in one step.\n\n```go\nfunc parseTools(toolsFlag string) []string {\n\tif toolsFlag == \"\" {\n\t\treturn []string{}\n\t}\n\treturn strings.Fields(toolsFlag)\n}\n```\n",
            "severity": "Low",
            "rationale": "The `parseTools` function (lines 127-139) is crucial for processing user input. Its readability is enhanced by clear logic and comments. This function's correctness directly impacts the program's ability to filter tools correctly. Poorly written parsing logic could lead to incorrect filtering, affecting the accuracy of assessments and reports.\n",
            "lineStart": 20,
            "lineEnd": 139,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "testability",
            "violatingCode": "The code snippet that demonstrates the issue for testability is primarily within the `main` function, specifically lines 45-48, 50-54, 58-62, 65-69, 79-83, 84-88, 103-106, 108-112, 116-119, and 123-124. These lines contain direct calls to `os.Exit(0)` or `os.Exit(1)` which makes it difficult to test the different execution paths within the `main` function.\n",
            "codeResolution": "To improve testability, the `main` function's logic should be refactored to extract the core functionality into separate, testable functions. This involves isolating the steps of flag parsing, history reading, filtering, assessment, and report generation.\n\nFor example, the flag parsing logic (lines 20-42) could be moved into a function like `parseFlags()`, which returns a struct containing the flag values. This allows for testing the flag parsing logic in isolation.\n\n```go\nfunc parseFlags() (thresholdGrade string, thresholdPercent int, tools string, version bool, assessGrade bool, assessCoverage bool, createReport bool) {\n\tflag.Parse()\n\treturn *thresholdGrade, *thresholdPercent, *tools, *version, *assessGrade, *assessCoverage, *createReport\n}\n```\n",
            "severity": "Low",
            "rationale": "The `parseTools` function (lines 127-139) is a good example of a small, focused function. This function's simplicity makes it easy to test in isolation. The rationale is that it is easier to test and maintain. This function's correctness directly impacts the application's ability to correctly parse the tools flag, which affects the filtering of results.\n",
            "lineStart": 58,
            "lineEnd": 119,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "maintainabilityIndex",
            "violatingCode": "The `main` function (lines 18-125) contains a significant amount of logic, including flag parsing, history reading, filtering, assessment, and report generation. The function's length and the variety of responsibilities it handles make it difficult to maintain. The use of `os.Exit(1)` in multiple places (lines 53, 61, 68, 82, 87, 105, 111, 118, 124) for error handling, scattered throughout the function, also reduces maintainability.\n",
            "codeResolution": "To improve maintainability, consider refactoring the `main` function to break down large blocks of code into smaller, more manageable functions. This will improve readability and make it easier to understand and modify specific parts of the program.\n\nFor example, lines 57-69, which handle the initialization and reading of history, could be extracted into a separate function:\n\n```go\nfunc readHistory(reader read.HistoryReader) ([]HistoryEntry, error) {\n\thistory, err := reader.ReadHistory()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error reading history: %w\", err)\n\t}\n\treturn history, nil\n}\n```\n\nThis approach encapsulates the logic, making the `main` function cleaner and easier to follow. Similar refactoring can be applied to other sections, such as flag parsing and report generation.\n",
            "severity": "Medium",
            "rationale": "The `parseTools` function (lines 127-139) is crucial for parsing user input. Its structure directly impacts maintainability. If the parsing logic becomes more complex (e.g., adding validation or handling different delimiters), the function could become harder to understand and modify. This could affect correctness if parsing errors are not handled robustly, and performance if the string manipulation is inefficient.\n",
            "lineStart": 18,
            "lineEnd": 139,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "linesOfCode",
            "violatingCode": "The `main` function contains a significant number of lines dedicated to error handling using `fmt.Fprintf(os.Stderr, \"Error message: %v\\n\", err)` followed by `os.Exit(1)`. This pattern is repeated multiple times throughout the function, increasing the lines of code. For example, lines 58-62, 65-69, 79-83, 84-88, 116-119.\n",
            "codeResolution": "The `parseTools` function (lines 127-139) can be refactored to reduce lines of code and improve readability. The current implementation checks for an empty string and then proceeds to split and trim. This can be simplified by directly splitting and trimming, and then returning an empty slice if the input is empty after trimming.\n\n```go\nfunc parseTools(toolsFlag string) []string {\n\ttools := strings.Split(toolsFlag, \",\")\n\tvar result []string\n\tfor _, tool := range tools {\n\t\ttrimmedTool := strings.TrimSpace(tool)\n\t\tif trimmedTool != \"\" {\n\t\t\tresult = append(result, trimmedTool)\n\t\t}\n\t}\n\treturn result\n}\n```\n",
            "severity": "Critical",
            "rationale": "The `linesOfCode` metric is a direct indicator of code complexity. A higher `linesOfCode` count, as seen in the provided code, can negatively impact maintainability. More lines of code mean more code to read, understand, and debug. This can also affect performance if the code contains inefficiencies or redundant operations. While not directly impacting correctness, a large codebase increases the chances of introducing errors during modifications.\n",
            "lineStart": 18,
            "lineEnd": 140,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "functionMethodCounts",
            "violatingCode": "The code defines two functions: `main` and `parseTools`. The `main` function is the entry point and contains the core logic, including flag parsing, history reading, filtering, assessment, and report generation. The `parseTools` function is used to parse the tools flag.\n",
            "codeResolution": "The `functionMethodCounts` metric can be improved by reducing the number of functions and methods. The `main` function is quite long and could be refactored to improve readability and maintainability.\n\nRefactoring Strategy:\n\n1.  **Extract Logic:** Break down the `main` function into smaller, more focused functions. For example, the flag parsing, history reading, filtering, and report generation could each be in their own function.\n2.  **Reduce Nesting:** Simplify conditional logic to reduce nesting depth.\n\nExample:\n\n```go\nfunc main() {\n\t// ... flag definitions ...\n\tflag.Parse()\n\n\tif *versionFlag {\n\t\tdisplayVersion()\n\t\treturn\n\t}\n\n\ttoolsList := parseTools(*toolsFlag)\n\thistory, err := readHistory()\n\tif err != nil {\n\t\thandleError(\"Error reading history\", err)\n\t\treturn\n\t}\n\t// ... rest of the logic ...\n}\n\nfunc displayVersion() {\n\tfmt.Fprintf(os.Stderr, \"codeleft-cli Version %s\\n\", Version)\n\tos.Exit(0)\n}\n```\n",
            "severity": "Critical",
            "rationale": "The `functionMethodCounts` metric reflects the number of functions and methods in the code. A high count, as seen in the provided code, can indicate a lack of modularity. This can affect maintainability because changes or bug fixes might require modifications across multiple functions. It can also impact performance if functions are overly complex or perform redundant operations.\n",
            "lineStart": 18,
            "lineEnd": 139,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "dependenciesModules",
            "violatingCode": "The code imports several modules, indicating dependencies on external packages.\n\n```go\nimport (\n\t\"codeleft-cli/assessment\"\n\t\"codeleft-cli/filter\"\n\t\"codeleft-cli/read\"\n\t\"codeleft-cli/report\"\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n```\n",
            "codeResolution": "The code imports several modules, increasing dependencies. To improve `dependenciesModules`, consider these strategies:\n\n*   **Dependency Injection:** Pass dependencies as arguments to functions or structs, reducing direct imports.\n*   **Interface Abstraction:** Define interfaces for external dependencies, allowing for easier mocking and testing.\n*   **Module Grouping:** If possible, group related functionalities into fewer, more cohesive modules.\n\nExample:\n\n```go\n// Before\nimport (\n\t\"codeleft-cli/assessment\"\n\t\"codeleft-cli/filter\"\n\t\"codeleft-cli/read\"\n\t\"codeleft-cli/report\"\n)\n\n// After (Dependency Injection Example)\ntype App struct {\n    historyReader read.HistoryReader\n    // ... other dependencies\n}\n\nfunc NewApp(hr read.HistoryReader) *App {\n    return &App{historyReader: hr}\n}\n```\n",
            "severity": "Critical",
            "rationale": "The high number of dependencies (lines 4, 5, 6, 7) increases the complexity of the codebase. This can make it harder to understand the flow of data and logic, thus affecting maintainability. Each dependency introduces potential points of failure, which can impact correctness. Changes in one dependency could necessitate changes in others, increasing the risk of introducing bugs and making debugging more difficult.\n",
            "lineStart": 4,
            "lineEnd": 12,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "nestingDepth",
            "violatingCode": "The code demonstrates a moderate level of nesting depth, particularly in the `main` function. The nested `if` statements, such as the ones checking `*assessGrade` and `*assessCoverage`, contribute to this.\n\nSpecifically, lines 103-106 and 109-112 show nested `if` statements that could be refactored to reduce nesting depth.\n",
            "codeResolution": "The `main` function exhibits moderate nesting depth due to the series of `if` statements and error checks. To reduce nesting, consider early returns for error conditions and refactoring long conditional blocks into separate functions.\n\nFor example, lines 58-62, 65-69, 79-83, 84-88, 116-119 can be refactored to reduce nesting.\n\n```go\n// Example of refactoring error handling with early returns\nhistoryReader, err := read.NewHistoryReader()\nif err != nil {\n    handleError(fmt.Errorf(\"Error initializing history reader: %w\", err))\n}\n```\n\n```go\nfunc handleError(err error) {\n    fmt.Fprintf(os.Stderr, \"%v\\n\", err)\n    os.Exit(1)\n}\n```\n",
            "severity": "Critical",
            "rationale": "Nesting depth, as seen in the `main` function, can make the code harder to understand and maintain. Deeply nested `if` statements or loops increase cognitive load, making it difficult to follow the control flow. This can lead to errors, as developers may miss conditions or misunderstand the logic. It also makes it harder to modify the code without introducing bugs.\n",
            "lineStart": 45,
            "lineEnd": 119,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "cyclomaticComplexity",
            "violatingCode": "The `main` function contains several conditional statements (`if`) that contribute to its cyclomatic complexity. Specifically, lines 45, 51, 90, 103, 109, and 114 introduce decision points. Each `if` statement adds to the complexity by creating alternative execution paths based on the evaluation of boolean expressions.\n",
            "codeResolution": "The `main` function has high cyclomatic complexity due to multiple `if` statements and nested logic.\n\nRefactoring strategy: Extract logic into separate functions to reduce complexity.\n\nExample:\n\n```go\n// main function\nif *assessGrade && !accessorGrade.AssessCoverage(*thresholdPercent, gradeDetails) {\n    fmt.Fprintf(os.Stderr, \"Grade threshold failed :( \\n\")\n    os.Exit(1)\n}\n```\n\ncan be refactored to:\n\n```go\n// main function\nif !assessGradeThreshold(accessorGrade, *thresholdPercent, gradeDetails) {\n    os.Exit(1)\n}\n\n// Helper function\nfunc assessGradeThreshold(accessorGrade *assessment.CoverageAssessment, thresholdPercent int, gradeDetails []filter.GradeDetails) bool {\n    if *assessGrade && !accessorGrade.AssessCoverage(thresholdPercent, gradeDetails) {\n        fmt.Fprintf(os.Stderr, \"Grade threshold failed :( \\n\")\n        return false\n    }\n    return true\n}\n```\n",
            "severity": "Critical",
            "rationale": "The code's structure, particularly within the `main` function, exhibits a moderate level of cyclomatic complexity due to the numerous `if` statements and nested conditions. This complexity can affect maintainability by making the code harder to understand and modify. It could also potentially impact correctness, as complex conditional logic increases the risk of introducing bugs.\n",
            "lineStart": 45,
            "lineEnd": 119,
            "status": ""
          }
        ],
        "codeReviewTitle": "Complexity Code Review"
      }
    },
    "gradingDetails": {
      "grades": {
        "maintainabilityIndex": "C+",
        "qualityDesign": "B+",
        "readability": "B",
        "testability": "B"
      },
      "issues": {
        "cyclomaticComplexity": 45,
        "dependenciesModules": 60,
        "functionMethodCounts": 30,
        "linesOfCode": 140,
        "nestingDepth": 45
      }
    },
    "hash": "982165dd077199cf9782d67c4892ef31f5704945bfae225f029e54fcdc1aa518",
    "id": "eJytWN9v2zgM/lc4AxucLnG6l3vIIQ+9dN0KFNdi6XYP84DqbDoRJkuGJPea6/q/HyjJsp2m+3HbS+uK5MePFEVRvU+YMWgMl5trpUSySFaqbgTecbtLpkmhSlwpaVHaZJE0rPjMNgg14zKXueR1o7SFNJe5zZ2uwMrOCsHnHrVGafPkgLjiwqI+KNLIyicE5K0TVYJt4ncdl5XpvozVXG7cnxMiO5/DB9SGKwmqArtFWF2cg1VK5LJQ0tgoXkKevMqOs98cFBlSwMCNs0Jp9Q4axaWFSmnYqVZHqCyXVSsLZ5BO4J6ozOdwihWXCMTZ0JLdajRbJco3mpUIi6UTZWtHOc2TKJ9tSCFPppAn/ucarefhJBA1szyZjKCvUBcobQQ/l3aE3Hg5oR6PgIOANvoxulLCnAm2OcCZREOmK1XXbGawYZpZLEFwY13qlRJcbiDFbJNNYX15cX46vfzrZH01u1bN7NXxdCWQydlKlTjNsmwSfN/67Rl5/0MpkeZJEJHfigmD5P6Um0awnY+paLWmZNweroAuPF+1400JLpyo347o5sSZfG1HPOhK3aKmnB7ELYL0KehO/hi90MgsvnNnYx/by2bdwRlAr5wEGHhZl4/+1AZ4X76r1lhV83/RKbXG9QA07rdVwGUh2hJjcrmslK6ZpR2RuXWM3jvlJdDp6A5Gbh3UNd455jfD0x4P4w28jN8v4YY4OaxFLgFGFh9VQy7NJ9K59N+LXN54V1Vts7NGc2mFTB0lV5+yvOASs8vWNq1NJ1OIlCbBjlSvyO4UK9YKa1IneYjZuWLa0A45tJkYHXRvTQppn863TJaiT5frZDK3vIKjYY3f7xOvUmWytS1Ra9rDg+l6bvLcnYOwEKJQJnt9x216vMd9peQtausOgQEurQIGvnOCEbzAQKw/98slSC6+Sc4DUmjUNyUXoVx7Kq8iFd9VLqg9LJbQULboLjLpUXTbJ+9ccsuZoGJ8y41VevcOWYmaxNvhwhRQawKkCyX7E/8ZqftN5JVTevZ9Mb3WWmngHQHKUfDofKBewPPbkH7U+sl4fSDEo7MfkI+0R8Fk9CsE8P+pE8sB6x+ie9I0Ygf+3jbAZDloFq7UBbNorOudZ07LdSP3Rdm/6MXhBHW5W8Ij08z/GtkE9VAJVBmH3FzH9X0nvUVAT2PZTWEMPp8XSlZ8E3C5dOfTrz1RXKuBMO0WL9dnXOB6ZyzW6eTXVFxg9kMFF6hH0sNIXGV59j9fWB74++uKV8EkO99IpTE7U6Kk+grev3zZl3OBZo9bw+z2UClcxfX0AMj0sOfAti+bHr0rm0GtjDqpEFhYPwQMD4gbXbgS7j5cqVYGooO71tePUQI/dIr+Qg9VTDvIRNEKZtVekO5w+BlsFVX8RjomgdZBsyDjSqY9fG96ipZxYchwDJWFr/HBnMLReKwNzFlRoDFKx6lqP3A/2ZzE1XQ/W11ZHg3Hsxcv4NkIOjsZzVnp0f4kPIVhWJNvlvab8TgHFeMCS1ik4Ir7a3XdERsOfT8bdsQaRt4t/vLgV48Gzh+Jn1iPBtPgToeq9p2Tvt3FbGvh9dIAGnpQ1EKdvUGJOgKmw2geV97vB1rYN5vYxnugPua9Huxj+xFTzLT89XSGNAQXWIJp3Q5WrRC7Z30+Q/6exDkRAootFp8NNFQW5cB2OOM9hIdrP0yBaQS33Wti/DIbDmthBKTZj14F4RXdvWsHw1k/EnqdCXz8FCbH+0NTIz0L+zqwrZbR4P4h3lTzOayJKCjpabpOajWvwTSsQBPnRaqOjp0z6RlRpqYhK/RE566SmHTPFTINNNwfH/kn6JGuNa/X5CjthMN9Cbz9U5eSnEyTigukqyZZJPP3BrWZb1HqnWD13/O6FZY3Auejf2TQPweyjUoe/gOY0FD5"
  },
  {
    "assessingTool": "Complexity",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/model.go",
    "grade": "A-",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:05:58.048Z",
    "codeReview": {
      "review": "Congratulations! Your most recent code changes passed."
    },
    "gradingDetails": {
      "grades": {
        "maintainabilityIndex": "B+",
        "qualityDesign": "B+",
        "readability": "A-",
        "testability": "B+"
      },
      "issues": {
        "cyclomaticComplexity": 1,
        "dependenciesModules": 20,
        "functionMethodCounts": 30,
        "linesOfCode": 32,
        "nestingDepth": 0
      }
    },
    "hash": "3396f4b9e4778036575f33905c23fb021aa50539dfe96788b3b4192ba68ed7dc",
    "id": "eJyFk01vnDAQhv/KyCeQ6HJfqYd2qyaRcoia9LReKQ4MMBt/IHtoiqL898qsl7JRdsMFyfM8r41neBUqBAyBbPvgnBZrsXGm1/iXeBSFqFyNG2cZLYu16FX1rFqEhjSjl1ZaMr3zDJm0kqVgMiiFtHks8dgjXFNg50cI7IeK4TVy35YbQiyRbeH4PO6Ds2t5eiwpHqP5kzTeKe4SesZsEpWkK69qnKFzUhupZPwO6K0yeNkYEpWkBzJ4z8r0BypexSqunUp8pJK1cTX+wj+ELxNmVL89bLdTdpytaqYW30S2/YGsSIdzWntCJfVahQ4+vY5OheP93dQgWfJZlOoJfHvXc8IA213qf6w1g60g6/6Xc7hFm+VANg2GRx68BY026/KU+KEVQkYF7KOZw1OcoqXfbWm3mtux+o6N85h12/1i9UL8/YvqF/FTcowsIEbA1+lVTLtMIaKYJ06sRRmHJ5QdWj9qZZ5KM2imXmMZm6ix4S+VpvLwB5Umrq1aJ97+AciXNG8="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/gradeDetails.go",
    "grade": "A+",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:05:58.840Z",
    "codeReview": {
      "review": "Congratulations! Your most recent code changes passed."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "codeDiff": {
      "oldCode": "package filter\n\nimport \"time\"\n\ntype GradeDetail interface {\n\tGetCoverage(int)\n}\n\ntype GradeDetails struct {\n\tGrade    string `json:\"grade\"`\n\tScore    int `json:\"score\"`\n\tCoverage int `json:\"coverage\"`\n\tFileName string `json:\"fileName\"`\n\tTool     string `json:\"tool\"`\n\tTimestamp time.Time `json:\"timestamp\"`\n}\n\nfunc NewGradeDetails(grade string, score int, fileName string, tool string, timeStamp time.Time) GradeDetails {\n\treturn GradeDetails{\n\t\tGrade:    grade,\n\t\tScore:    score,\n\t\tFileName: fileName,\n\t\tTool:     tool,\n\t\tTimestamp: timeStamp,\n\t}\n}\n\nfunc (g *GradeDetails) GetCoverage(thresholdAsNum int) {\n    if g.Score > thresholdAsNum {\n        g.Coverage = 120\n    } else if g.Score == thresholdAsNum {\n        g.Coverage = 100\n    } else if g.Score >= thresholdAsNum-1 {\n        g.Coverage = 90\n    } else if g.Score >= thresholdAsNum-2 {\n        g.Coverage = 80\n    } else if g.Score >= thresholdAsNum-3 {\n        g.Coverage = 70\n    } else if g.Score >= thresholdAsNum-4 {\n        g.Coverage = 50\n    } else if g.Score >= thresholdAsNum-5 {\n        g.Coverage = 30\n    } else {\n        g.Coverage = 10\n    }\n}\n\n",
      "newCode": "package filter\n\nimport \"time\"\n\ntype GradeDetail interface {\n\tGetCoverage(int)\n}\n\ntype GradeDetails struct {\n\tGrade    string `json:\"grade\"`\n\tScore    int `json:\"score\"`\n\tCoverage int `json:\"coverage\"`\n\tFileName string `json:\"fileName\"`\n\tTool     string `json:\"tool\"`\n\tTimestamp time.Time `json:\"timestamp\"`\n}\n\nfunc NewGradeDetails(grade string, score int, fileName string, tool string, timeStamp time.Time) GradeDetails {\n\treturn GradeDetails{\n\t\tGrade:    grade,\n\t\tScore:    score,\n\t\tFileName: fileName,\n\t\tTool:     tool,\n\t\tTimestamp: timeStamp,\n\t}\n}\n``\nfunc (g *GradeDetails) GetCoverage(thresholdAsNum int) {\n\tif g.Score > thresholdAsNum {\n\t\tg.Coverage = 120\n\t} else if g.Score == thresholdAsNum {\n\t\tg.Coverage = 100\n\t} else if g.Score >= thresholdAsNum-1 {\n\t\tg.Coverage = 70\n\t} else if g.Score >= thresholdAsNum-2 {\n\t\tg.Coverage = 50\n\t} else if g.Score >= thresholdAsNum-3 {\n\t\tg.Coverage = 30\n\t} else {\n\t\tg.Coverage = 10\n\t}\n}\n",
      "changes": [
        {
          "newCode": "``",
          "reason": "Modified",
          "start": 27,
          "end": 27
        },
        {
          "oldCode": "    if g.Score > thresholdAsNum {\n        g.Coverage = 120\n    } else if g.Score == thresholdAsNum {\n        g.Coverage = 100\n    } else if g.Score >= thresholdAsNum-1 {\n        g.Coverage = 90\n    } else if g.Score >= thresholdAsNum-2 {\n        g.Coverage = 80\n    } else if g.Score >= thresholdAsNum-3 {\n        g.Coverage = 70\n    } else if g.Score >= thresholdAsNum-4 {\n        g.Coverage = 50\n    } else if g.Score >= thresholdAsNum-5 {\n        g.Coverage = 30\n    } else {\n        g.Coverage = 10\n    }",
          "newCode": "\tif g.Score > thresholdAsNum {\n\t\tg.Coverage = 120\n\t} else if g.Score == thresholdAsNum {\n\t\tg.Coverage = 100\n\t} else if g.Score >= thresholdAsNum-1 {\n\t\tg.Coverage = 70\n\t} else if g.Score >= thresholdAsNum-2 {\n\t\tg.Coverage = 50\n\t} else if g.Score >= thresholdAsNum-3 {\n\t\tg.Coverage = 30\n\t} else {\n\t\tg.Coverage = 10\n\t}",
          "reason": "Modified",
          "start": 29,
          "end": 45
        },
        {
          "oldCode": "\n",
          "reason": "Modified",
          "start": 47,
          "end": 48
        }
      ]
    },
    "hash": "03a723bf3f0803c7342034f96a029794bdd5f876cd7aafa9eb0e2ab807bc307c",
    "id": "eJyVVMFq4zAQ/ZVBp2Rx4qTd0taQQmlpb2kgXfbiQ7XOWFFXlow03qWU/PsiRU7sUMPm6DdPb948jfXJuHPonNTi1RjFMvby8369mry+rCbzGUtYYTb4YDShJpaxmhe/uUAopSK0uc61rGpjCXJGssKceYg+aoRnyzf4iMSlAqkJbckLhM9c5/SM9GD+oOUCR1LTONe7r445cGSbguIhXwAAD0ot4O3dGZ3lTHg8Z2+esy6MDRyp6UBwHoyEtm2PUEQwcp6kwiWv8LRRGfFI82nBF37IGNVSZIWOeFWDz2bqP4+0tha4Yf6y0QUs8W83glEYL/ZIIMzizSdQ9m0m4BsfP2SF637rcT/bEKpFaqzuFQIe4878fMFBskdDwAENTiLaJpYdTMWCzyiwg7kWbCfPji5DadfNYSTgW9fWGLpbQ1uLbmvU5t4tm8oHMvYDhasvQUz3i3AHJ7xICVNND7uwgPnFbF/ZASqHXY3F4r9FZoMid6cik/mgzO0ZKheDKjdnqFwOqlyfofJ9UOXqDJWrQZXLvsrwLURaXCaWhB93xWnLMpb+cGhdukVtPxSvfqVVo0jWClP/zCksaVIome5ft1R09m8qDNv9A7LCvX0="
  },
  {
    "assessingTool": "Complexity",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/gradeDetails.go",
    "grade": "A-",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:00.788Z",
    "codeReview": {
      "review": "Congratulations! Your most recent code changes passed."
    },
    "gradingDetails": {
      "grades": {
        "maintainabilityIndex": "B+",
        "qualityDesign": "B+",
        "readability": "A-",
        "testability": "B+"
      },
      "issues": {
        "cyclomaticComplexity": 40,
        "dependenciesModules": 2,
        "functionMethodCounts": 3,
        "linesOfCode": 48,
        "nestingDepth": 50
      }
    },
    "hash": "fd87027048edd5367be09de14453f6e38eff21b74e80d57bad206afa1660b08a",
    "id": "eJyVVMtu2zAQ/JUFT3ahWHk0SCvAAQoXzc0okPbGQ1h5RbPlQyBXbY3A/16QpmzJiID6qNnh7OxwxVcmQsAQlJXfnNOsYitnWo1/Fe1YwWq3wZWzhJZYxVpR/xISoVGa0HPLrTKt8wSckTLIWYRo1yI8ebHBz0hCaVCW0DeiRnjlltMT0sr9Ri8kzpSlObf7t44FCOS7mvKhWACACCor4eVncLbiTEacs5fIea6dTxxl6UgIEcyEvu2IUGcwc74ojWth8LxRk/FMi1nBG37IOd1TlMFAwrQQs1nEzxOtryVumr/pbA1r/DOMYJbGyz0KSLNE8wU0Y5sFxManD2Xwedx6Ps42heqROm9HhYTnuKs4X3JQHNAUcEKTk4z2iVVHU7kQM0rsZK4H+8mrk8tU2g9zmEl4N7Q1h+HW0NZj2Dq9+RTWnYmBzONA6eobkIvDIjzCGS9T0lSL4y4s4eb2+lDZA+qAQ43l8r9FridFHs9Frm4mZT5eoHI7qfLhApW7SZWHC1TeT6rcX6ByP6lyN1aZvoVMy8vEivTjfhW0ZRUrvwf0odyi9TstzI/SdJpUq7GMz5zGhq5qrcrD61bKwf4tpGP7f4HgvnM="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/pathFilter.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:00.840Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "7c590fbe7f1fc740f36326fed781c2e9aa054bda3fb1b0476ea143a33751e623",
    "id": "eJx9VU1v3DYQ/SsTHZpVsRaT6wI+BEGDpIfEgF30YBkBVxpJ01BDgZy1sw383wuS+vRHbxQ5nPfmvRnqV6a9R++J2xtrTXbIvv394frq4ubb1cX7d9k+q2yNHy0LsmSHbNDVD90iNGQEXcklUz9YJ7AruZQyRhts5KIypOQ8oC+zdDJo6VRDBsNi2vTiiNsYk4dkSsGVlu5TzA7kwaEfLHs6GoTGuhGXuA0rhJDLw1F7rMEyUMvWYR3PPGiuobGmRueLkgOZdXIv7lQJ/ApExnuf4jWA27vIvAjf6+OUC27vEu2SH0fOX/FhlblyqCXgA+MDEHvRXCHYZg3/QNKBdAiDs/dUY/2/5JsTV1uU3YbzmvEeXuGbw+8rArFwh3JyDL8t+3F7q8gBANbf+21IQjk8QY1Bj4tEI2ryz4M9Sax+5aJ0WqDXUnWg+RzkCgFbVawLHUE1Rv1o5fgslVLwRSAVNnngDVUIlWXRxKF5LJvzi/jaIbCVKe8k/W5o1uLlYzm7jrxYR+jh87TKl2XS+F67QOLz89AgTSmhrb/vIaU6w+ESnOYWodumKYUaeDM0BfkvidyIfo6uB3L5FFnKBvAS9DAg17v17oyYpzuPo2GrtliHL07O+FB1WP3w8NChdOhAQ0v3yIumyc3YzOeNkcFH8pOHm9Po46uyL7XH/FNfH601qfYwjNb12tC/mMYrxAWJq/CM+PCMQWX7QTvyNhbLU3wdkIL+0ytV3Nhro30XwfIkjVLwMZQNutVhtLcNuvIz1jmbGXxbD+xolFLwpyXetmKcfdY97sM+w0zw2Wi+SnjeCNnjVxFiE6viq+4xz+emeiLA5SU8hZjbamwMcSd83jVKwfVgSBbdicVCTQ6rueGlJucD5/HpL+KV3ZbDHspMldki+R8/K3Oqk6NGewE02AcrqQGSt2HOm/GxVgpuOvKgvT/1OI71zAi5Tn033og6F/Ch/ufkY7YVW6g0gzbewhGBeBnIYmVzTW5xOdR2ezDIu7DKL97fTdKN0Zs38sXuGN/sWfFEaW1KujsHvGDKaMuLM91o4zEOc7bPmtHg7JCpvzw6rzpkdza6P6r+ZIQGg2rzS0/vtxrmmSxamz3+B+NvCTM="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/pathFilter.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:00.893Z",
    "codeReview": {
      "review": "The `PathFilter` implementation has three critical areas of concern:\n\n1.  **Inefficient `isIgnored` function:**  The nested loops in `isIgnored` (checking ignored files and folders) have a time complexity of O(n*m), where n is the number of ignored files and m is the number of ignored folders.  This is inefficient for large lists of ignored items.  Consider using a Trie or a similar data structure to speed up the lookup.  Example:  Replace the `for` loops with a more optimized approach.\n\n2.  **Assumes file path structure:** The `isIgnored` function assumes that the `path` always ends with a file name.  If the `histories` can contain directory paths, this will lead to incorrect filtering.  Example: Modify the `isIgnored` function to handle directory paths correctly.\n\n3.  **Lack of error handling:** The code lacks error handling.  `filepath.Join` or `filepath.ToSlash` could potentially return errors.  Example: Add error handling to `filepath.Join` and `filepath.ToSlash` calls.\n"
    },
    "gradingDetails": {
      "dependencyInversionScore": "B",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "B",
      "openClosedScore": "B",
      "singleResponsibilityScore": "A"
    },
    "hash": "d043fde4286fc4fe585903eb741cc1337f04a67b822a39a584aac99c9297d76c",
    "id": "eJx9VU2P3DYM/SusD+m4mFjodYA9BGmCbFGkBXZ7Wi8KjU3bbGTKkOjdToP974Ukf+5Hb7JE8T2+R8rfM+09ek/c3lprslN28/tv179kx6yyNX60LMiSnbJBV990i9CQEXQll0z9YJ3AoeRSyhhtsJH3lSEllwF9maWTQUunGjIYFvOmF0fcxpg8JFMK/tDSfY7ZgTw49INlT2eD0Fg34RK3YYUQcnk4a481WAZq2Tqs45kHzTU01tTofFFyILNN7sWNlcD3QGS69zleA7i7j8yL8L09Trng7j7RLvlp4vwVHzeZK4daAj4wPgKxF80Vgm228I8kHUiHMDj7QDXW/0u+Gbnaoxx2nLeMj/AG3xx+2hCIhTuU0TG8W/fj9l6REwBsv4/7kIRyeoYag55WiSbU5J8HO0qsfuOidFqg11J1oPkS5AoBe1WsCx1BNUb9aOP4IpVScC2QCps98IYqhMqyaOLQPJbN5VV87RDYypx3lv4wNFvx8qmcQ0derCP08GVe5esyafygXSDx5WVokKaU0NZ/HSGlusDpCpzmFqHbpymFGvhhaAry14nchH6Jrgdy+RxZyg7wCvQwINeH7e6CmKc7T5Nhm7bYhq9OLvhQdVh98/DYoXToQENLD8irpsnN2MyXnZHBR/Kzh7vT6OObsq+1x/xzX5+tNan2MIzW9drQv5jGK8QFiavwjPjwjEFl+0E78jYWy3N8HZCC/vMrVdzaG6N9F8HyJI1S8DGUDbrVYbT3DbrxM9a5mBl82w7sZJRS8Ksl3rdinH3WPR7DPsNC8MVovkl42QjZ41cRYhOr4qvuMc+XpnomwNUVPIdY2mpqDHEjvuwapeBmMCSr7sRioSaH1dLwUpPzgfP09BfxymHP4QhlpspslfzTP5UZ6+So0V4ADfbBSmqA5Mcw5830WCsFtx150N6PPU5jvTBCrlPfTTeizgV8qP8efcy2YQuVZtDGWzgjEK8DWWxsrsmtLofa7k4G+RBW+fuf72fppujdG/lqd0xv9qJ4orQ1Jd1dAl4xZbLl1ZlutPEYhzk7Zs1kcHbK1J8enVcdsrsY3Z9VPxqhwaDa/dLT+62GZSaL1mZP/wF3JAd2"
  },
  {
    "assessingTool": "Complexity",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/pathFilter.go",
    "grade": "A-",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:01.931Z",
    "codeReview": {
      "review": "Congratulations! Your most recent code changes passed."
    },
    "gradingDetails": {
      "grades": {
        "maintainabilityIndex": "B+",
        "qualityDesign": "B+",
        "readability": "A-",
        "testability": "B+"
      },
      "issues": {
        "cyclomaticComplexity": 45,
        "dependenciesModules": 3,
        "functionMethodCounts": 2,
        "linesOfCode": 66,
        "nestingDepth": 30
      }
    },
    "hash": "d222534534d893a619f244050907103fec4e55ea68a35866549e9a473c70c84d",
    "id": "eJx9VU1v3DgM/StcH7rjYmphrwPkUAQt2h6KBZo9xcFCY9M2W5kyJDrpbJH/vpDkz3z0JksU3+N7pPwr096j98TtjbUmO2XXth8M/iS5ZMessjVeWxZkyU7ZoKsfukVoyAi6kkumfrBO4FByKWWMNtjIu8qQksuAvszSyaClUw0ZDIt504sjbmNMHpIpBX9r6T7G7EAeHPrBsqezQWism3CJ27BCCLk8nLXHGiwDtWwd1vHMg+YaGmtqdL4oOZDZJvfixkrgVyAy3fsYrwHc3kXmRfjeHqdccHuXaJf8OHH+ig+bzJVDLQEfGB+A2IvmCsE2W/gHkg6kQxicvaca69+Sb0au9iiHHect4yO8wjeHtxsCsXCHMjqGN+t+3N4rcgKA7fdxH5JQTk9QY9DjKtGEmvzzYEeJ1W9clE4L9FqqDjRfglwhYK+KdaEjqMaoH20cX6RSCj4LpMJmD7yhCqGyLJo4NI9lc3kRXzsEtjLnnaU/DM1WvHwq59CRF+sIPXyaV/m6TBrfaxdIfHoeGqQpJbT1v0dIqS5wugKnuUXo9mlKoQb+GJqC/OdEbkK/RNcDuXyOLGUHeAV6GJDrw3Z3QczTncfJsE1bbMNXJxd8qDqsfnh46FA6dKChpXvkVdPkZmzmy87I4CP52cPdafTxVdnX2mP+ua/P1ppUexhG63pt6D9M4xXigsRVeEZ8eMagsv2gHXkbi+U5vg5IQf/5lSpu7DejfRfB8iSNUnAdygbd6jDa+wbd+BnrXMwMvm0HdjJKKfhiifetGGefdY/HsM+wEHw2mq8SXjZC9vhVhNjEqviqe8zzpameCHB1BU8hlraaGkPciM+7Rin4NhiSVXdisVCTw2ppeKnJ+cB5evqLeOWw53CEMlNltkr+4Wdlxjo5arQXQIN9sJIaIPkzzHkzPdZKwU1HHrT3Y4/TWC+MkOvUd9ONqHMB7+vvo4/ZNmyh0gzaeAtnBOJ1IIuNzTW51eVQ2+3JIB/CKn/3190s3RS9eyNf7I7pzV4UT5S2pqS7S8ALpky2vDjTjTYe4zBnx6yZDM5OmfrHo/OqQ3YXo/uz6kcjNBhUu196er/VsMxk0drs8X+rygop"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/gradeDetails.go",
    "grade": "C",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:02.593Z",
    "codeReview": {
      "detailedReview": {
        "tasks": [
          {
            "done": false,
            "titleTask": "interfaceSegregation",
            "violatingCode": "The provided code snippet, specifically lines 24-40, demonstrates a violation of the Interface Segregation Principle (ISP) because it implements a complex conditional logic to determine coverage based on a score. This approach tightly couples the scoring mechanism with the coverage calculation, making it difficult to modify or extend the coverage calculation independently.\n",
            "codeResolution": "The code snippet exhibits a lack of Interface Segregation by tightly coupling the `Score` to `Coverage` logic.\n\nRefactoring Strategy: Extract the coverage calculation into a separate, dedicated function or a lookup table to improve readability and maintainability.\n\n```go\nfunc calculateCoverage(score, threshold int) int {\n    if score > threshold {\n        return 120\n    } else if score == threshold {\n        return 100\n    } else if score >= threshold-1 {\n        return 90\n    } else if score >= threshold-2 {\n        return 80\n    } else if score >= threshold-3 {\n        return 70\n    } else if score >= threshold-4 {\n        return 50\n    } else if score >= threshold-5 {\n        return 30\n    } else {\n        return 10\n    }\n}\n```\n",
            "severity": "Critical",
            "rationale": "Rationale:\n\nThe provided code snippet doesn't directly relate to Interface Segregation Principle (ISP). ISP focuses on the design of interfaces, ensuring they are specific to the needs of the client. This code snippet is about calculating coverage based on a score and threshold. It doesn't define or implement any interfaces. Therefore, ISP isn't applicable here.\n",
            "lineStart": 24,
            "lineEnd": 39,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "liskovSubstitution",
            "violatingCode": "The provided code snippet violates the Liskov Substitution Principle (LSP) because the logic for determining `g.Coverage` depends on a series of `if/else if` statements that check the value of `g.Score` relative to `thresholdAsNum`. This structure makes it difficult to substitute different implementations of the underlying data structure without potentially altering the behavior of the code.\n",
            "codeResolution": "```markdown\n**Code Resolution for Liskov Substitution Principle (LSP)**\n\nThe provided code snippet, while not directly violating LSP, can be improved for readability and maintainability, which indirectly supports LSP by making the code easier to understand and modify without unintended side effects.\n\n**Refactoring Strategy:** Consolidate the `if/else if` chain into a more structured approach, such as a lookup table or a function that calculates coverage based on the score and threshold.\n\n**Example of Improved Code:**\n\n```go\nfunc calculateCoverage(score, threshold int) int {\n    if score > threshold {\n        return 120\n    }\n    if score == threshold {\n        return 100\n    }\n    if score >= threshold-1 {\n        return 90\n    }\n    if score >= threshold-2 {\n        return 80\n    }\n    if score >= threshold-3 {\n        return 70\n    }\n    if score >= threshold-4 {\n        return 50\n    }\n    if score >= threshold-5 {\n        return 30\n    }\n    return 10\n}\n\n// In the original context:\ng.Coverage = calculateCoverage(g.Score, thresholdAsNum)\n```\n```\n",
            "severity": "Critical",
            "rationale": "Rationale:\n\nThe code snippet demonstrates a potential violation of the Liskov Substitution Principle (LSP) if `g.Score` and `thresholdAsNum` are not of compatible types or if the logic within the conditional statements is not consistently applied. This could lead to unexpected behavior, reduced maintainability, and potential correctness issues. For example, if `thresholdAsNum` is an integer and `g.Score` is a float, the comparisons might not behave as expected due to type coercion, leading to incorrect coverage values. This could affect the performance of the system.\n",
            "lineStart": 24,
            "lineEnd": 40,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "openClosed",
            "violatingCode": "The `openClosed` principle is violated in the provided code snippet. The series of `if/else if` statements directly modify the `g.Coverage` based on the `g.Score` relative to a `thresholdAsNum`.\n\n```go\n24:     if g.Score > thresholdAsNum {\n25:         g.Coverage = 120\n26:     } else if g.Score == thresholdAsNum {\n27:         g.Coverage = 100\n28:     } else if g.Score >= thresholdAsNum-1 {\n29:         g.Coverage = 90\n30:     } else if g.Score >= thresholdAsNum-2 {\n31:         g.Coverage = 80\n32:     } else if g.Score >= thresholdAsNum-3 {\n33:         g.Coverage = 70\n34:     } else if g.Score >= thresholdAsNum-4 {\n35:         g.Coverage = 50\n36:     } else if g.Score >= thresholdAsNum-5 {\n37:         g.Coverage = 30\n38:     } else {\n39:         g.Coverage = 10\n40:     }\n```\n\nAdding or changing coverage levels requires modifying this block of code, thus violating the Open/Closed Principle.\n",
            "codeResolution": "The code violates the Open/Closed Principle because adding or modifying coverage tiers requires changing the existing `if/else if` structure.\n\nRefactoring Strategy: Use a lookup table (map or slice) to define score thresholds and corresponding coverage values. This allows for easy modification and extension without altering the core logic.\n\n```go\nthresholds := map[int]int{\n    0: 10,\n    5: 30,\n    6: 50,\n    7: 70,\n    8: 80,\n    9: 90,\n    10: 100,\n    11: 120,\n}\n\nfor score, coverage := range thresholds {\n    if g.Score >= thresholdAsNum - score {\n        g.Coverage = coverage\n        break\n    }\n}\n```\n",
            "severity": "Critical",
            "rationale": "Rationale:\n\nThe code violates the Open/Closed Principle because adding or modifying coverage tiers requires changing the existing `if/else if` structure. This can affect maintainability as the logic becomes more complex with each added tier. It could also introduce errors if not handled carefully. This design makes it difficult to extend the functionality without modifying the original code, potentially impacting correctness.\n",
            "lineStart": 24,
            "lineEnd": 40,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "singleResponsibility",
            "violatingCode": "The code snippet from lines 24-40 within the provided context, directly calculates and assigns `g.Coverage` based on a series of `if/else if` conditions related to `g.Score` and `thresholdAsNum`. This logic tightly couples the scoring mechanism with the coverage calculation, violating the Single Responsibility Principle.\n",
            "codeResolution": "```markdown\n**Code Resolution for Single Responsibility**\n\nThe provided code snippet has a single responsibility issue. The logic for determining `g.Coverage` based on `g.Score` and `thresholdAsNum` is complex and could be extracted into a separate function or method to improve readability and maintainability.\n\n**Refactoring Strategy:**\n\n1.  Create a function (e.g., `calculateCoverage`) that takes `g.Score` and `thresholdAsNum` as input and returns the calculated coverage value.\n2.  Replace the original conditional block with a call to this function.\n\n**Improved Code Example:**\n\n```go\nfunc calculateCoverage(score int, threshold int) int {\n    if score > threshold {\n        return 120\n    } else if score == threshold {\n        return 100\n    } else if score >= threshold-1 {\n        return 90\n    } else if score >= threshold-2 {\n        return 80\n    } else if score >= threshold-3 {\n        return 70\n    } else if score >= threshold-4 {\n        return 50\n    } else if score >= threshold-5 {\n        return 30\n    } else {\n        return 10\n    }\n}\n\n// In the original code:\ng.Coverage = calculateCoverage(g.Score, thresholdAsNum)\n```\n```",
            "severity": "Low",
            "rationale": "Rationale:\n\nThe code snippet calculates coverage based on a score and a threshold. This logic could be extracted into a separate function or a dedicated class to adhere to the Single Responsibility Principle. This matters because mixing the coverage calculation with other responsibilities can make the code harder to understand, test, and maintain. Changes to the scoring system would require modifying this block, potentially introducing errors or impacting performance if the logic becomes complex.\n",
            "lineStart": 24,
            "lineEnd": 40,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "dependencyInversion",
            "violatingCode": "The code snippet directly uses concrete values (e.g., `120`, `100`, `90`, etc.) to set the `Coverage` of a `g` object based on its `Score` relative to a `thresholdAsNum`.\n\n```go\n24:     if g.Score > thresholdAsNum {\n25:         g.Coverage = 120\n26:     } else if g.Score == thresholdAsNum {\n27:         g.Coverage = 100\n```\nThis approach tightly couples the logic to specific coverage values, making it inflexible to changes in the coverage calculation rules.\n",
            "codeResolution": "The provided code snippet demonstrates a lack of Dependency Inversion Principle (DIP) because it directly couples the `g.Score` to a series of hardcoded threshold values.\n\nRefactoring Strategy:\n\n1.  **Introduce an Interface:** Define an interface for calculating coverage based on score and threshold.\n2.  **Implementations:** Create concrete implementations of this interface, each representing a different coverage calculation strategy.\n3.  **Dependency Injection:** Inject the appropriate coverage calculation strategy into the code.\n\n```go\ntype CoverageCalculator interface {\n    CalculateCoverage(score int, threshold int) int\n}\n\ntype DefaultCoverageCalculator struct{}\n\nfunc (c *DefaultCoverageCalculator) CalculateCoverage(score int, threshold int) int {\n    if score > threshold {\n        return 120\n    } else if score == threshold {\n        return 100\n    } else if score >= threshold-1 {\n        return 90\n    } else if score >= threshold-2 {\n        return 80\n    } else if score >= threshold-3 {\n        return 70\n    } else if score >= threshold-4 {\n        return 50\n    } else if score >= threshold-5 {\n        return 30\n    } else {\n        return 10\n    }\n}\n\n// In your main code:\ncalculator := &DefaultCoverageCalculator{}\ng.Coverage = calculator.CalculateCoverage(g.Score, thresholdAsNum)\n```\n",
            "severity": "Critical",
            "rationale": "Rationale:\n\nThe code snippet directly couples the `g.Score` with a series of hardcoded threshold comparisons. This violates the Dependency Inversion Principle because it tightly binds the logic to specific numerical values. This lack of abstraction makes the code less maintainable. Any change to the scoring system or coverage calculation requires direct modification of this code block, increasing the risk of errors and making it difficult to adapt to future requirements.\n",
            "lineStart": 24,
            "lineEnd": 40,
            "status": ""
          }
        ],
        "codeReviewTitle": "SOLID Code Review"
      }
    },
    "gradingDetails": {
      "dependencyInversionScore": "F",
      "interfaceSegregationScore": "F",
      "liskovSubstitutionScore": "F",
      "openClosedScore": "F",
      "singleResponsibilityScore": "B"
    },
    "codeDiff": {
      "oldCode": "package filter\n\nimport \"time\"\n\ntype GradeDetail interface {\n\tGetCoverage(int)\n}\n\ntype GradeDetails struct {\n\tGrade    string `json:\"grade\"`\n\tScore    int `json:\"score\"`\n\tCoverage int `json:\"coverage\"`\n\tFileName string `json:\"fileName\"`\n\tTool     string `json:\"tool\"`\n\tTimestamp time.Time `json:\"timestamp\"`\n}\n\nfunc NewGradeDetails(grade string, score int, fileName string, tool string, timeStamp time.Time) GradeDetails {\n\treturn GradeDetails{\n\t\tGrade:    grade,\n\t\tScore:    score,\n\t\tFileName: fileName,\n\t\tTool:     tool,\n\t\tTimestamp: timeStamp,\n\t}\n}\n\nfunc (g *GradeDetails) GetCoverage(thresholdAsNum int) {\n    if g.Score > thresholdAsNum {\n        g.Coverage = 120\n    } else if g.Score == thresholdAsNum {\n        g.Coverage = 100\n    } else if g.Score >= thresholdAsNum-1 {\n        g.Coverage = 90\n    } else if g.Score >= thresholdAsNum-2 {\n        g.Coverage = 80\n    } else if g.Score >= thresholdAsNum-3 {\n        g.Coverage = 70\n    } else if g.Score >= thresholdAsNum-4 {\n        g.Coverage = 50\n    } else if g.Score >= thresholdAsNum-5 {\n        g.Coverage = 30\n    } else {\n        g.Coverage = 10\n    }\n}\n\n",
      "newCode": "package filter\n\nimport \"time\"\n\ntype GradeDetail interface {\n\tGetCoverage(int)\n}\n\ntype GradeDetails struct {\n\tGrade    string `json:\"grade\"`\n\tScore    int `json:\"score\"`\n\tCoverage int `json:\"coverage\"`\n\tFileName string `json:\"fileName\"`\n\tTool     string `json:\"tool\"`\n\tTimestamp time.Time `json:\"timestamp\"`\n}\n\nfunc NewGradeDetails(grade string, score int, fileName string, tool string, timeStamp time.Time) GradeDetails {\n\treturn GradeDetails{\n\t\tGrade:    grade,\n\t\tScore:    score,\n\t\tFileName: fileName,\n\t\tTool:     tool,\n\t\tTimestamp: timeStamp,\n\t}\n}\n\n// GetCoverage calculates the coverage percentage based on the score and threshold\nfunc (g *GradeDetails) GetCoverage(thresholdAsNum int) {\n\tif g.Score > thresholdAsNum {\n\t\tg.Coverage = 120\n\t} else if g.Score == thresholdAsNum {\n\t\tg.Coverage = 100\n\t} else if g.Score >= thresholdAsNum-1 {\n\t\tg.Coverage = 70\n\t} else if g.Score >= thresholdAsNum-2 {\n\t\tg.Coverage = 50\n\t} else if g.Score >= thresholdAsNum-3 {\n\t\tg.Coverage = 30\n\t} else {\n\t\tg.Coverage = 10\n\t}\n}\n",
      "changes": [
        {
          "newCode": "// GetCoverage calculates the coverage percentage based on the score and threshold",
          "reason": "Added",
          "start": 28,
          "end": 28,
          "grade": "F"
        },
        {
          "oldCode": "    if g.Score > thresholdAsNum {\n        g.Coverage = 120\n    } else if g.Score == thresholdAsNum {\n        g.Coverage = 100\n    } else if g.Score >= thresholdAsNum-1 {\n        g.Coverage = 90\n    } else if g.Score >= thresholdAsNum-2 {\n        g.Coverage = 80\n    } else if g.Score >= thresholdAsNum-3 {\n        g.Coverage = 70\n    } else if g.Score >= thresholdAsNum-4 {\n        g.Coverage = 50\n    } else if g.Score >= thresholdAsNum-5 {\n        g.Coverage = 30\n    } else {\n        g.Coverage = 10\n    }",
          "newCode": "\tif g.Score > thresholdAsNum {\n\t\tg.Coverage = 120\n\t} else if g.Score == thresholdAsNum {\n\t\tg.Coverage = 100\n\t} else if g.Score >= thresholdAsNum-1 {\n\t\tg.Coverage = 70\n\t} else if g.Score >= thresholdAsNum-2 {\n\t\tg.Coverage = 50\n\t} else if g.Score >= thresholdAsNum-3 {\n\t\tg.Coverage = 30\n\t} else {\n\t\tg.Coverage = 10\n\t}",
          "reason": "Modified",
          "start": 29,
          "end": 45,
          "grade": "F"
        },
        {
          "oldCode": "\n",
          "reason": "Modified",
          "start": 47,
          "end": 48,
          "grade": "F"
        }
      ]
    },
    "hash": "e3afe15b98d55e2f7a408781926c55d9f26583ee8bdcdb6937a03c16e296e46b",
    "id": "eJyVVF2L2zAQ/CuLnpLii++jR1tDDsodPQolLaR908OpzlpRqw8jrVuOI/+9SJETO5yhefTsaHZ2tNYLEyFgCMrK785pVrH11y+fH1jBarfBe2cJLbGKtaL+LSRCozSh55ZbZVrnCTgjZZCzCNFzi/DoxQYfkITSoCyhb0SN8MItp0eke/cHvZA4U5bm3O5eOxYgkO9qyodiAQAiqKyEp1/B2YozGXHOniJnXTufOMrSgRAimAl92xGhzmDmfFIaV8LgaaMm45kWY4JX/JBzuqcog4GEaSFms4ifR1pfS9w0f9PZGlb4dxjBLI2XexSQZonmC2jGNguIjY8fyuB63Ho+zjaF6pE6b0eFhOe4qzhfclDs0RRwQpOTjPaJVQdTuRAzSuxkrgf7yaujy1TaDXOYSXgztDWH4dbQ1mPYOr35GFadiYHM40Dp6huQi/0i3MEJL1PSVIvDLizh6vpyX9kB6oBDjeXyv0UuJ0XuTkUuriZlPpyhcj2p8v4MlZtJlXdnqLydVLk9Q+V2UuVmrDJ9C5mWl4kV6cf9JmjLKlb+COhDuUXrn7UwP0vTaVKtxjI+cxobuqi1KvevWykH+7eQju3+Aad6u8A="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/filterTools.go",
    "grade": "A+",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:02.708Z",
    "codeReview": {
      "review": "Congratulations! Your most recent code changes passed."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "codeDiff": {
      "oldCode": "package filter\n\nimport (\n\t\"log\"\n\t\"strings\"\n)\n\ntype FilterTools interface {\n\tFilter(values []string, histories Histories) Histories\n}\n\ntype ToolFilter struct{}\n\nfunc NewToolFilter() FilterTools {\n\treturn &ToolFilter{}\n}\n\nfunc (t *ToolFilter) Filter(values []string, histories Histories) Histories {\n\tfilteredHistories := Histories{}\n\tfor _, value := range values {\n\t\tlog.Println(\"Filtering by tool:\", value)\n\t\tvalue = strings.TrimPrefix(value, \" \")\n\t\tvalue = strings.TrimSuffix(value, \" \")\n\n\t\ttoolFilteredHistories := t.filterByTool(value, histories)\n\t\tfilteredHistories = append(filteredHistories, toolFilteredHistories...)\n\t}\n\treturn filteredHistories\n}\n\nfunc (t *ToolFilter) filterByTool(tool string, histories Histories) Histories {\n\tfilteredHistories := Histories{}\n\n\tfor _, history := range histories {\n\t\tif strings.ToUpper(history.AssessingTool) == strings.ToUpper(tool) {\n\t\t\thistory.CodeReview = map[string]any{}\n\t\t\thistory.GradingDetails = map[string]any{}\n\n\t\t\tfilteredHistories = append(filteredHistories, history)\n\t\t}\n\t}\n\n\treturn filteredHistories\n}",
      "newCode": "package filter\n\nimport (\n\t\"strings\"\n)\n\ntype FilterTools interface {\n\tFilter(values []string, histories Histories) Histories\n}\n\ntype ToolFilter struct{}\n\nfunc NewToolFilter() FilterTools {\n\treturn &ToolFilter{}\n}\n\nfunc (t *ToolFilter) Filter(values []string, histories Histories) Histories {\n\tfilteredHistories := Histories{}\n\tfor _, value := range values {\n\t\tvalue = strings.TrimPrefix(value, \" \")\n\t\tvalue = strings.TrimSuffix(value, \" \")\n\t\t//this string value is not used for SQL querys\n\t\ttoolFilteredHistories := t.filterByTool(value, histories)\n\t\tfilteredHistories = append(filteredHistories, toolFilteredHistories...)\n\t}\n\treturn filteredHistories\n}\n\nfunc (t *ToolFilter) filterByTool(tool string, histories Histories) Histories {\n\tfilteredHistories := Histories{}\n\n\tfor _, history := range histories {\n\t\tif strings.ToUpper(history.AssessingTool) == strings.ToUpper(tool) {\n\t\t\t//reduce the data load\n\t\t\thistory.CodeReview = map[string]any{}\n\t\t\thistory.GradingDetails = map[string]any{}\n\n\t\t\tfilteredHistories = append(filteredHistories, history)\n\t\t}\n\t}\n\n\treturn filteredHistories\n}",
      "changes": [
        {
          "newCode": "\t\t//this string value is not used for SQL querys",
          "reason": "Modified",
          "start": 24,
          "end": 24
        },
        {
          "newCode": "\t\t\t//reduce the data load",
          "reason": "Added",
          "start": 36,
          "end": 36
        }
      ]
    },
    "hash": "9d3c8eab3c9c9feb2f4713d488fb7491c91a9e1045aa07de11f21a7d0df2e6b3",
    "id": "eJytVE2PmzAQ/SsjHyqoCLTXSBy2W7U9dVE3qx7Wq8oLA7FqbGQPu0VR/nuFDSFpokgr9YRh3sd4HvaOCefQOambjTGKrdndz5v7YrW5K1YfP7CElabCW6MJNbE160T5WzQItVSElmuuZdsZSxBxzYkzZRrOwtKRlbpx42s8AmnoEL543ujkQGpCW4sSYTcyQil6EapHB49PgZ/AVjoyVqKDb/MqXpZc7w/io2xQAUe2L2nna3WvS/iOr0s5ik8a8fYWqbca3i2okb0IRATvl9os8NZ2g1eYHlbL53W+YHzXVBsLvxLw+mPZCt0gTHZehZMyTVpYqUnpiLPQkdQNPA9Axqg1Z5NAHPBBLIcpmnRjZVtYrOWfsI8EOAPOrqDv+/oS2uPpMJ1/dkZp2PCnYRzgTD4MarI7H0oOoutQV9FZKYGLZmmaerH9UaBn3GuhnvQ5WsB/jnUJNggOS7TbUzFOsl5Gbx66Dm00kdKb4zMbQ56fIckXJiVOM/HWVPgDXyS+Qg6t6B4D70noIfx2x+CvVlRSN5+RhFTuMmGivC28yWAKfj9Hdj00lrBaKiwEbdmaZQ8Orcu2qO2gRPuctb0i2SnMxgtLYU2rUsksCE0Pf9rTxrD9X3Nl3Fs="
  },
  {
    "assessingTool": "Complexity",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/filterTools.go",
    "grade": "A-",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:04.703Z",
    "codeReview": {
      "review": "Congratulations! Your most recent code changes passed."
    },
    "gradingDetails": {
      "grades": {
        "maintainabilityIndex": "C+",
        "qualityDesign": "B",
        "readability": "B+",
        "testability": "B+"
      },
      "issues": {
        "cyclomaticComplexity": 10,
        "dependenciesModules": 20,
        "functionMethodCounts": 3,
        "linesOfCode": 44,
        "nestingDepth": 30
      }
    },
    "hash": "5fc18436014c5f403620eaa4653523c9a49474e12159465e4862d72ee8fd08fb",
    "id": "eJytVE2PmzAQ/SsjHyqoKNyROLSp2p6qqN09rVeVFwZi1diWPewuivLfK2wIySaKtFJPGOZ9jOdh75nwHr2XurszRrGSbUxvFb5KGlnGatPgxmhCTaxkVtR/RYfQSkXouOZa9tY4goRrTpwp03EWl56c1J2fXtMJSKNF+BZ4k48HqQldK2qE/cSIpeRZqAE9PDxGfgY76ck4iR5+LKt0XXJ9OIpPslEFPLmhpn2otYOu4Se+rOUkPWsk2DukwWn4sKIm9iqQEHxca4vAe9uNXnF62Kyfy2rFhK6pNQ7+ZBD0p7ITukOY7YIKJ2W6fOukJqUTzmJHUnfwNAIZo0rOZoE04qNYBXM0+Z2T/dZhK1/jPjLgDDi7gf49tNfQAU/H6bzZGeVxw1/GaYAL+Tio2e5yKBUIa1E3yUUpg6tmeZ4HscNJoBfcW6Ge9TlZwH+OdQ02Co5rtLtzMU6yXUdv7q1Fl8yk/PPpiU2hqi6QFAqzEqeFuDEN/sJniS9QQS/sQ+Q9Cj3G3+4U/N2JRuruK5KQyl8nzJT3hTcbzMEflshuh8Yy1kqFW0E7VrLi3qPzxQ61G5Xon4p+UCStwmK6sBS29KlWsohC8yOc9rwz7PAPDandUQ=="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/filterTools.go",
    "grade": "C",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:05.328Z",
    "codeReview": {
      "detailedReview": {
        "tasks": [
          {
            "done": false,
            "titleTask": "interfaceSegregation",
            "violatingCode": "The provided code snippet does not demonstrate any violations of the Interface Segregation Principle (ISP). The code is simply logging a message and trimming whitespace from a string. There are no interfaces defined or implemented in this snippet.\n",
            "codeResolution": "The provided code snippet demonstrates good adherence to the Interface Segregation Principle (ISP). The `log` function is used to log a message, and the `strings.TrimPrefix` and `strings.TrimSuffix` functions are used to trim whitespace from a string. There is no need to refactor this code snippet.\n",
            "severity": "Critical",
            "rationale": "The provided code snippet doesn't directly relate to the Interface Segregation Principle (ISP). ISP focuses on creating specific interfaces rather than large, general-purpose ones. This snippet shows a simple string manipulation task (trimming whitespace) and logging. Therefore, there's no ISP violation or benefit to analyze here.\n",
            "lineStart": 3,
            "lineEnd": 19,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "liskovSubstitution",
            "violatingCode": "The provided code snippet does not demonstrate a violation of the Liskov Substitution Principle (LSP). The code is simply trimming whitespace from a string. LSP applies to inheritance and the ability to substitute subtypes for their base types without altering the correctness of the program. This snippet does not involve inheritance or polymorphism.\n",
            "codeResolution": "The provided code snippet doesn't directly demonstrate a violation of the Liskov Substitution Principle (LSP). LSP is about ensuring that subtypes can replace their base types without altering the correctness of the program. The snippet shows string manipulation (trimming whitespace) and logging, which are not related to inheritance or polymorphism, which are the core concepts of LSP. Therefore, no specific fix or refactoring strategy is applicable in this context.\n",
            "severity": "Critical",
            "rationale": "Rationale:\n\nThe code snippet demonstrates a potential issue for Liskov Substitution if `log` is not properly implemented. If `log` is replaced with a different implementation, it could lead to unexpected behavior. This could affect maintainability, as changes to the logging implementation might require changes elsewhere. It could also affect correctness if the new implementation doesn't handle the trimming of spaces correctly, leading to incorrect filtering.\n",
            "lineStart": 0,
            "lineEnd": 19,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "openClosed",
            "violatingCode": "The provided code snippet demonstrates a violation of the Open/Closed Principle (OCP). Specifically, lines 17 and 18, `value = strings.TrimPrefix(value, \" \")` and `value = strings.TrimSuffix(value, \" \")`, modify the input `value` by trimming whitespace. If new filtering requirements arise (e.g., handling special characters), these lines would need modification, violating OCP.\n",
            "codeResolution": "The provided code snippet focuses on string manipulation (trimming whitespace) based on a filter.\n\n**Code Resolution:**\n\nThe code snippet is already concise and performs a specific task. There is no immediate need for refactoring. The code adheres to the Open/Closed principle as it can be extended to include more filtering logic without modifying the existing code.\n\n**Potential Improvement:**\n\nIf more complex filtering logic is needed, consider creating a separate function or method to encapsulate the filtering process. This would improve readability and maintainability.\n",
            "severity": "Critical",
            "rationale": "The rationale for the Open/Closed Principle (OCP) in this context is to ensure that the code is open for extension but closed for modification. The provided code snippet, specifically lines 16-19, demonstrates a potential violation of OCP. If new filtering criteria or data transformations are needed, the existing code would need to be modified. This can affect maintainability by increasing the risk of introducing bugs and making it harder to understand the code's behavior. It could also affect correctness if the modifications are not thoroughly tested.\n",
            "lineStart": 16,
            "lineEnd": 19,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "singleResponsibility",
            "violatingCode": "The provided code snippet demonstrates a violation of the Single Responsibility Principle (SRP).\n\n```go\n16: \t\tlog.Println(\"Filtering by tool:\", value)\n17: \t\tvalue = strings.TrimPrefix(value, \" \")\n18: \t\tvalue = strings.TrimSuffix(value, \" \")\n19: \n```\n\nThe code is responsible for both logging a message and modifying the input string. This dual responsibility makes the code harder to maintain and test.\n",
            "codeResolution": "The provided code snippet focuses on string manipulation (trimming whitespace) related to a filtering process. The single responsibility principle could be improved by separating the filtering logic from the logging concern.\n\n**Refactoring Strategy:**\n\n1.  **Extract a function** to handle the string trimming.\n2.  **Call the function** before logging.\n\n**Improved Code Example:**\n\n```go\nfunc trimFilterValue(value string) string {\n    value = strings.TrimPrefix(value, \" \")\n    value = strings.TrimSuffix(value, \" \")\n    return value\n}\n\n// ...\nlog.Println(\"Filtering by tool:\", value)\nvalue = trimFilterValue(value)\n// ...\n```\n\nThis isolates the trimming operation, making the code more modular and easier to maintain.\n",
            "severity": "Critical",
            "rationale": "The rationale for the single responsibility principle (SRP) violation is that the \"log\" function is responsible for both logging and data transformation (trimming whitespace). This matters because it tightly couples logging with data manipulation, making the code harder to maintain. Changes to logging (e.g., different format) could inadvertently affect data transformation, and vice versa. This could affect maintainability by making it harder to understand and modify the code, and potentially introduce bugs.\n",
            "lineStart": 3,
            "lineEnd": 19,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "dependencyInversion",
            "violatingCode": "The provided code snippet does not demonstrate a violation of the Dependency Inversion Principle (DIP). The code snippet is simply logging a message and trimming whitespace from a string. There are no dependencies or abstractions to analyze for DIP adherence or violation.\n",
            "codeResolution": "The provided code snippet demonstrates a lack of dependency inversion. The `log` package is directly imported and used.\n\n**Refactoring Strategy:**\n\nIntroduce an interface for logging, such as `Logger`. The `log` package can then implement this interface. The code should depend on the `Logger` interface rather than the concrete `log` package.\n\n**Example:**\n\n```go\ntype Logger interface {\n\tPrintln(v ...interface{})\n}\n\ntype DefaultLogger struct{}\n\nfunc (l *DefaultLogger) Println(v ...interface{}) {\n\tlog.Println(v...)\n}\n\n// In the code:\nvar logger Logger = &DefaultLogger{} // or a mock for testing\n\n// Use the logger:\nlogger.Println(\"Filtering by tool:\", value)\n```\n",
            "severity": "Critical",
            "rationale": "The code snippet demonstrates a direct dependency on the `log` package. This matters for Dependency Inversion because it tightly couples the code to a specific logging implementation. This can affect maintainability because changing the logging library would require code modifications. It could also affect testability, as it's harder to mock or stub the `log` package for unit tests. This lack of abstraction could potentially impact the flexibility and adaptability of the code.\n",
            "lineStart": 3,
            "lineEnd": 19,
            "status": ""
          }
        ],
        "codeReviewTitle": "SOLID Code Review"
      }
    },
    "gradingDetails": {
      "dependencyInversionScore": "F",
      "interfaceSegregationScore": "F",
      "liskovSubstitutionScore": "F",
      "openClosedScore": "F",
      "singleResponsibilityScore": "F"
    },
    "codeDiff": {
      "oldCode": "package filter\n\nimport (\n\t\"log\"\n\t\"strings\"\n)\n\ntype FilterTools interface {\n\tFilter(values []string, histories Histories) Histories\n}\n\ntype ToolFilter struct{}\n\nfunc NewToolFilter() FilterTools {\n\treturn &ToolFilter{}\n}\n\nfunc (t *ToolFilter) Filter(values []string, histories Histories) Histories {\n\tfilteredHistories := Histories{}\n\tfor _, value := range values {\n\t\tlog.Println(\"Filtering by tool:\", value)\n\t\tvalue = strings.TrimPrefix(value, \" \")\n\t\tvalue = strings.TrimSuffix(value, \" \")\n\n\t\ttoolFilteredHistories := t.filterByTool(value, histories)\n\t\tfilteredHistories = append(filteredHistories, toolFilteredHistories...)\n\t}\n\treturn filteredHistories\n}\n\nfunc (t *ToolFilter) filterByTool(tool string, histories Histories) Histories {\n\tfilteredHistories := Histories{}\n\n\tfor _, history := range histories {\n\t\tif strings.ToUpper(history.AssessingTool) == strings.ToUpper(tool) {\n\t\t\thistory.CodeReview = map[string]any{}\n\t\t\thistory.GradingDetails = map[string]any{}\n\n\t\t\tfilteredHistories = append(filteredHistories, history)\n\t\t}\n\t}\n\n\treturn filteredHistories\n}",
      "newCode": "package filter\n\nimport (\n\t\"strings\"\n)\n\ntype FilterTools interface {\n\tFilter(values []string, histories Histories) Histories\n}\n\ntype ToolFilter struct{}\n\nfunc NewToolFilter() FilterTools {\n\treturn &ToolFilter{}\n}\n\nfunc (t *ToolFilter) Filter(values []string, histories Histories) Histories {\n\tfilteredHistories := Histories{}\n\tfor _, value := range values {\n\t\tstrings.TrimPrefix(value, \" \")\n\t\tstrings.TrimSuffix(value, \" \")\n\t\ttoolFilteredHistories := t.filterByTool(value, histories)\n\t\tfilteredHistories = append(filteredHistories, toolFilteredHistories...)\n\t}\n\treturn filteredHistories\n}\n\nfunc (t *ToolFilter) filterByTool(tool string, histories Histories) Histories {\n\tfilteredHistories := Histories{}\n\n\tfor _, history := range histories {\n\t\tif strings.ToUpper(history.AssessingTool) == strings.ToUpper(tool) {\n\t\t\t//reduce the data load\n\t\t\thistory.CodeReview = map[string]any{}\n\t\t\thistory.GradingDetails = map[string]any{}\n\n\t\t\tfilteredHistories = append(filteredHistories, history)\n\t\t}\n\t}\n\n\treturn filteredHistories\n}\n",
      "changes": [
        {
          "oldCode": "\t\tlog.Println(\"Filtering by tool:\", value)\n\t\tvalue = strings.TrimPrefix(value, \" \")\n\t\tvalue = strings.TrimSuffix(value, \" \")\n",
          "newCode": "\t\tstrings.TrimPrefix(value, \" \")\n\t\tstrings.TrimSuffix(value, \" \")",
          "reason": "Modified",
          "start": 21,
          "end": 24,
          "grade": "F"
        },
        {
          "newCode": "\t\t\t//reduce the data load",
          "reason": "Added",
          "start": 36,
          "end": 36,
          "grade": "F"
        },
        {
          "reason": "Added",
          "start": 45,
          "end": 45,
          "grade": "F"
        }
      ]
    },
    "hash": "cb9e91e377b0be181a27704722c220d51fefea1ddf1cfe4d048308a21a446b05",
    "id": "eJytVEtr3DAQ/iuDDsUujn03+NAm9AGlXZrkFIWg2GOvqCwZaZzULPvfiyTvere7LARysuz5HqP5LG2YcA6dk7q7M0axkt3++vH9hmWsNg1eG02oiZVsEPUf0SG0UhFarrmW/WAsQcI1J86U6TiLS0dW6s7519QDaRoQvgSet3AgNaFtRY2w8YxYSl6EGtHBw2PkZ7CWjoyV6ODbbpUuS663e3EvG1XAkR1r2oRaO+oafuLrUk7So0aCvUUarYYPC8qzF4GE4ONS2wm8td3oFaeHzfK5rBZM6JpaY+Epg6Dvy1boDmG2CyqclOnylZWalE44ix1J3cHzBGSMKjmbBdKIj2IVzNHkd1b2K4ut/Bv3kQFnwNkF9O3YnkMHPO2n89/OKI8b/jz5Ae7I+0HNdqdDqUAMA+omOSllcNYsz/Mgtj0I9IR7KdSjPr0FvHOsS7BRcFqiXR+LcZLtMnpzPwxok5mUfzo8rClU1QmSQmFW4rQjXpsGf+OLxFeooBfDQ+Q9Cj3F3+4Q/NWKRuruBklI5c4TZsrbwpsN5uC3u8guh8Yy1kqFK0FrVrLi3qF1xRq1nZTon4t+VCQHhYW/sBS2dFUrWUSh+RFOe94Ztv0Hx7jang=="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/collectGrades.go",
    "grade": "A+",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:05.422Z",
    "codeReview": {
      "review": "Congratulations! Your most recent code changes passed."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 1,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "codeDiff": {
      "oldCode": "package filter\n\ntype CollectGrades interface {\n\tCollectGrades(histories Histories, threshold string) []GradeDetails\n}\n\ntype GradeCollection struct {\n\tGradeCalculator GradeCalculator\n}\n\nfunc NewGradeCollection(calculator GradeCalculator) CollectGrades {\n\treturn &GradeCollection{\n\t\tGradeCalculator: calculator,\n\t}\n}\n\nfunc (g *GradeCollection) CollectGrades(histories Histories, threshold string) []GradeDetails {\n\tgradeDetails := []GradeDetails{}\n\tfor _, history := range histories {\n\t\tnewDetails := NewGradeDetails(history.Grade, g.GradeCalculator.GradeNumericalValue(history.Grade), history.FilePath, history.AssessingTool, history.TimeStamp)\n\t\tnewDetails.GetCoverage(g.GradeCalculator.GradeNumericalValue(threshold))\n\t\tgradeDetails = append(gradeDetails, newDetails)\n\n\t}\n\treturn gradeDetails\n}\n\ntype GradeCalculator interface {\n\tGradeNumericalValue(grade string) int\n}\n\ntype GradeStringCalculator struct{}\n\nfunc NewGradeStringCalculator() GradeCalculator {\n\treturn &GradeStringCalculator{}\n}\n\nfunc (g *GradeStringCalculator) GradeNumericalValue(grade string) int {\n\tswitch grade {\n\tcase \"A+\":\n\t\treturn 90 // Minimum score for A+ in the new system\n\tcase \"A\":\n\t\treturn 85 // Minimum score for A\n\tcase \"A-\":\n\t\treturn 80 // Minimum score for A-\n\tcase \"B+\":\n\t\treturn 75 // Minimum score for B+\n\tcase \"B\":\n\t\treturn 70 // Minimum score for B\n\tcase \"B-\":\n\t\treturn 65 // Minimum score for B-\n\tcase \"C+\":\n\t\treturn 60 // Minimum score for C+\n\tcase \"C\":\n\t\treturn 55 // Minimum score for C\n\tcase \"C-\":\n\t\treturn 50 // Minimum score for C-\n\tcase \"D+\":\n\t\treturn 45 // Minimum score for D+\n\tcase \"D\":\n\t\treturn 40 // Minimum score for D\n\tcase \"D-\":\n\t\treturn 30 // Minimum score for D- (Lowest passing grade)\n\tcase \"F\":\n\t\t// Although F is for scores below 30, the request is to return 30\n\t\t// to maintain similarity with the previous system's representative F score.\n\t\treturn 20\n\tdefault:\n\t\t// For any unrecognized grade, return 30, aligning with the F case\n\t\t// and the previous system's representative F score location.\n\t\treturn 20\n\t}\n}",
      "newCode": "package filter\n\ntype CollectGrades interface {\n\tCollectGrades(histories Histories, threshold string) []GradeDetails\n}\n\ntype GradeCollection struct {\n\tGradeCalculator GradeCalculator\n}\n\nfunc NewGradeCollection(calculator GradeCalculator) CollectGrades {\n\treturn &GradeCollection{\n\t\tGradeCalculator: calculator,\n\t}\n}\n\nfunc (g *GradeCollection) CollectGrades(histories Histories, threshold string) []GradeDetails {\n\tgradeDetails := []GradeDetails{}\n\tfor _, history := range histories {\n\t\tnewDetails := NewGradeDetails(history.Grade, g.GradeCalculator.GradeNumericalValue(history.Grade), history.FilePath, history.AssessingTool, history.TimeStamp)\n\t\tnewDetails.GetCoverage(g.GradeCalculator.GradeNumericalValue(threshold))\n\t\tgradeDetails = append(gradeDetails, newDetails)\n\n\t}\n\treturn gradeDetails\n}\n\ntype GradeCalculator interface {\n\tGradeNumericalValue(grade string) int\n}\n\ntype GradeStringCalculator struct{}\n\nfunc NewGradeStringCalculator() GradeCalculator {\n\treturn &GradeStringCalculator{}\n}\n\nfunc (g *GradeStringCalculator) GradeNumericalValue(grade string) int {\n\tswitch grade {\n\tcase \"A*\":\n\t\treturn 5\n\tcase \"A\":\n\t\treturn 4\n\tcase \"B\":\n\t\treturn 3\n\tcase \"C\":\n\t\treturn 2\n\tcase \"D\":\n\t\treturn 1\n\tdefault:\n\t\treturn 0\n\t}\n}\n",
      "changes": [
        {
          "oldCode": "\tcase \"A+\":\n\t\treturn 90 // Minimum score for A+ in the new system",
          "newCode": "\tcase \"A*\":\n\t\treturn 5",
          "reason": "Modified",
          "start": 40,
          "end": 41
        },
        {
          "oldCode": "\t\treturn 85 // Minimum score for A\n\tcase \"A-\":\n\t\treturn 80 // Minimum score for A-\n\tcase \"B+\":\n\t\treturn 75 // Minimum score for B+",
          "newCode": "\t\treturn 4",
          "reason": "Modified",
          "start": 43,
          "end": 47
        },
        {
          "oldCode": "\t\treturn 70 // Minimum score for B\n\tcase \"B-\":\n\t\treturn 65 // Minimum score for B-\n\tcase \"C+\":\n\t\treturn 60 // Minimum score for C+",
          "newCode": "\t\treturn 3",
          "reason": "Modified",
          "start": 49,
          "end": 53
        },
        {
          "oldCode": "\t\treturn 55 // Minimum score for C\n\tcase \"C-\":\n\t\treturn 50 // Minimum score for C-\n\tcase \"D+\":\n\t\treturn 45 // Minimum score for D+",
          "newCode": "\t\treturn 2",
          "reason": "Modified",
          "start": 55,
          "end": 59
        },
        {
          "oldCode": "\t\treturn 40 // Minimum score for D\n\tcase \"D-\":\n\t\treturn 30 // Minimum score for D- (Lowest passing grade)\n\tcase \"F\":\n\t\t// Although F is for scores below 30, the request is to return 30\n\t\t// to maintain similarity with the previous system's representative F score.\n\t\treturn 20",
          "newCode": "\t\treturn 1",
          "reason": "Modified",
          "start": 61,
          "end": 67
        },
        {
          "oldCode": "\t\t// For any unrecognized grade, return 30, aligning with the F case\n\t\t// and the previous system's representative F score location.\n\t\treturn 20",
          "newCode": "\t\treturn 0",
          "reason": "Modified",
          "start": 69,
          "end": 71
        },
        {
          "reason": "Added",
          "start": 74,
          "end": 74
        }
      ]
    },
    "hash": "a8e135293041251b5f064d79b230541771a88b7c64fecd0a55375196e3e9a648",
    "id": "eJydll9v0zAUxb/KVR6gZWkzGBtQaQ9dq46HsU3agAeKkOfeJhaOHeybVaXad0eJs8RNFv69Ndc+5/x8c9NkFzBr0Vqh4lutZTAJrj5Pb65Ht1fXo5eHQRhwvcKZVoSKgkmQMf6dxQhrIQnNUi0VbTOEmZYSOZ0btkILQhGaNeMIu6Va0t7iIBGWtBFo4f3jrxAoMWgTLVdgyQgVD+HL13L/HIkJaZfqoc4q65Wn0KpQ5JxclFtjkueSkTbQuq5s1rnicImbltOA9wqHrROWYQYpNwqetWzKtQ7KBBr3sNjx4MMMYnjRsmlF/l/fHGjsVyanrT27AoPW2sC3EFzKtthlmIoRmtjqXAo3ntVjF6tSRbkdl8UQ4nGrDe76Mk/RCM7kJyZz3BcNa4jxQki8ZpQ0lak/q035VqR4QyzNhm3G8TnSTN+jYTEO/o6m7umwcttr3ymwLEO1GvjVEJrEQuRubz0h8W8nuRm61nPzFFxpVd9soajjd1Ouea7u+dh1J7+9czDsEHXnvC3aPT3H7W2V9Z9O4wLtRhBPXNtchTOLsAymB8tg4m5KBfXuEKIIPggl0jwFy7VBKEZ5egBCASVY3BmwW0uY+kZtn7fHPT6+aNRR9aWPPNlZB/pNT9jZgS/rqHrCznxRB/GkL8tHnHUQT3rCZj7irK067gmb+aIO4nFflo847yC+7gmb+4jzjqonbO6LOohHfaoRDC70Bi1Bxso/Jje1Q89tUZtFEUwlJTqPE1iAsKVFaWbhDqXewNFhWA6twR95YSoskIYaorYhDSkTiphQYEUqJDOCtrARlJT6zOC90LmtJv+5BYOZQYuKGIl7hIXLHe+d8lUZsMI1yyU1zAttgKkt5Mog17ESP3Hljhk2aCEwKWJVdKCmWEDRgtqHqdU/wYHUnBWvwqcoi7+dIAzW1SsimATRR4vGRgkqs5UsvYvSXJLIJEbFJ4zENY24FJH7com4/3Idxzp4+AWKikSC"
  },
  {
    "assessingTool": "Complexity",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/collectGrades.go",
    "grade": "A-",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:07.280Z",
    "codeReview": {
      "review": "Congratulations! Your most recent code changes passed."
    },
    "gradingDetails": {
      "grades": {
        "maintainabilityIndex": "C+",
        "qualityDesign": "B+",
        "readability": "B+",
        "testability": "A-"
      },
      "issues": {
        "cyclomaticComplexity": 30,
        "dependenciesModules": 20,
        "functionMethodCounts": 30,
        "linesOfCode": 73,
        "nestingDepth": 20
      }
    },
    "hash": "e0272dc55a89789167d85c1866173bc81bd43e7de319a0beaa986f5c59ca7bf1",
    "id": "eJydll9v0zAUxb/KVR6gZWkzARtQaQ9bqo4HmJA2eKEIee5tYuHYwb5ZCdW+O0qcJW6y8O+tufY55+ebmyb7gFmL1gqV3Ggtg0UQ6yyX+ENQGYQB1xuMtSJUFCyCnPFvLEHYCklo1mqtqMwRYi0lcro0bIMWhCI0W8YR9mu1poPFSSosaSPQwtuHXyFQatCmWm7AkhEqmcLnL/X+JRIT0q7VfZtV1xtPoVWlKDi5KLfGJC8kI22gd93YbAvF4Qp3PacJHxVOeyeswwxSYRQ86dnUawOUBXTuYbXj3oeZJPCsZ9OL/L++OdDEryzOenv2FQZttYGvIbiUstplmEoQutjmXAp3ntVDF5tSQ1nO62IIybzXBnd9VWRoBGfyE5MFHoqmLcR8JSR+YJR2lXN/UrvyjcjwmliWT/uM80ukWN+hYQlO/o6m7em0cTto3xmwPEe1mfjVELrESuRubzshyW8nuRu63nPzGFxt1d5soWjgd12vea7u+dgPJ7+/czIdEA3nvC/aPz7H/W2N9Z9O4wLtThBPXdtchTOLsA7Oj9bBwt2UBurNMUQRvBdKZEUGlmuDUI3y+REIBZRidWfAlpYw8436Pq9PRnx80WygGkufebKLAfSrkbCLI182UI2EXfiiAeLpWJaPGA8QT0fCYh8x7qtORsJiXzRAPBnL8hGXA8SXI2FLH3E5UI2ELX3RAPHFmGoGk3d6h5YgZ/Ufk5vaqee2as2iCM4lpbpIUliBsLVFbWbhFqXewYvjsB5ag9+LylRYIA0tRGtDGjImFDGhwIpMSGYElbATlNb63OCd0IVtJv+pBYO5QYuKGIk7hJXLnR+c8nkdsMEtKyR1zCttgKkSCmWQ60SJn7hxxww7tBCYFImqOtBSrKBqQevD1Oaf4EBqzqpX4WOU1d9OEAbb5hURLILoo0VjoxSVKSXLbqOskCRyiVH1CSNxSzMuReS+XCLuv1zniQ7ufwEQQkV4"
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/latestGrades.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:07.336Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "e667d17d5da6653d913919bfe68ceb7d3fc61a821e4f5f4471d38c413bf01884",
    "id": "eJyVVE1v2zAM/SuEDkO8unZ3zZBDFyAbsHUNkBQ7VMWg2rQjRJY8idlmpPnvgz/kjyZAsZMFkXx8fH7UkQnn0Dmp860xis3Z/Y/bzfp6e7++/nDDQpaYFJdGE2pic1aKZC9yhEwqQss111SVCCup02+C0NFnK1J0IDWhzUSCcOSa06pJH2fMdtKRsRIdfPGnYDhyferBJ8CO7CGhYxPNDjqB7/hnghuck2koWKSD1fBuHKlhBqSZyuH9OFxD/Sfvtlccw4NDEJCYojROEsIeqzlwtpIK14J2L7dj1Tmrq1TTpoWqYL6AQuxxVojy0ZGVOn/qQkHNmFNmLPwMYTfkW6FzhN2UC6c9NtEcNVpBuPScvmLVTVNFnlePF00Idi05yQzqMKYdlxDwr3Tk6gYT/o97rJ4++mjH5Lw+2soCNySKMvqEmbHYM+oDwVD9SqOmByw8ZZ91ag8nQOVwKH67tCk8taN2dlka/Rst3YlyazZKJjibwASdf+L4oryQWKzTQcBBy1+HxgbwLBymYDR40UHoFKaGaB158Zdl/a+abC60Jgm678T0vgSugLMXzuBqWjtMcTYvJO1NPUMhSjAZeIeSAQGuSRpuo476uXCd1HeihAuefr1CXXbLwe9CnxPCTQgK9Qg0CN5eiqZ5Z4hJgwWIskSdzsa3PUzgfeH1HGc12rGQeY3ZnMUPDq2Ld6htpUTxHBcHRbJUGNePqcKMrhMl4/YNjdXodYlyw07/ABd4GCw="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/latestGrades.go",
    "grade": "A",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:07.389Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "dependencyInversionScore": "A*",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "A*",
      "openClosedScore": "B",
      "singleResponsibilityScore": "A"
    },
    "hash": "c8c5b33e9c1648f266d82b997b35c14984134ea6ffc407bb8638bdbd6d9ec71c",
    "id": "eJyVVE2P0zAQ/SsjH1DDhoRzUQ9QVEDsAlJ3T+sV8iaT1KpjB3sKRN3+d5TEzse20opTLM/Mmzcvb3xkwjl0Tury1hjFlmz7/frLRxazzOS4NppQE1uyWmR7USIUUhFarrmmpkbYSJ1fC0JHn6zI0YHUhLYQGcKRa06bLn2asdhJR8ZKdPA5nKLxyPVpAJ8BO7KHjI5dtDjoDL7hnxludE6mo2CRDlbDq2mkhRmRFqqE19NwC/WfvPteaQp3DkFAZqraOEkIe2yWwNlGKvwhaPf0fio3Z22V6tr0UA0sV1CJPS4qUd87slKXDz4UtYw5FcbCzxh2Y74VukTYzblw2mMXLVGjFYTrwOkrNn6aJgm8BrxkRtC35CQLaMOYey4x4F/pyLUNZvzv99g8vAtRz+S8PrmVFW5JVHXyAQtjcWA0BKKx+plGXQ9YBcoh69QfToDK4Vj8cmlXeOpH9XZZG/0bLd2I+tZslcxwMYOJvH/S9KK8kFls00HAQctfh84G8Cgc5mA0BNFB6BzmhugdefGXFcOvmq0s9CaJ/Hdm+lACV8DZE2dwNa8dpzibF7L+pp2hEjWYAoJDyYAA1yWNt4mnfi6cl/pG1HDB089XyGf3HMIuDDkxvI1BoZ6ARtHLS9E194aYNViBqGvU+WJ6O8BEwRdBz2lWpx2LWdCYLVl659C6dIfaNkpUj2l1UCRrhWn7mCos6E2mZNq/oamavC5JadjpH1rTFm8="
  },
  {
    "assessingTool": "Complexity",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/latestGrades.go",
    "grade": "A-",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:08.388Z",
    "codeReview": {
      "review": "Congratulations! Your most recent code changes passed."
    },
    "gradingDetails": {
      "grades": {
        "maintainabilityIndex": "B+",
        "qualityDesign": "B+",
        "readability": "A",
        "testability": "A-"
      },
      "issues": {
        "cyclomaticComplexity": 30,
        "dependenciesModules": 2,
        "functionMethodCounts": 30,
        "linesOfCode": 45,
        "nestingDepth": 20
      }
    },
    "hash": "4d926988444b4b0a09e874fb1e8fc5f61c0f934f7dff58bc10229554843a87e8",
    "id": "eJyVVE1v2zAM/SuEDkO8evbOGXrYAmQDtg4Dmp6qolBt2hEiS55EbzXS/PfBtuSPJkCxkwWRfHx8ftSRCefQOanLnTGKrdnGVLXCZ0kti1lmctwYTaiJrVktsoMoEQqpCC3XXFNbI2ylzn8IQkdfrcjRgdSEthAZwpFrTts+fZ6x2ktHxkp08C2counI9WkEXwA7sk1Gxz5aNDqDn/h3gRudk+kpWKTGang3j3QwE9JKlfB+Hu6g/pP30CtN4c4hCMhMVRsnCeGA7Ro420qFvwTtXz7PNeesq1J9mwGqhfU1VOKAq0rU946s1OWDD0UdY06FsfAYw37Kt0KXCPslF04H7KMlarSCcBM4fcfWT9MmgdeIlywI+pacZAFdGHPPJQZ8lo5c12DB//6A7cOnEPVMzuuTnazwlkRVJ1+wMBZHRmMgmqpfadT3gOtAOWSdhsMJUDmcit8u7QtPw6jeLhuj/6ClG1HvzK2SGa4WMJH3T5pelBcyi106CGi0/N30NoAn4TAHoyGIDkLnsDTE4MiLv6wYf9Vib2EwSeS/C9OHErgCzl44g6tl7TTF2byQDTfdDJWowRQQHEoGBLg+abpNPPVz4bzUN6KGC55+vUI+e+AQdmHMieFjDAr1DDSK3l6Kvrk3xKLBNYi6Rp2v5rcjTBR8EfScZ/XasZgFjdmapXcOrUv3qG2rRPWUVo0iWStMu8dUYUEfMiXT4Q1N1ex1SUrDTv8ASJoZIg=="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/filter/collectGrades.go",
    "grade": "A",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:08.977Z",
    "codeReview": {
      "detailedReview": {
        "tasks": [
          {
            "done": false,
            "titleTask": "liskovSubstitution",
            "violatingCode": "The provided code snippet demonstrates a violation of the Liskov Substitution Principle (LSP) due to inconsistent return values. Specifically, the code returns different values for the same grade in different cases. For example, the code returns 90 for \"A+\" (line 32), but then returns 85 for \"A\" (line 34). Also, the code returns 20 for \"F\" (line 58) and for unrecognized grades (line 62). This inconsistency makes it difficult to substitute different grades without unexpected behavior.\n",
            "codeResolution": "The provided code snippet exhibits a potential violation of the Liskov Substitution Principle (LSP) due to inconsistent return values. Specifically, the \"F\" grade and unrecognized grades return 20, while other grades return their minimum scores.\n\nRefactoring Strategy:\n\nEnsure all grades return a value consistent with their meaning.\n\n```\n\tcase \"F\":\n\t\treturn 0 // Or the actual minimum score for F\n\tdefault:\n\t\treturn 0 // Or a default value indicating an invalid grade\n```\n",
            "severity": "Critical",
            "rationale": "The provided code snippet, specifically lines 32, 34, 40, 46, 52, 58, and 60, contains errors that violate the Liskov Substitution Principle (LSP). The presence of unreachable code (lines 34, 40, 46, 52, 58, and 60) means that the behavior of the function is not consistent. This can lead to unexpected results, making the code harder to understand, test, and maintain. It could also affect performance if the compiler attempts to execute these unreachable lines.\n",
            "lineStart": 34,
            "lineEnd": 62,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "interfaceSegregation",
            "violatingCode": "The provided code snippet, specifically lines 31-62, demonstrates a violation of the Interface Segregation Principle (ISP). The `switch` statement within the function is responsible for mapping letter grades to numerical scores. The issue is that the function is trying to handle all possible grades (A+ to F) within a single block of code. This violates ISP because the function is doing too much, and it would be better to break it down into smaller, more focused functions or classes.\n",
            "codeResolution": "The provided code snippet, specifically lines 31-62, demonstrates a switch statement that maps letter grades to numerical scores. This code does not directly relate to the Interface Segregation Principle (ISP). ISP focuses on the design of interfaces, ensuring they are specific to the needs of the clients that use them. This code snippet is a simple mapping function and does not involve interfaces. Therefore, no specific refactoring for ISP is applicable here.\n",
            "severity": "Critical",
            "rationale": "The provided code snippet, specifically lines 32, 34, 40, 46, 52, 60, and 62, demonstrates a potential issue related to the Interface Segregation Principle (ISP). The code's structure, with multiple `return` statements within a `switch` case, could be improved. This could affect maintainability because any changes to the grading system would require modifying this single block of code, increasing the risk of errors. It doesn't directly affect performance or correctness, but it does make the code less readable and harder to understand.\n",
            "lineStart": 31,
            "lineEnd": 62,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "singleResponsibility",
            "violatingCode": "The provided code snippet, specifically lines 31-62, demonstrates a violation of the Single Responsibility Principle (SRP). The code is responsible for multiple concerns: mapping letter grades to numerical scores and handling edge cases for unrecognized grades. The switch statement with multiple return statements tightly couples the grade-to-score conversion logic within a single block of code.\n",
            "codeResolution": "The provided code snippet exhibits a lack of Single Responsibility Principle (SRP). The switch statement is responsible for both mapping letter grades to numerical scores and handling edge cases (unrecognized grades, F grade).\n\nRefactoring Strategy: Extract the grade-to-score mapping into a separate data structure (e.g., a map or a lookup table). This isolates the mapping logic, making the code more maintainable and easier to extend.\n\n```go\ngradeScores := map[string]int{\n    \"A+\": 90,\n    \"A\":  85,\n    \"A-\": 80,\n    \"B+\": 75,\n    \"B\":  70,\n    \"B-\": 65,\n    \"C+\": 60,\n    \"C\":  55,\n    \"C-\": 50,\n    \"D+\": 45,\n    \"D\":  40,\n    \"D-\": 30,\n    \"F\":  20,\n}\n\n// Use the map to get the score\nscore, ok := gradeScores[grade]\nif !ok {\n    return 20 // Default for unrecognized grades\n}\nreturn score\n```\n",
            "severity": "High",
            "rationale": "The provided code snippet violates the Single Responsibility Principle (SRP) because it combines grade-to-score conversion logic with handling edge cases (unrecognized grades, F grade). This matters because it reduces maintainability. If the grading system changes, both the core conversion and the edge case handling must be updated together, increasing the risk of errors. This could also affect correctness if the edge case logic is not properly aligned with the core grading logic.\n",
            "lineStart": 31,
            "lineEnd": 62,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "dependencyInversion",
            "violatingCode": "The provided code snippet, specifically lines 31-62, directly implements a grade-to-score mapping using a `switch` statement. This approach tightly couples the grading logic within the function. The function directly returns integer values based on string inputs.\n",
            "codeResolution": "The provided code snippet lacks context, making it difficult to assess Dependency Inversion directly. However, based on the structure, it appears to be a grade-to-score mapping.\n\n**Code Resolution:**\n\nThe code could benefit from using a data structure (e.g., a map or dictionary) to store the grade-to-score mappings. This approach enhances maintainability and testability.\n\n**Example of Improved Code:**\n\n```\ngradeScores := map[string]int{\n\t\"A+\": 90,\n\t\"A\":  85,\n\t\"A-\": 80,\n\t\"B+\": 75,\n\t\"B\":  70,\n\t\"B-\": 65,\n\t\"C+\": 60,\n\t\"C\":  55,\n\t\"C-\": 50,\n\t\"D+\": 45,\n\t\"D\":  40,\n\t\"D-\": 30,\n\t\"F\":  20,\n}\n\n// To get the score:\nscore, ok := gradeScores[grade]\nif !ok {\n\tscore = 20 // Default for unrecognized grades\n}\n```\n",
            "severity": "Critical",
            "rationale": "The provided code snippet, specifically lines 32, 34, 40, 46, 52, 58, and 60, directly impacts the Dependency Inversion Principle (DIP). The hardcoded return values tightly couple the grade evaluation logic to the specific numerical score thresholds. This lack of abstraction makes the code less flexible. Any change to the grading system (e.g., different score ranges) necessitates direct code modification, affecting maintainability. This could lead to errors if not all instances are updated correctly.\n",
            "lineStart": 31,
            "lineEnd": 62,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "openClosed",
            "violatingCode": "The provided code snippet, specifically lines 31-62, demonstrates a violation of the Open/Closed Principle. The `switch` statement directly maps letter grades to numerical scores.\n\n```\ncase \"A+\":\n    return 90\ncase \"A\":\n    return 85\n```\n\nAny modification to the grading system (e.g., adding new grades, changing score thresholds) necessitates altering this `switch` statement, thus violating the principle.\n",
            "codeResolution": "The provided code snippet, specifically the `switch` statement, violates the Open/Closed Principle (OCP). Adding a new grade or modifying the scoring system requires modifying the existing code.\n\nRefactoring Strategy:\n\n1.  **Introduce a Grade Interface:** Define an interface (e.g., `Grade`) with a method to get the minimum score.\n2.  **Implementations for Each Grade:** Create concrete classes (e.g., `APlusGrade`, `AGrade`) implementing the `Grade` interface. Each class encapsulates the logic for its respective grade.\n3.  **Use a Map or Strategy Pattern:** Use a map or strategy pattern to map grade strings to their corresponding `Grade` implementations.\n\nExample (Conceptual):\n\n```\ninterface Grade {\n    int getMinimumScore();\n}\n\nclass APlusGrade implements Grade {\n    @Override\n    public int getMinimumScore() {\n        return 90;\n    }\n}\n\n// ... other grade implementations\n\nMap<String, Grade> gradeMap = new HashMap<>();\ngradeMap.put(\"A+\", new APlusGrade());\n// ... populate the map\n```\n\nThis approach allows for adding new grades without modifying existing code, adhering to OCP.\n",
            "severity": "Critical",
            "rationale": "The provided code snippet violates the Open/Closed Principle because adding or modifying grading scales requires altering the existing `switch` statement. This lack of extensibility can affect maintainability, as each change necessitates code modification and testing. It increases the risk of introducing errors and makes it harder to adapt to future grading system requirements.\n",
            "lineStart": 31,
            "lineEnd": 62,
            "status": ""
          }
        ],
        "codeReviewTitle": "SOLID Code Review"
      }
    },
    "gradingDetails": {
      "dependencyInversionScore": "F",
      "interfaceSegregationScore": "F",
      "liskovSubstitutionScore": "F",
      "openClosedScore": "F",
      "singleResponsibilityScore": "C-"
    },
    "codeDiff": {
      "oldCode": "package filter\n\ntype CollectGrades interface {\n\tCollectGrades(histories Histories, threshold string) []GradeDetails\n}\n\ntype GradeCollection struct {\n\tGradeCalculator GradeCalculator\n}\n\nfunc NewGradeCollection(calculator GradeCalculator) CollectGrades {\n\treturn &GradeCollection{\n\t\tGradeCalculator: calculator,\n\t}\n}\n\nfunc (g *GradeCollection) CollectGrades(histories Histories, threshold string) []GradeDetails {\n\tgradeDetails := []GradeDetails{}\n\tfor _, history := range histories {\n\t\tnewDetails := NewGradeDetails(history.Grade, g.GradeCalculator.GradeNumericalValue(history.Grade), history.FilePath, history.AssessingTool, history.TimeStamp)\n\t\tnewDetails.GetCoverage(g.GradeCalculator.GradeNumericalValue(threshold))\n\t\tgradeDetails = append(gradeDetails, newDetails)\n\n\t}\n\treturn gradeDetails\n}\n\ntype GradeCalculator interface {\n\tGradeNumericalValue(grade string) int\n}\n\ntype GradeStringCalculator struct{}\n\nfunc NewGradeStringCalculator() GradeCalculator {\n\treturn &GradeStringCalculator{}\n}\n\nfunc (g *GradeStringCalculator) GradeNumericalValue(grade string) int {\n\tswitch grade {\n\tcase \"A+\":\n\t\treturn 90 // Minimum score for A+ in the new system\n\tcase \"A\":\n\t\treturn 85 // Minimum score for A\n\tcase \"A-\":\n\t\treturn 80 // Minimum score for A-\n\tcase \"B+\":\n\t\treturn 75 // Minimum score for B+\n\tcase \"B\":\n\t\treturn 70 // Minimum score for B\n\tcase \"B-\":\n\t\treturn 65 // Minimum score for B-\n\tcase \"C+\":\n\t\treturn 60 // Minimum score for C+\n\tcase \"C\":\n\t\treturn 55 // Minimum score for C\n\tcase \"C-\":\n\t\treturn 50 // Minimum score for C-\n\tcase \"D+\":\n\t\treturn 45 // Minimum score for D+\n\tcase \"D\":\n\t\treturn 40 // Minimum score for D\n\tcase \"D-\":\n\t\treturn 30 // Minimum score for D- (Lowest passing grade)\n\tcase \"F\":\n\t\t// Although F is for scores below 30, the request is to return 30\n\t\t// to maintain similarity with the previous system's representative F score.\n\t\treturn 20\n\tdefault:\n\t\t// For any unrecognized grade, return 30, aligning with the F case\n\t\t// and the previous system's representative F score location.\n\t\treturn 20\n\t}\n}",
      "newCode": "package filter\n\ntype CollectGrades interface {\n\tCollectGrades(histories Histories, threshold string) []GradeDetails\n}\n\ntype GradeCollection struct {\n\tGradeCalculator GradeCalculator\n}\n\nfunc NewGradeCollection(calculator GradeCalculator) CollectGrades {\n\treturn &GradeCollection{\n\t\tGradeCalculator: calculator,\n\t}\n}\n\nfunc (g *GradeCollection) CollectGrades(histories Histories, threshold string) []GradeDetails {\n\tgradeDetails := []GradeDetails{}\n\tfor _, history := range histories {\n\t\tnewDetails := NewGradeDetails(history.Grade, g.GradeCalculator.GradeNumericalValue(history.Grade), history.FilePath, history.AssessingTool, history.TimeStamp)\n\t\tnewDetails.GetCoverage(g.GradeCalculator.GradeNumericalValue(threshold))\n\t\tgradeDetails = append(gradeDetails, newDetails)\n\n\t}\n\treturn gradeDetails\n}\n\ntype GradeCalculator interface {\n\tGradeNumericalValue(grade string) int\n}\n\ntype GradeStringCalculator struct{}\n\nfunc NewGradeStringCalculator() GradeCalculator {\n\treturn &GradeStringCalculator{}\n}\n\nfunc (g *GradeStringCalculator) GradeNumericalValue(grade string) int {\n\tswitch grade {\n\tcase \"A*\":\n\t\treturn 5\n\tcase \"A\":\n\t\treturn 4\n\tcase \"B\":\n\t\treturn 3\n\tcase \"C\":\n\t\treturn 2\n\tcase \"D\":\n\t\treturn 1\n\tdefault:\n\t\treturn 0\n\t}\n}\n",
      "changes": [
        {
          "oldCode": "\tcase \"A+\":\n\t\treturn 90 // Minimum score for A+ in the new system",
          "newCode": "\tcase \"A*\":\n\t\treturn 5",
          "reason": "Modified",
          "start": 40,
          "end": 41,
          "grade": "F"
        },
        {
          "oldCode": "\t\treturn 85 // Minimum score for A\n\tcase \"A-\":\n\t\treturn 80 // Minimum score for A-\n\tcase \"B+\":\n\t\treturn 75 // Minimum score for B+",
          "newCode": "\t\treturn 4",
          "reason": "Modified",
          "start": 43,
          "end": 47,
          "grade": "F"
        },
        {
          "oldCode": "\t\treturn 70 // Minimum score for B\n\tcase \"B-\":\n\t\treturn 65 // Minimum score for B-\n\tcase \"C+\":\n\t\treturn 60 // Minimum score for C+",
          "newCode": "\t\treturn 3",
          "reason": "Modified",
          "start": 49,
          "end": 53,
          "grade": "F"
        },
        {
          "oldCode": "\t\treturn 55 // Minimum score for C\n\tcase \"C-\":\n\t\treturn 50 // Minimum score for C-\n\tcase \"D+\":\n\t\treturn 45 // Minimum score for D+",
          "newCode": "\t\treturn 2",
          "reason": "Modified",
          "start": 55,
          "end": 59,
          "grade": "F"
        },
        {
          "oldCode": "\t\treturn 40 // Minimum score for D\n\tcase \"D-\":\n\t\treturn 30 // Minimum score for D- (Lowest passing grade)\n\tcase \"F\":\n\t\t// Although F is for scores below 30, the request is to return 30\n\t\t// to maintain similarity with the previous system's representative F score.\n\t\treturn 20",
          "newCode": "\t\treturn 1",
          "reason": "Modified",
          "start": 61,
          "end": 67,
          "grade": "F"
        },
        {
          "oldCode": "\t\t// For any unrecognized grade, return 30, aligning with the F case\n\t\t// and the previous system's representative F score location.\n\t\treturn 20",
          "newCode": "\t\treturn 0",
          "reason": "Modified",
          "start": 69,
          "end": 71,
          "grade": "F"
        },
        {
          "reason": "Added",
          "start": 74,
          "end": 74,
          "grade": "F"
        }
      ]
    },
    "hash": "773b5199665a296d1c072852738d2875b000a3e9c34d68d0da8c052f2f8634b0",
    "id": "eJydll9v0zAUxb/KVR6gZWkzARtQaQ9dqw6kMZA2eKEIee5tYuHYwb5ZFap9d5Q4S9xk4d9bc+1zzs83N032AbMWrRUqvtFaBrPg+sPlu2UQBlxvcKEVoaJgFmSMf2cxwlZIQrNWa0VFhrDQUiKnC8M2aEEoQrNlHGG/Vms6WBwlwpI2Ai28ffgVAiUGbaLlBiwZoeIxfPla7V8iMSHtWt03WVW99hRalYqck4tya0zyXDLSBjrXtc02VxyucNdxGvFB4bhzwirMIOVGwZOOTbXWQ5lB6x6WO+59mFEMzzo2ncj/65sDjf3K7KyzZ19i0FYb+BaCSynKXYapGKGNrc+lcOdZPXSxLtWUxbQqhhBPO21w11d5ikZwJj8zmeOhaNxATFdC4kdGSVuZ+0Palm9EitfE0mzcZZxeIC30HRoW4+jvaJqejmu3g/adAcsyVJuRXw2hTSxF7vY2ExL/dpLboes8N4/BVVbNzRaKen7X1Zrn6p6PfX/yuztH4x5Rf867ov3jc9zdVlv/6TQu0O4E8cS1zVU4swjrYH60DmbuptRQb44hiuC9UCLNU7BcG4RylOdHIBRQguWdAVtYwtQ36vq8Phnw8UWTnmoofeLJznvQrwbCzo98WU81EHbui3qIp0NZPuKih3g6ELbwERdd1clA2MIX9RBPhrJ8xGUP8eVA2NJHXPZUA2FLX9RDfDGkmsDoUu/QEmSs+mNyUzv23FaNWRTBXFKi8ziBFQhbWVRmFm5R6h28OA6roTX4Iy9NhQXS0EA0NqQhZUIREwqsSIVkRlABO0FJpc8M3gmd23ryn1owmBm0qIiRuENYudzpwSmfVwEb3LJcUsu80gaYKiBXBrmOlfiJG3fMsEULgUkRq7IDDcUKyhY0Pkxt/gkOpOasfBU+Rln+7QRhsK1fEcEsiD5ZNDZKUJlCsvQ2SnNJIpMYlZ8wErc04VJE7ssl4v7LdRrr4P4Xx7BCxQ=="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/report.go",
    "grade": "A+",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:09.189Z",
    "codeReview": {
      "review": "Congratulations! Your most recent code changes passed."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "codeDiff": {
      "oldCode": "package report\n\nimport (\n\t\"codeleft-cli/filter\" // Assuming this path is correct\n\t\"fmt\"\n\t\"log\"\n)\n\n// GenerateReport orchestrates the report generation process.\n// It depends on abstractions (ReportWriter) and coordinates different components.\nfunc GenerateReport(gradeDetails []filter.GradeDetails, outputPath string, thresholdGrade string, writer ReportWriter) error {\n\tif len(gradeDetails) == 0 {\n\t\tlog.Println(\"Warning: No grade details provided to generate report.\")\n\t\t// Handle appropriately - maybe write an empty report or return specific error\n\t\t// Creating empty data for the writer\n\t\treturn writer.Write(ReportViewData{ ThresholdGrade: thresholdGrade }, outputPath)\n\t}\n\n\t// 1. Build the tree structure\n\tbuilder := NewTreeBuilder(NewSeparatorPathSplitter(), NewDefaultNodeCreator())\n\tgroupedDetails := builder.GroupGradeDetailsByPath(gradeDetails)\n\trootNodes := builder.BuildReportTree(groupedDetails)\n\n\t// 2. Calculate coverages and aggregate stats\n\tcalculator := NewCoverageCalculator(thresholdGrade)\n\tstats := NewGlobalStats()\n\tfor _, node := range rootNodes {\n\t\tcalculator.CalculateNodeCoverages(node, stats) // Modifies nodes and stats\n\t}\n\n\t// 3. Sort the tree (optional, could be done after building or before writing)\n\tsortReportNodes(rootNodes)\n\n    // 4. Calculate final overall averages\n    overallAverages, totalAverage, allTools := calculator.CalculateOverallAverages(stats)\n\n\t// 5. Prepare data for the view\n\tviewData := ReportViewData{\n\t\tRootNodes:       rootNodes,\n\t\tAllTools:        allTools, // Already sorted by calculator\n\t\tOverallAverages: overallAverages,\n\t\tTotalAverage:    totalAverage,\n\t\tThresholdGrade:  thresholdGrade,\n\t}\n\n\t// 6. Write the report using the injected writer\n\terr := writer.Write(viewData, outputPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to write report: %w\", err)\n\t}\n\n\tfmt.Printf(\"Successfully generated repository report: %s\\n\", outputPath)\n\treturn nil\n}",
      "newCode": "package report\n\nimport (\n\t\"codeleft-cli/filter\" // Assuming this path is correct\n\t\"fmt\"\n\t\"log\"\n)\n\n// GenerateReport orchestrates the report generation process.\n// It depends on abstractions (ReportWriter) and coordinates different components.\nfunc GenerateReport(gradeDetails []filter.GradeDetails, outputPath string, thresholdGrade string, writer ReportWriter) error {\n\tif len(gradeDetails) == 0 {\n\t\tlog.Println(\"Warning: No grade details provided to generate report.\")\n\t\t// Handle appropriately - maybe write an empty report or return specific error\n\t\t// Creating empty data for the writer\n\t\treturn writer.Write(ReportViewData{ ThresholdGrade: thresholdGrade }, outputPath)\n\t}\n\n\t// 1. Build the tree structure\n\tbuilder := NewTreeBuilder()\n\tgroupedDetails := builder.GroupGradeDetailsByPath(gradeDetails)\n\trootNodes := builder.BuildReportTree(groupedDetails)\n\n\t// 2. Calculate coverages and aggregate stats\n\tcalculator := NewCoverageCalculator(thresholdGrade)\n\tstats := NewGlobalStats()\n\tfor _, node := range rootNodes {\n\t\tcalculator.CalculateNodeCoverages(node, stats) // Modifies nodes and stats\n\t}\n\n\t// 3. Sort the tree (optional, could be done after building or before writing)\n\tsortReportNodes(rootNodes)\n\n    // 4. Calculate final overall averages\n    overallAverages, totalAverage, allTools := calculator.CalculateOverallAverages(stats)\n\n\t// 5. Prepare data for the view\n\tviewData := ReportViewData{\n\t\tRootNodes:       rootNodes,\n\t\tAllTools:        allTools, // Already sorted by calculator\n\t\tOverallAverages: overallAverages,\n\t\tTotalAverage:    totalAverage,\n\t\tThresholdGrade:  thresholdGrade,\n\t}\n\n\t// 6. Write the report using the injected writer\n\terr := writer.Write(viewData, outputPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to write report: %w\", err)\n\t}\n\n\tfmt.Printf(\"Successfully generated repository report: %s\\n\", outputPath)\n\treturn nil\n}",
      "changes": [
        {
          "oldCode": "\tbuilder := NewTreeBuilder(NewSeparatorPathSplitter(), NewDefaultNodeCreator())",
          "newCode": "\tbuilder := NewTreeBuilder()",
          "reason": "Modified",
          "start": 20,
          "end": 20
        }
      ]
    },
    "hash": "9c99e28f283cc42383f33105cdf2cf0ee57cd78b0f12b505440ef4b9eb2df8b4",
    "id": "eJxtVctu6zYQ/ZWpgAIyoEj39rUwkEUeRdpFk+DabRZVUdDiSGZLk8JwFMMI8u/FkJJi+TabyMN5nHNmOHzLVAgYgnHd1nubrbOnl5vN89X26fnq86esyBqv8c47RsfZOutV86/qEAh7T1y72pmDfEFeu5rr6G2x5avGmqo1lpHqDKoKbkIYDsZ1wHsToFe8BxOg8UTYcIptD1xn6dP6Tj5XUqCq4AEdkmL8EquCp2aPgcUSgPcTGuiSm/EOevINhlDG8F8ZNPbodADvQO0ktBG3AHlK+UKGkVagnIbGe9LGxeTatC0SOobGH3rv0LHkbAfXXIDKO1Ia75GVsQH+/CtxLx/OrAX4gfuBn4V8YDKuK4D3hGHvrY6es/kYAcESHRJ5gjeRyLRg0S2KruD6Gj6l45qt78pnMo6ty+vsRZEzrlvDo4cYA3pE2pN/NRo1sJ/0m/Qs62yVklUV/KKctgiq78n3ZBSjPcEVHNRphwktKAd46Pk0tcMTEPJADkKPjWlNkxjMOe8IFctMpDCtWEHrKbY0CZBcxyzJVEY1xr79YfB4r1i9wXah4/pS1/dz8SOrd5mtCONzCbeDsTrWZcLYhaHhgVA8dnKGBOtreMTjlhBvkyV/xOMGe0WKPUneTW8NM1K+KsT1Hls1WH6UCyRMPeWrWLojP/Sop2FZX8NYo3yQk/OZuT1J4mWfJQV5HxMvoiOuJIzAzJd1VjPh70q4U7YZrPS68a9IqsMQh191HWEn9sCKgwQ0o6ufJLgbI+7mg3ypdkQY48eIB+t3ym7EksdD6fLfBTivUVxIOdkpM6dxhj8qlzPeqOYEOZcERYK6ki3zm9emNRhi5sRo5vHR8O9L2MiAzv3OfS/rQNkCGj9YDTsE7R2CauUWRn1lTj3BDltPaTyN6xJTT5xUj+jzmUdUHAAE2Q/nmrfGKQuRhbWgRjbJd7TejMYC2LOafhagrJU9HZX9P32eluF50mam/mMJzyQzi8vr9mrwKC6v44WS9BdXLPXky0RuDelvZlskh5sR4HQ+Iy7iM2AJlT6BaIYadqczEin+gsD6K0GS2/ZMlVhqIdPoc7ETLpZCsZyKn0qIq+X8RRlCerIQjPsHG4H8sZiQ4o1YrKVJv6/WjWll+cE31+CMnQZ8XGztgcufZTO2eZ21yti0jtNWTUjW8O2xzgrJcb69JDJueYncDI28ee1g7Wne5TomCIY9nT5yhbp2ku4C5IjHGVu796zIWmNRDrN1Vv0ekEK1R0cnqw676jBYNr3FavHkpwrjv7Lz2ft/wgUOmA=="
  },
  {
    "assessingTool": "Complexity",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/report.go",
    "grade": "A",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:11.336Z",
    "codeReview": {
      "review": "Congratulations! Your most recent code changes passed."
    },
    "gradingDetails": {
      "grades": {
        "maintainabilityIndex": "A+",
        "qualityDesign": "A",
        "readability": "A",
        "testability": "A-"
      },
      "issues": {
        "cyclomaticComplexity": 45,
        "dependenciesModules": 3,
        "functionMethodCounts": 7,
        "linesOfCode": 54,
        "nestingDepth": 30
      }
    },
    "hash": "7423e878d1104f3780d6e10f969bebb440f87751bdfe98ee16b0d378d96aa6ca",
    "id": "eJxtVV1v6zYM/SucgQEO4Ovs+yFAHtp06Pawrrjtdh/mYVBs2tGmiAZFNwuK/veBku3GuetLHYof5xxS1GtmQsAQrO+eiVy2yXZ07B3+a+WcFVlNDe7IC3rJNllv6n9Mh8DYE0vlK2+P+gV55SuporfDVj7Uzq5b6wS5ymC9hpsQhqP1HcjBBuiNHMAGqIkZa0mx7VGqLH066vRzpQXWa7hHj2wEP8aqQFwfMIhaAshhQgNdcrPkoWeqMYQyhv8s0GCPvglAHsxeQ2t1C5CnlJ/YCvIKjG+gJuLG+pi8sW2LjF6gpmNPHr1oznbw9RWovGPT4B2KsS7AH38m7uX9hbUAGqQf5FHJB2HruwLkwBgO5JroOZtPERAs0SEzMbyqRLYFh35RdAXbLXyVjitx1JWPbL04n1fZJ8Pe+m4DDwQxBpoRac/0YhtsQGjSb9KzrLJVSrZew0/GNw7B9D1Tz9YIujN8gKM57zGhBeMBj72cp3YQA6MM7CH0WNvW1onBnHPHaERnIoU1Rgy0xLGlSYDkOmZJpjKqMfbtd4unOyPmFZ4XOm6udX27FD+yetPZijC+LuF2sK6JdYUxdmGoZWBUj72eIcNmCw94embE22TJH/D0hL1hI8Sa96l3VgQ5XxXqeoetGZw86AVSpsT5KpbumIYem2lYNlsYa5T3enI5M7dnTbzss6Zgoph4ER1xJWEUZr6ss5oJf1PCzrh6cNrrml6QTYchDr/pOsZO7UGMBA2oR1eaJNiNEbv5IF+qHRHG+DHi3tHeuCe15PFQu/xXAZ4aVBc2XnfKzGmc4ffK5Yw3qjlBzjVBkaCudMv8Qo1tLYaYOTGaebw3/NsSnnRA537n1Os6MK6AmgbXwB6hIY9gWr2FUV+dU2LYY0ucxtP6LjEllqR6RJ/PPKLiAKDIvrvUvLXeOIgsnAMzskm+o/VmNBYgJGb6WYBxTrd0VPb/9Pl1GZ4nbWbq35fwyDqzuLxuLxZP6vIyXihNf3XFUk8+TuQ2kP5mtkVyuBkBTucz4iI+A47RNGdQzbCB/fmCRIq/IrD5TJDk9nyhSiy1kGn0udoJV0uhWE7FDyXE1XL5ogwhPVkI1v+NtUJ+X0zI8UYs1tKk32frxra6/OCLLXjrpgEfF1t7lPJH3YxtXmWtsS6t47RVE5INfHmqskJzXG4vjYxbXiOfhlrfvHZw7jzv8iYmCFaIz++5QlV5TXcFcsTjrav8W1ZkrXWoh9kmW/8WkMP6gJ7Pzhz36+PgxPYO14snP1UY/5UdZW//AaVID44="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/report.go",
    "grade": "A",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:11.749Z",
    "codeReview": {
      "detailedReview": {
        "tasks": [
          {
            "done": false,
            "titleTask": "dependencyInversion",
            "violatingCode": "The `violatingCode` is:\n\n```go\nbuilder := NewTreeBuilder(NewSeparatorPathSplitter(), NewDefaultNodeCreator())\n```\n\nThis code directly instantiates `SeparatorPathSplitter` and `NewDefaultNodeCreator` within the `NewTreeBuilder` function. This violates the Dependency Inversion Principle because `TreeBuilder` depends on concrete implementations rather than abstractions. This makes it harder to swap out these dependencies for testing or to use different splitting or node creation strategies.\n",
            "codeResolution": "The `dependencyInversion` in the provided code snippet is well-addressed. The `TreeBuilder` depends on abstractions (`PathSplitter`, `NodeCreator`) rather than concrete implementations. This design allows for flexibility and testability.\n\nNo immediate refactoring is needed. The code adheres to the Dependency Inversion Principle (DIP) by depending on abstractions.\n",
            "severity": "Critical",
            "rationale": "The `NewTreeBuilder` depends on concrete implementations `NewSeparatorPathSplitter()` and `NewDefaultNodeCreator()`. This violates the Dependency Inversion Principle. It matters because changes to `SeparatorPathSplitter` or `DefaultNodeCreator` directly impact `TreeBuilder`, reducing maintainability. This tight coupling can hinder testing and make it harder to swap out components, potentially affecting correctness if dependencies aren't properly managed.\n",
            "lineStart": 17,
            "lineEnd": 17,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "openClosed",
            "violatingCode": "The provided code snippet `builder := NewTreeBuilder(NewSeparatorPathSplitter(), NewDefaultNodeCreator())` does not directly demonstrate a violation of the Open/Closed Principle (OCP). The OCP focuses on the ability to extend the behavior of a module without modifying its source code. This line of code is instantiating a `TreeBuilder` with specific dependencies. Without further context, it's impossible to determine if this instantiation violates OCP.\n",
            "codeResolution": "The `NewTreeBuilder` function is tightly coupled with `NewSeparatorPathSplitter` and `NewDefaultNodeCreator`. To improve the Open/Closed Principle, introduce interfaces for the splitter and node creator. This allows for different implementations without modifying the `TreeBuilder`.\n\nRefactoring Strategy:\n\n1.  Define `PathSplitter` and `NodeCreator` interfaces.\n2.  Make `NewSeparatorPathSplitter` and `NewDefaultNodeCreator` implement these interfaces.\n3.  Modify `NewTreeBuilder` to accept `PathSplitter` and `NodeCreator` interfaces.\n\nExample:\n\n```go\ntype PathSplitter interface {\n    Split(path string) []string\n}\n\ntype NodeCreator interface {\n    CreateNode(name string) Node\n}\n\nfunc NewTreeBuilder(splitter PathSplitter, creator NodeCreator) *TreeBuilder {\n    return &TreeBuilder{splitter: splitter, creator: creator}\n}\n```\n",
            "severity": "Critical",
            "rationale": "The `Open/Closed Principle` is not directly addressed in the provided code snippet. The snippet shows the instantiation of a `TreeBuilder` with a `SeparatorPathSplitter` and a `DefaultNodeCreator`. The `Open/Closed Principle` would be relevant if there were a need to extend the functionality of the `TreeBuilder` without modifying its core structure. For example, adding support for a new type of path splitter or node creator should be possible without altering the `TreeBuilder` class itself. This promotes maintainability by reducing the risk of introducing bugs when adding new features and improves the system's ability to adapt to changing requirements.\n",
            "lineStart": 17,
            "lineEnd": 17,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "liskovSubstitution",
            "violatingCode": "The provided code snippet `builder := NewTreeBuilder(NewSeparatorPathSplitter(), NewDefaultNodeCreator())` does not directly demonstrate a violation of the Liskov Substitution Principle (LSP). LSP is about substitutability of subtypes for their base types. This line instantiates a `TreeBuilder` with a `SeparatorPathSplitter` and a `DefaultNodeCreator`. Without knowing the interfaces or base types involved, it's impossible to determine if LSP is violated here. The code itself is a simple instantiation and doesn't inherently break LSP.\n",
            "codeResolution": "The provided code snippet `builder := NewTreeBuilder(NewSeparatorPathSplitter(), NewDefaultNodeCreator())` demonstrates good adherence to the Liskov Substitution Principle (LSP). The `NewTreeBuilder` function likely accepts interfaces or abstract types for its dependencies (`PathSplitter` and `NodeCreator`). This design allows for different implementations of `PathSplitter` and `NodeCreator` to be used interchangeably without affecting the `TreeBuilder`'s functionality.\n\nNo specific refactoring is needed as the code snippet itself doesn't violate LSP. The design promotes LSP by using abstractions.\n",
            "severity": "Critical",
            "rationale": "Rationale:\n\nThe `NewTreeBuilder` function call is a potential area for Liskov Substitution Principle (LSP) concerns. If `NewTreeBuilder` relies on specific implementations of `SeparatorPathSplitter` or `DefaultNodeCreator`, substituting these dependencies with alternative implementations could lead to unexpected behavior. This could affect maintainability, as changes in the substituted classes might require modifications in `NewTreeBuilder`. It could also affect correctness if the substitutions don't fully adhere to the expected behavior of the original dependencies.\n",
            "lineStart": 17,
            "lineEnd": 17,
            "status": ""
          }
        ],
        "codeReviewTitle": "SOLID Code Review"
      }
    },
    "gradingDetails": {
      "dependencyInversionScore": "F",
      "interfaceSegregationScore": "A+",
      "liskovSubstitutionScore": "F",
      "openClosedScore": "F",
      "singleResponsibilityScore": "A+"
    },
    "codeDiff": {
      "oldCode": "package report\n\nimport (\n\t\"codeleft-cli/filter\" // Assuming this path is correct\n\t\"fmt\"\n\t\"log\"\n)\n\n// GenerateReport orchestrates the report generation process.\n// It depends on abstractions (ReportWriter) and coordinates different components.\nfunc GenerateReport(gradeDetails []filter.GradeDetails, outputPath string, thresholdGrade string, writer ReportWriter) error {\n\tif len(gradeDetails) == 0 {\n\t\tlog.Println(\"Warning: No grade details provided to generate report.\")\n\t\t// Handle appropriately - maybe write an empty report or return specific error\n\t\t// Creating empty data for the writer\n\t\treturn writer.Write(ReportViewData{ ThresholdGrade: thresholdGrade }, outputPath)\n\t}\n\n\t// 1. Build the tree structure\n\tbuilder := NewTreeBuilder(NewSeparatorPathSplitter(), NewDefaultNodeCreator())\n\tgroupedDetails := builder.GroupGradeDetailsByPath(gradeDetails)\n\trootNodes := builder.BuildReportTree(groupedDetails)\n\n\t// 2. Calculate coverages and aggregate stats\n\tcalculator := NewCoverageCalculator(thresholdGrade)\n\tstats := NewGlobalStats()\n\tfor _, node := range rootNodes {\n\t\tcalculator.CalculateNodeCoverages(node, stats) // Modifies nodes and stats\n\t}\n\n\t// 3. Sort the tree (optional, could be done after building or before writing)\n\tsortReportNodes(rootNodes)\n\n    // 4. Calculate final overall averages\n    overallAverages, totalAverage, allTools := calculator.CalculateOverallAverages(stats)\n\n\t// 5. Prepare data for the view\n\tviewData := ReportViewData{\n\t\tRootNodes:       rootNodes,\n\t\tAllTools:        allTools, // Already sorted by calculator\n\t\tOverallAverages: overallAverages,\n\t\tTotalAverage:    totalAverage,\n\t\tThresholdGrade:  thresholdGrade,\n\t}\n\n\t// 6. Write the report using the injected writer\n\terr := writer.Write(viewData, outputPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to write report: %w\", err)\n\t}\n\n\tfmt.Printf(\"Successfully generated repository report: %s\\n\", outputPath)\n\treturn nil\n}",
      "newCode": "package report\n\nimport (\n\t\"codeleft-cli/filter\" // Assuming this path is correct\n\t\"fmt\"\n\t\"log\"\n)\n\n// GenerateReport orchestrates the report generation process.\n// It depends on abstractions (ReportWriter) and coordinates different components.\nfunc GenerateReport(gradeDetails []filter.GradeDetails, outputPath string, thresholdGrade string, writer ReportWriter) error {\n\tif len(gradeDetails) == 0 {\n\t\tlog.Println(\"Warning: No grade details provided to generate report.\")\n\t\t// Handle appropriately - maybe write an empty report or return specific error\n\t\t// Creating empty data for the writer\n\t\treturn writer.Write(ReportViewData{ ThresholdGrade: thresholdGrade }, outputPath)\n\t}\n\n\t// 1. Build the tree structure\n\tbuilder := NewTreeBuilder()\n\tgroupedDetails := builder.GroupGradeDetailsByPath(gradeDetails)\n\trootNodes := builder.BuildReportTree(groupedDetails)\n\n\t// 2. Calculate coverages and aggregate stats\n\tcalculator := NewCoverageCalculator(thresholdGrade)\n\tstats := NewGlobalStats()\n\tfor _, node := range rootNodes {\n\t\tcalculator.CalculateNodeCoverages(node, stats) // Modifies nodes and stats\n\t}\n\n\t// 3. Sort the tree (optional, could be done after building or before writing)\n\tsortReportNodes(rootNodes)\n\n    // 4. Calculate final overall averages\n    overallAverages, totalAverage, allTools := calculator.CalculateOverallAverages(stats)\n\n\t// 5. Prepare data for the view\n\tviewData := ReportViewData{\n\t\tRootNodes:       rootNodes,\n\t\tAllTools:        allTools, // Already sorted by calculator\n\t\tOverallAverages: overallAverages,\n\t\tTotalAverage:    totalAverage,\n\t\tThresholdGrade:  thresholdGrade,\n\t}\n\n\t// 6. Write the report using the injected writer\n\terr := writer.Write(viewData, outputPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to write report: %w\", err)\n\t}\n\n\tfmt.Printf(\"Successfully generated repository report: %s\\n\", outputPath)\n\treturn nil\n}",
      "changes": [
        {
          "oldCode": "\tbuilder := NewTreeBuilder(NewSeparatorPathSplitter(), NewDefaultNodeCreator())",
          "newCode": "\tbuilder := NewTreeBuilder()",
          "reason": "Modified",
          "start": 20,
          "end": 20,
          "grade": "D"
        }
      ]
    },
    "hash": "7ea8c47a770606ee1934e5dfa0ee5429819abe8b313f3b2a486f89652a71bf37",
    "id": "eJxtVdtu40YM/RVWQAEZ0Mq9PxjIQy5FukCbDdbp7sOqKMYSJU87HgocKoYR5N8LzkiK5W1eInN4OeeQw3nJTAgYgvXdE5HLNtn2w+/v77Iiq6nBW/KCXrJN1pv6X9MhMPbEUvnK24N+QV75Sqro7bCVd7Wz69Y6Qa4yWK/hOoThYH0HsrcBeiN7sAFqYsZaUmx7kCpLn446/VxpgfUa7tEjG8GPsSoQ13sMopYAsp/QQJfcLHnomWoMoYzh7wUa7NE3AciD2WlorW4B8pTyM1tBXoHxDdRE3Fgfkze2bZHRC9R06MmjF83ZDr6+AJV3bBq8QzHWBfjyV+Je3p9ZC6BB+kEelXwQtr4rQPaMYU+uiZ6z+RgBwRIdMhPDi0pkW3DoF0VXcHUF36XjShx15SNbL87nVfbZsLe+28ADQYyBZkTaMz3bBhsQmvSb9CyrbJWSrdfwm/GNQzB9z9SzNYLuBO/gYE47TGjBeMBDL6epHcTAKAN7CD3WtrV1YjDnvGU0ojORwhojBlri2NIkQHIdsyRTGdUY+/bJ4vHOiHmBp4WOm0tdX8/Fj6xedbYijO9LuBmsa2JdYYxdGGoZGNVjp2fIsLmCBzw+MeJNsuQPeNxib9gIsebd9s6KIOerQl3vsDWDkwe9QMqUOF/F0h3T0GMzDcvmCsYa5b2enM/MzUkTL/usKZgoJl5ER1xJGIWZL+usZsI/lHBrXD047XVNz8imwxCH33QdY6f2IEaCBtSjK00S3I4Rt/NBvlQ7IozxY8S9o51xW7Xk8VC7/HcBnhpUFzZed8rMaZzht8rljDeqOUHONUGRoK50y/xBjW0thpg5MZp5vDX8xxK2OqBzv3PqdR0YV0BNg2tgh9CQRzCt3sKor84pMeywJU7jaX2XmBJLUj2iz2ceUXEAUGQ/nWveWm8cRBbOgRnZJN/Rej0aCxASM/0swDinCzoq+3/6fFiG50mbmfrPJTyyziwur9uzxaO6PI8XStNfXLHUk48TuQ2kv5ltkRyuR4DT+Yy4iM+AYzTNCVQzbGB3OiOR4i8IbL4SJLk9nakSSy1kGn0udsLFUiiWU/FLCXG1nL8oQ0hPFoL1/2CtkN8WE3K8EYu1NOn31bqxrS4/+OYKvHXTgI+LrT1I+atuxjavstZYl9Zx2qoJyQa+PVZZoTnOt5dGxi2vkduh1jevHZw7zbu8iQmCFeLTW65QVV7TXYAc8XjrKv+aFVlrHephtsnWfwbksN6j55Mzh936MDixvcP14slPFcZ/ZUfZ638lDgzb"
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/builder.go",
    "grade": "A+",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:12.262Z",
    "codeReview": {
      "review": "Congratulations! Your most recent code changes passed."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "codeDiff": {
      "oldCode": "package report\n\nimport (\n\t\"codeleft-cli/filter\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n)\n\n// CoverageData interface for abstracting coverage data.\ntype CoverageData interface {\n\tGetCoverage(tool string) (float64, bool)\n\tSetCoverage(tool string, coverage float64, ok bool)\n}\n\n// PathSplitter interface for splitting file paths.\ntype PathSplitter interface {\n\tSplit(path string) []string\n}\n\n// SeparatorPathSplitter splits paths by the OS-specific separator.\ntype SeparatorPathSplitter struct{}\n\nfunc NewSeparatorPathSplitter() PathSplitter {\n\treturn &SeparatorPathSplitter{}\n}\n\nfunc (s *SeparatorPathSplitter) Split(path string) []string {\n\treturn strings.Split(path, string(filepath.Separator))\n}\n\n// NodeCreator interface for creating ReportNode instances.\ntype NodeCreator interface {\n\tCreateFileNode(name string, path string, details []filter.GradeDetails) *ReportNode\n\tCreateDirectoryNode(name string, path string) *ReportNode\n}\n\n// DefaultNodeCreator is a concrete implementation of NodeCreator.\ntype DefaultNodeCreator struct{}\n\nfunc NewDefaultNodeCreator() NodeCreator {\n\treturn &DefaultNodeCreator{}\n}\n\nfunc (c *DefaultNodeCreator) CreateFileNode(name string, path string, details []filter.GradeDetails) *ReportNode {\n\treturn &ReportNode{\n\t\tName:    name,\n\t\tPath:    path,\n\t\tIsDir:   false,\n\t\tDetails: details,\n\t}\n}\n\nfunc (c *DefaultNodeCreator) CreateDirectoryNode(name string, path string) *ReportNode {\n\treturn &ReportNode{\n\t\tName:     name,\n\t\tPath:     path,\n\t\tIsDir:    true,\n\t\tChildren: []*ReportNode{},\n\t}\n}\n\n// TreeBuilder is responsible for constructing the ReportNode tree.\ntype TreeBuilder struct {\n\tpathSplitter PathSplitter\n\tnodeCreator  NodeCreator\n}\n\n// NewTreeBuilder creates a new TreeBuilder with provided dependencies.\nfunc NewTreeBuilder(pathSplitter PathSplitter, nodeCreator NodeCreator) *TreeBuilder {\n\treturn &TreeBuilder{\n\t\tpathSplitter: pathSplitter,\n\t\tnodeCreator:  nodeCreator,\n\t}\n}\n\n// GroupGradeDetailsByPath groups grade details by file path.\nfunc (tb *TreeBuilder) GroupGradeDetailsByPath(details []filter.GradeDetails) map[string][]filter.GradeDetails {\n\tgrouped := make(map[string][]filter.GradeDetails)\n\tfor _, d := range details {\n\t\t// Normalize path separators for consistency\n\t\tnormalizedPath := filepath.ToSlash(d.FileName)\n\t\tgrouped[normalizedPath] = append(grouped[normalizedPath], d)\n\t}\n\treturn grouped\n}\n\n// buildTree recursively builds the report tree from path parts.\nfunc (tb *TreeBuilder) buildTree(roots []*ReportNode, dirs map[string]*ReportNode, parts []string, fullPath string, details []filter.GradeDetails) []*ReportNode {\n\tif len(parts) == 0 {\n\t\treturn roots\n\t}\n\n\tvar parent *ReportNode\n\tcurrentPath := \"\"\n\n\tfor i, part := range parts {\n\t\tisLastPart := (i == len(parts)-1)\n\t\tif currentPath == \"\" {\n\t\t\tcurrentPath = part\n\t\t} else {\n\t\t\tcurrentPath = currentPath + \"/\" + part\n\t\t}\n\n\t\texistingNode, found := dirs[currentPath]\n\n\t\tif isLastPart {\n\t\t\tfileNode := tb.nodeCreator.CreateFileNode(part, fullPath, details)\n\t\t\tif parent == nil {\n\t\t\t\troots = append(roots, fileNode)\n\t\t\t} else {\n\t\t\t\tparent.Children = append(parent.Children, fileNode)\n\t\t\t}\n\t\t} else {\n\t\t\tif found {\n\t\t\t\tparent = existingNode\n\t\t\t} else {\n\t\t\t\tdirNode := tb.nodeCreator.CreateDirectoryNode(part, currentPath)\n\t\t\t\tdirs[currentPath] = dirNode\n\n\t\t\t\tif parent == nil {\n\t\t\t\t\troots = append(roots, dirNode)\n\t\t\t\t} else {\n\t\t\t\t\tchildExists := false\n\t\t\t\t\tfor _, child := range parent.Children {\n\t\t\t\t\t\tif child.Path == dirNode.Path {\n\t\t\t\t\t\t\tchildExists = true\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif !childExists {\n\t\t\t\t\t\tparent.Children = append(parent.Children, dirNode)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tparent = dirNode\n\t\t\t}\n\t\t}\n\t}\n\treturn roots\n}\n\n// BuildReportTree constructs the basic tree hierarchy from file paths.\n// It does not calculate coverage here.\nfunc (tb *TreeBuilder) BuildReportTree(groupedDetails map[string][]filter.GradeDetails) []*ReportNode {\n\troots := []*ReportNode{}\n\tdirs := make(map[string]*ReportNode)\n\n\tpaths := make([]string, 0, len(groupedDetails))\n\tfor p := range groupedDetails {\n\t\tpaths = append(paths, p)\n\t}\n\tsort.Strings(paths)\n\n\tfor _, fullPath := range paths {\n\t\tdetails := groupedDetails[fullPath]\n\t\tparts := tb.pathSplitter.Split(fullPath)\n\t\tif len(parts) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\troots = tb.buildTree(roots, dirs, parts, fullPath, details)\n\t}\n\n\treturn roots\n}",
      "newCode": "package report\n\nimport (\n\t\"codeleft-cli/filter\" // Assuming this path is correct\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n)\n\n// TreeBuilder is responsible for constructing the ReportNode tree.\n// SRP: Focused on tree building logic.\ntype TreeBuilder struct{}\n\nfunc NewTreeBuilder() *TreeBuilder {\n\treturn &TreeBuilder{}\n}\n\n// GroupGradeDetailsByPath groups the flat list of details into a map\n// where the key is the file path (FileName) and the value is a slice\n// of all GradeDetails for that path.\n// SRP: Focused on grouping input data.\nfunc (tb *TreeBuilder) GroupGradeDetailsByPath(details []filter.GradeDetails) map[string][]filter.GradeDetails {\n\tgrouped := make(map[string][]filter.GradeDetails)\n\tfor _, d := range details {\n\t\t// Normalize path separators for consistency\n\t\tnormalizedPath := filepath.ToSlash(d.FileName)\n\t\tgrouped[normalizedPath] = append(grouped[normalizedPath], d)\n\t}\n\treturn grouped\n}\n\n// BuildReportTree constructs the basic tree hierarchy from file paths.\n// It does not calculate coverage here.\nfunc (tb *TreeBuilder) BuildReportTree(groupedDetails map[string][]filter.GradeDetails) []*ReportNode {\n    roots := []*ReportNode{}\n    // Use a map to keep track of created directory nodes by their full path\n    // Ensures we don't create duplicate nodes for the same directory\n    dirs := make(map[string]*ReportNode)\n\n    // Sort paths for potentially more structured processing (optional but can help)\n    paths := make([]string, 0, len(groupedDetails))\n    for p := range groupedDetails {\n        paths = append(paths, p)\n    }\n    sort.Strings(paths)\n\n    for _, fullPath := range paths {\n        details := groupedDetails[fullPath] // Get the details for this file\n        parts := strings.Split(fullPath, \"/\")\n        if len(parts) == 0 {\n            continue // Skip empty paths\n        }\n\n        var parent *ReportNode\n        currentPath := \"\"\n\n        for i, part := range parts {\n            isLastPart := (i == len(parts)-1)\n            if currentPath == \"\" {\n                currentPath = part\n            } else {\n                currentPath = currentPath + \"/\" + part\n            }\n\n            // Check if node already exists (could be a dir created by a previous path)\n            existingNode, found := dirs[currentPath]\n\n            if isLastPart { // This is the file part\n                fileNode := &ReportNode{\n                    Name:           part,\n                    Path:           fullPath, // Store the full original path\n                    IsDir:          false,\n                    Details:        details, // Store associated details\n                    ToolCoverages:  make(map[string]float64),\n                    ToolCoverageOk: make(map[string]bool),\n                }\n                if parent == nil { // File in root\n                    roots = append(roots, fileNode)\n                } else {\n                    parent.Children = append(parent.Children, fileNode)\n                }\n                // Don't add files to the 'dirs' map\n            } else { // This is a directory part\n                if found {\n                    // Directory node already exists, just update parent pointer\n                    parent = existingNode\n                } else {\n                    // Create new directory node\n                    dirNode := &ReportNode{\n                        Name:           part,\n                        Path:           currentPath, // Path up to this directory\n                        IsDir:          true,\n                        Children:       []*ReportNode{},\n                        ToolCoverages:  make(map[string]float64),\n                        ToolCoverageOk: make(map[string]bool),\n                    }\n                    dirs[currentPath] = dirNode // Add to map for lookup\n\n                    if parent == nil { // Directory in root\n                        roots = append(roots, dirNode)\n                    } else {\n                        // Check if child already exists in parent (can happen with sorting/processing order)\n                        childExists := false\n                        for _, child := range parent.Children {\n                            if child.Path == dirNode.Path {\n                                childExists = true\n                                break\n                            }\n                        }\n                        if !childExists {\n                            parent.Children = append(parent.Children, dirNode)\n                        }\n                    }\n                    parent = dirNode // This new dir becomes the parent for the next part\n                }\n            }\n        }\n    }\n    return roots\n}",
      "changes": [
        {
          "oldCode": "\t\"codeleft-cli/filter\"",
          "newCode": "\t\"codeleft-cli/filter\" // Assuming this path is correct",
          "reason": "Modified",
          "start": 4,
          "end": 4
        },
        {
          "oldCode": "\n// CoverageData interface for abstracting coverage data.\ntype CoverageData interface {\n\tGetCoverage(tool string) (float64, bool)\n\tSetCoverage(tool string, coverage float64, ok bool)\n}\n\n// PathSplitter interface for splitting file paths.\ntype PathSplitter interface {\n\tSplit(path string) []string\n}\n\n// SeparatorPathSplitter splits paths by the OS-specific separator.\ntype SeparatorPathSplitter struct{}\n\nfunc NewSeparatorPathSplitter() PathSplitter {\n\treturn &SeparatorPathSplitter{}\n}\n\nfunc (s *SeparatorPathSplitter) Split(path string) []string {\n\treturn strings.Split(path, string(filepath.Separator))\n}\n\n// NodeCreator interface for creating ReportNode instances.\ntype NodeCreator interface {\n\tCreateFileNode(name string, path string, details []filter.GradeDetails) *ReportNode\n\tCreateDirectoryNode(name string, path string) *ReportNode\n}\n\n// DefaultNodeCreator is a concrete implementation of NodeCreator.\ntype DefaultNodeCreator struct{}\n\nfunc NewDefaultNodeCreator() NodeCreator {\n\treturn &DefaultNodeCreator{}\n}\n\nfunc (c *DefaultNodeCreator) CreateFileNode(name string, path string, details []filter.GradeDetails) *ReportNode {\n\treturn &ReportNode{\n\t\tName:    name,\n\t\tPath:    path,\n\t\tIsDir:   false,\n\t\tDetails: details,\n\t}\n}\n\nfunc (c *DefaultNodeCreator) CreateDirectoryNode(name string, path string) *ReportNode {\n\treturn &ReportNode{\n\t\tName:     name,\n\t\tPath:     path,\n\t\tIsDir:    true,\n\t\tChildren: []*ReportNode{},\n\t}\n}\n",
          "reason": "Modified",
          "start": 9,
          "end": 62
        },
        {
          "oldCode": "type TreeBuilder struct {\n\tpathSplitter PathSplitter\n\tnodeCreator  NodeCreator\n}\n\n// NewTreeBuilder creates a new TreeBuilder with provided dependencies.\nfunc NewTreeBuilder(pathSplitter PathSplitter, nodeCreator NodeCreator) *TreeBuilder {\n\treturn &TreeBuilder{\n\t\tpathSplitter: pathSplitter,\n\t\tnodeCreator:  nodeCreator,\n\t}\n}\n\n// GroupGradeDetailsByPath groups grade details by file path.",
          "newCode": "// SRP: Focused on tree building logic.\ntype TreeBuilder struct{}\n\nfunc NewTreeBuilder() *TreeBuilder {\n\treturn &TreeBuilder{}\n}\n\n// GroupGradeDetailsByPath groups the flat list of details into a map\n// where the key is the file path (FileName) and the value is a slice\n// of all GradeDetails for that path.\n// SRP: Focused on grouping input data.",
          "reason": "Modified",
          "start": 64,
          "end": 77
        },
        {
          "oldCode": "}\n\n// buildTree recursively builds the report tree from path parts.\nfunc (tb *TreeBuilder) buildTree(roots []*ReportNode, dirs map[string]*ReportNode, parts []string, fullPath string, details []filter.GradeDetails) []*ReportNode {\n\tif len(parts) == 0 {\n\t\treturn roots\n\t}\n\n\tvar parent *ReportNode\n\tcurrentPath := \"\"\n\n\tfor i, part := range parts {\n\t\tisLastPart := (i == len(parts)-1)\n\t\tif currentPath == \"\" {\n\t\t\tcurrentPath = part\n\t\t} else {\n\t\t\tcurrentPath = currentPath + \"/\" + part\n\t\t}\n\n\t\texistingNode, found := dirs[currentPath]\n\n\t\tif isLastPart {\n\t\t\tfileNode := tb.nodeCreator.CreateFileNode(part, fullPath, details)\n\t\t\tif parent == nil {\n\t\t\t\troots = append(roots, fileNode)\n\t\t\t} else {\n\t\t\t\tparent.Children = append(parent.Children, fileNode)\n\t\t\t}\n\t\t} else {\n\t\t\tif found {\n\t\t\t\tparent = existingNode\n\t\t\t} else {\n\t\t\t\tdirNode := tb.nodeCreator.CreateDirectoryNode(part, currentPath)\n\t\t\t\tdirs[currentPath] = dirNode\n\n\t\t\t\tif parent == nil {\n\t\t\t\t\troots = append(roots, dirNode)\n\t\t\t\t} else {\n\t\t\t\t\tchildExists := false\n\t\t\t\t\tfor _, child := range parent.Children {\n\t\t\t\t\t\tif child.Path == dirNode.Path {\n\t\t\t\t\t\t\tchildExists = true\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif !childExists {\n\t\t\t\t\t\tparent.Children = append(parent.Children, dirNode)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tparent = dirNode\n\t\t\t}\n\t\t}\n\t}\n\treturn roots\n}\n",
          "newCode": "}\n",
          "reason": "Modified",
          "start": 86,
          "end": 141
        },
        {
          "oldCode": "\troots := []*ReportNode{}\n\tdirs := make(map[string]*ReportNode)\n\n\tpaths := make([]string, 0, len(groupedDetails))\n\tfor p := range groupedDetails {\n\t\tpaths = append(paths, p)\n\t}\n\tsort.Strings(paths)\n\n\tfor _, fullPath := range paths {\n\t\tdetails := groupedDetails[fullPath]\n\t\tparts := tb.pathSplitter.Split(fullPath)\n\t\tif len(parts) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\troots = tb.buildTree(roots, dirs, parts, fullPath, details)\n\t}\n\n\treturn roots",
          "newCode": "    roots := []*ReportNode{}\n    // Use a map to keep track of created directory nodes by their full path\n    // Ensures we don't create duplicate nodes for the same directory\n    dirs := make(map[string]*ReportNode)\n\n    // Sort paths for potentially more structured processing (optional but can help)\n    paths := make([]string, 0, len(groupedDetails))\n    for p := range groupedDetails {\n        paths = append(paths, p)\n    }\n    sort.Strings(paths)\n\n    for _, fullPath := range paths {\n        details := groupedDetails[fullPath] // Get the details for this file\n        parts := strings.Split(fullPath, \"/\")\n        if len(parts) == 0 {\n            continue // Skip empty paths\n        }\n\n        var parent *ReportNode\n        currentPath := \"\"\n\n        for i, part := range parts {\n            isLastPart := (i == len(parts)-1)\n            if currentPath == \"\" {\n                currentPath = part\n            } else {\n                currentPath = currentPath + \"/\" + part\n            }\n\n            // Check if node already exists (could be a dir created by a previous path)\n            existingNode, found := dirs[currentPath]\n\n            if isLastPart { // This is the file part\n                fileNode := &ReportNode{\n                    Name:           part,\n                    Path:           fullPath, // Store the full original path\n                    IsDir:          false,\n                    Details:        details, // Store associated details\n                    ToolCoverages:  make(map[string]float64),\n                    ToolCoverageOk: make(map[string]bool),\n                }\n                if parent == nil { // File in root\n                    roots = append(roots, fileNode)\n                } else {\n                    parent.Children = append(parent.Children, fileNode)\n                }\n                // Don't add files to the 'dirs' map\n            } else { // This is a directory part\n                if found {\n                    // Directory node already exists, just update parent pointer\n                    parent = existingNode\n                } else {\n                    // Create new directory node\n                    dirNode := &ReportNode{\n                        Name:           part,\n                        Path:           currentPath, // Path up to this directory\n                        IsDir:          true,\n                        Children:       []*ReportNode{},\n                        ToolCoverages:  make(map[string]float64),\n                        ToolCoverageOk: make(map[string]bool),\n                    }\n                    dirs[currentPath] = dirNode // Add to map for lookup\n\n                    if parent == nil { // Directory in root\n                        roots = append(roots, dirNode)\n                    } else {\n                        // Check if child already exists in parent (can happen with sorting/processing order)\n                        childExists := false\n                        for _, child := range parent.Children {\n                            if child.Path == dirNode.Path {\n                                childExists = true\n                                break\n                            }\n                        }\n                        if !childExists {\n                            parent.Children = append(parent.Children, dirNode)\n                        }\n                    }\n                    parent = dirNode // This new dir becomes the parent for the next part\n                }\n            }\n        }\n    }\n    return roots",
          "reason": "Modified",
          "start": 145,
          "end": 163
        }
      ]
    },
    "hash": "9e37213299b1e92d0e40598a7e5eb2b6f7033af47301cef320826ae884779136",
    "id": "eJy1WN1v2zYQ/1duehikVLFbYNiDAT+szVYUGNpgzrAHKygo6WQToUmBpJN5Qf73gV8SqchJO2Bv5vG+73d3lB8zohQqRfnuRgiWrbIvf/2yub68+XJ9+e5tVmaNaPGD4Bq5zlZZT5o7skOQ2AupK15xejC/IK94pSvLzbDTlw2jy44yjbLK3FVP9N6Q0PwIRGW0hN9aUr5T5lgYzcslfBD3KMkOr4gmQLlG2ZEGoRMSSK20JI2mfAeNZ4OWaLKouD71eE720Rj7iDpc51oIBs52AXnHBNE//1RCLQQzbujNPG85Wh1kxF0Qe/IBXBO93/SMao1yEoCyZOO+SQqYrKjg+xkx67ul54Z98Hp7636NdjfYE0m0kIkma1I5U1CfQO8RvmwuVY8N7WgDKkgFP86o0fLY6EdrqzvyBj7jwyxnXqSRWP8l6qPk8OOshFE66s0VXMyyFfBCFhIzHlSLkb/0tDxgcTGYKKLKfTa4l2jIk8I1hmrs/GGbwDAC5UoT3uBQwXlx65kl42+UoWHKOTnggKkooBJa1IQyBdtb10mLj5K0eOWoBVyM9ke1V1Rio4U8vah7IhxivsKOHJlOfFdAoBG8kagR6KFneECuiaaCg+jiOEPoM1rmEPOcLS+StCVoec49gUoDF895Cvgfkp06NtItudKfyQFXAADGVuloBruWZgHoaJ/UFZWG2BGmAqO3twruWPJ3BPofyv+t4czGMxsQaHkMnB/2lLUS+Qq2t5HRx6cksuUSbiTi+yNlLVrQSVS94IrWzDed4A5EpvHM3IoC0BIxgC9W4wRcfH08h+JRYi55hLoYgtE0wIdYsx0BaFqD40Ni84HqPfRS3NMWW2ixR94ib6idDAH6kUB+1rESYreSWl/EFpPyRRe+frH+FcQnX6HIygpim9MKfZTi2Mdd8f5k/IWdoSvYmZuhjerTuNZC5LmuE9eLcyrzV5rxQPqtQ/LtLIfLifULW1it4UDuMH9Nym57g7WvJVgpSfhujMjn064GeSCM/oO+p8L6UANSqdLIm1NIsGdvbbpWaxg2z43YMKL2ebuwE4ocsHAy3vdtKnsLayC9gVR+hqGEtvBlG0DhWcdC1ib9pg4gsTlKRe+RnRxV2d5yrzvbV9BJcXBx9kRqdb6Wg9ZcCqFV2u8ltFSquHDJpVU9LPASuiNj198xnRNbrlK0A4Y8t5oLWK/hbaigT4v1MuSKV/qeSOMHcj3drM1RGnKoXpXZF6sHC3Xej3hxsXhbVP1OlL72DDk1joxuXb7z5aYdxEbWzkhQknqwthbczRMgU3iOLz69gSpbVhm8iaVdFJXGv6kyg9UVoxNHbvFvSraNlNwGftpBFNhgvfNb1sjqehGNksVkDRsfxioP5S2CJtqFUqzXwCkbbVTaoWtoBHssIdgeVExTYyah0bgIG2lUMbmYUzafbtr5ZD2zAmuIk3reqZbKF1OWLnSXt6gkRaIprRbYCnrzA9tLqT2XXK8mMvY8kEo3Jn+/mqiVHXLmWRPf+9Fq2ZJ2SaqSqHSdYa4WoTG8L+48YU59WNt3yJSjlkjuUuJTfEwOtIMfYpUTe9+OqOcZTCw9zeBnrF0Cwel092MszHY7jt34shN+eDe5yV4TRRs32PcUJZHN/uRGfPIRulzCJw2tQAVcaGgIa46MaBy/efco8fwumHgRtlVYz69u4rmB7qC5Wk8fkubOLpeZPR8xFq4J3LdvYB03ztvSzuXU0WJ4EvQjYCexRM8sFQNA71UJ/biMzT8di437GnXXxbhEvkYrL+oMo9LrDwtwtZ44sA2Ct8ER6dKk60X82vNfwIF7XDxntmSlG8E15aGDPP7CgND1YrLw3Yr3u/zccPcrZ4LdrMwM/Ax7tsqWfyqUarlHLk+MHOrl4cg07Rkuk3+X3CNlWTvMLXYie/oXxdT5EA=="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/builder.go",
    "grade": "A",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:12.315Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "dependencyInversionScore": "A*",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "A*",
      "openClosedScore": "A",
      "singleResponsibilityScore": "B"
    },
    "hash": "975a419cfbad3b06c3083a4e2f69e77c85ee5e99545bf1043d04ee9b83d16d50",
    "id": "eJy1WN1v2zYQ/1duehikVLU7YNiDAb+02YoCRVss2ZNlFLR0sonIpECek3lB/veBXxKpyGk7YG/m8b7vd3eUHzOmNWrNxf5Wyi5bZTefP364zsqslg2+k4JQULbKelbfsT2Cwl4qqkQl+NH8grwSFVWWu8OWXtcdX7a8I1RV5q56RgdDQvMjELXREn6T4mKvzbEwmpdLeCfvUbE9XjNiwAWhalmN0EoFbKdJsZq42EPt2aBhxBaVoHOPl2QfjbH3SOE6Jyk7cLYLyNtOMvrt1xJ2UnbGDbqZ5y1Hq4OMvAtiTz6AL4wON33HiVBNAtCWbNw3SQGTFR18vyBmfbf03LAPXm+27tdo9wZ7phhJlWiyJrUzBbsz0AHh881r3WPNW16DDlLBjwtqSJ1qerS22pOo4RM+zHLmRRqJ9V8hnZSAn2cljNJRb67hapatgBeykJjxoFqM/KWn5QGLi8FEEVXuk8G9QkOeFK42VGPnT9sEhhG40MREjUMF58WtZ5aMf/AODVMu2BEHTEUBldAgMd5p2GxdJy3eK9bgtaMWcDXaH9Vec4U1SXV+UfdEOMR8jS07dZT4roFBLUWtkBD4se/wiIIYcSlAtnGcIfQZLXOIec6WF0naErQ8555ApYar5zwF/A/JTh0b6ZZc0Sd2xBUAgLFVOprBrqVZADraB33NlSG2rNOB0dtbBXcs+QcC/Q/l/95wZuOZDQhInQLnuwPvGoViBZttZPTxKYlsuYRbhfj2xLsGLegU6l4KzXedbzopHIhM45m5FQVACjGAL1bjBFx8fTyH4lFiLkWEuhiC0TTAh1izHQFoWkPgQ2LzgdMBeiXveYMNNNijaFDU3E6GAP1IIL/oWAmxW0mtr2KLSfmiC1+/WP8K4pOvUGRlBbHNaYXeK3nq4654ezb+wt7QNezNzdBGu/O41kLkOe0S14tLKvNvNOOR9RuH5O0sh8uJ9QsbWK3hyO4w/5aU3fYGa19LsFKKif0Ykc+nXQ3qyDr+D/qeCutDD0jlmlDU55Bgz97YdK3WMGyeW3nTMX3Im4WdUOyIhZPxvm9S2S2sgfUGUvkFhhKawpdtAIVnHQu5M+k3dQCF9Ulpfo/d2VG17S33urN9Ba2SRxdnzxTpy7UctOZKStJpv5fQcKXjwiWXVvWwwEtoT1335Qemc2LLVYq30KHIreYC1mt4Eyro02K9DLkSFd0zZfxAQdPNWp+UIYfqVZl9sXqwcOf9iBcXi7fF9Uem6YtnyLlxZHTr9S++3LyF2MjaGQlKUg/W1oK7eQLsNF7ii0+voMqWVQavYmkXRUX4N9dmsLpitPIkLP5NyTaRkm3g5y1EgQ3WW79ljSztFtEoWUzWsPFhrPJQ3iJo4m0oxXoNgnejjYocuoZGsMcSgu1BxTQ1ZhIajYuwkUYVk4s5ZfPp5q1P1jMrsIY4qZedarh6MWXpQnd5i0pSJJrSaoGtoDc/sL2U2kvJ9WoiY88Dqag2+fvdRK3tkDPPmvjej1bLlrRLUpVEpesMc7UIjeF9cecJc+rD2r5Dphw7hewuJT7Fx+TAW/gpVjmx9/2Iep7BxNLTDH7G2iUQnE53P8bCbLfj2I0vO+GHd5Ob7Dumee0G+4GjYqo+nN2ITz5Cl0v4QNBI1CAkQc26+tQxwvGb94AKL++CiRdhW4X1/M1NPDfQHTRX6+lD0tzZ5TKz5yPGwjWB+/YNrOPGeVPauZw6WgxPgn4E7CSW6JmlYwDQQZfQj8vY/NOxuHFfo+66GJfI12jlRZ1hVHr9YQGu1hMHNkFwGxxRLk20W8SvPf8FHLjHxXNhS1ZUS0FchA7y+AsDgnaLycJ3K97v8kvD3a+cCXazMjPwM+zZKlv+pVHp5QGFOnfsuFseTx3xvsNl8u+Se6Qsdw5zi73Mnv4FChP3Uw=="
  },
  {
    "assessingTool": "Complexity",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/builder.go",
    "grade": "A-",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:13.483Z",
    "codeReview": {
      "review": "Congratulations! Your most recent code changes passed."
    },
    "gradingDetails": {
      "grades": {
        "maintainabilityIndex": "C+",
        "qualityDesign": "B+",
        "readability": "B+",
        "testability": "A-"
      },
      "issues": {
        "cyclomaticComplexity": 45,
        "dependenciesModules": 30,
        "functionMethodCounts": 30,
        "linesOfCode": 164,
        "nestingDepth": 35
      }
    },
    "hash": "94f702f693a58b70ef99988c1e4570e8be9704772e94da4343ea24768fe6bb60",
    "id": "eJy1WN1v2zYQ/1duehikVLU7YNiDAb802YoCQ1cs3ZNlFLR0sonIpECek3pB/veCXxKpyGk7YG/m8b7vd3eUHzOmNWrNxf6TlF22yq7lse/wC6dzVma1bPBaCkJB2SrrWX3H9ggKe6moEpXgR/ML8kpUVFnuDlt6XXd82fKOUFWZu+oZHQwJzY9A1EZL+E2Ki702x8JoXi7hWt6jYnu8YcSAC0LVshqhlQrYTpNiNXGxh9qzQcOILSpB5x4vyT4aY++QwnVOUnbgbBeQt51k9NuvJeyk7IwbdDvPW45WBxl5F8SefAAfGR1u+44ToZoEoC3ZuG+SAiYrOvh+Qcz6bum5YR+83mzdr9HuLfZMMZIq0WRNamcKdmegA8Jft691jzVveQ06SAU/Lqghdarp0dpqT6KGD/gwy5kXaSTWf4V0UgJ+npUwSke9uYarWbYCXshCYsaDajHyl56WBywuBhNFVLkPBvcKDXlSuNpQjZ2/bRMYRuBCExM1DhWcF7eeWTL+wTs0TLlgRxwwFQVUQoPEeKdhs3WdtHinWIM3jlrA1Wh/VHvDFdYk1flF3RPhEPMNtuzUUeK7Bga1FLVCQuBmMBxRECMuBcg2jjOEPqNlDjHP2fIiSVuClufcE6jUcPWcp4D/IdmpYyPdkiv6wI64AgAwtkpHM9i1NAtAR3uvb7gyxJZ1OjB6e6vgjiX/QKD/ofzfG85sPLMBAalT4Lw+8K5RKFaw2UZGH5+SyJZL+KQQ355416AFnULdS6H5rvNNJ4UDkWk8M7eiAEghBvDFapyAi6+P51A8SsyliFAXQzCaBvgQa7YjAE1rCHxIbD5wOkCv5D1vsIEGexQNiprbyRCgHwnkFx0rIXYrqfVVbDEpX3Th6xfrX0F88hWKrKwgtjmt0DslT33cFW/Pxl/YG7qGvbkZ2mh3HtdaiDynXeJ6cUll/o1mPLJ+45C8neVwObF+YQOrNRzZHebfkrLb3mDtcwlWSjGxHyPy+bSrQR1Zx/9F31NhfegBqVwTivocEuzZG5uu1RqGzfNJ3nZMH/JmYScUO2LhZLzvm1R2C2tgvYFUfoGhhKbwZRtA4VnHQu5M+k0dQGF9UprfY3d2VG17y73ubF9Bq+TRxdkzRfpyLQetuZKSdNrvJTRc6bhwyaVVPSzwEtpT1338gemc2HKV4i10KHKruYD1Gt6ECvq0WC9DrkRF90wZP1DQdLPWJ2XIoXpVZl+sHizceT/ixcXibXH9J9P00TPk3DgyuvX6F19u3kJsZO2MBCWpB2trwd08AXYaL/HFp1dQZcsqg1extIuiIvzCtRmsrhitPAmLf1OyTaRkG/h5C1Fgg/XWb1kjS7tFNEoWkzVsfBirPJS3CJp4G0qxXoPg3WijIoeuoRHssYRge1AxTY2ZhEbjImykUcXkYk7ZfLp565P1zAqsIU7qZacarl5MWbrQXd6ikhSJprRaYCvozQ9sL6X2UnK9msjY80Aqqk3+fjdRazvkzLMmvvej1bIl7ZJUJVHpOsNcLUJjeF/cecKc+rC275Apx04hu0uJT/ExOfAWfopVTux9P6KeZzCx9DSDn7F2CQSn092PsTDb7Th248tO+OHd5Cb7jmleu8F+4KiYqg9nN+KTj9DlEt4TNBI1CElQs64+dYxw/OY9oMLLu2DiRdhWYT1/cxPPDXQHzdV6+pA0d3a5zOz5iLFwTeC+fQPruHHelHYup44Ww5OgHwE7iSV6ZukYAHTQJfTjMjb/dCxu3deouy7GJfI5WnlRZxiVXn9YgKv1xIFNENwGR5RLE+0W8WvPfwEH7nHxXNiSFdVSEBehgzz+woCg3WKy8N2K97v80nD3K2eC3azMDPwMe7bKlv9oVHp5QKHOHTvulsdTR7zvcJn8u+QeKcudw9xiL7Onr611+gY="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/calculator.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:13.540Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "effadf575dc24eed1ce3bdc3631f4666fa0f9bc3b8eae815cd3089dd222b8802",
    "id": "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"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/calculator.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:13.594Z",
    "codeReview": {
      "review": "This code, while functional, has several SOLID design flaws.  First, `calculateFileNodeCoverage` and `calculateDirectoryNodeCoverage` modify the `ReportNode` directly, violating the Single Responsibility Principle (SRP).  These functions should only calculate coverage, not modify the node's internal state.  Second, the `calculateCoverageScore` function is tightly coupled to the specific grade-to-coverage mapping, making it hard to change or extend.  Third, the use of `processedToolsThisFile` in `calculateFileNodeCoverage` is redundant and could be simplified.  For example, `calculateFileNodeCoverage` could be improved by removing the `processedToolsThisFile` map and using a conditional check within the loop to avoid double-counting.\n"
    },
    "gradingDetails": {
      "dependencyInversionScore": "B",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "A*",
      "openClosedScore": "B",
      "singleResponsibilityScore": "A"
    },
    "hash": "0b8849e830d7f0939eac2a71427b98de887e89210c2e7c4c55259306a61597bc",
    "id": "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"
  },
  {
    "assessingTool": "Complexity",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/calculator.go",
    "grade": "A-",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:14.713Z",
    "codeReview": {
      "review": "Congratulations! Your most recent code changes passed."
    },
    "gradingDetails": {
      "grades": {
        "maintainabilityIndex": "B+",
        "qualityDesign": "A",
        "readability": "A-",
        "testability": "B+"
      },
      "issues": {
        "cyclomaticComplexity": 45,
        "dependenciesModules": 3,
        "functionMethodCounts": 10,
        "linesOfCode": 193,
        "nestingDepth": 45
      }
    },
    "hash": "333a7ca84d9398c7edfff7759b22301b8a3fbafdf3b45c29fb4abc58b631ae5f",
    "id": "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"
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/template.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:14.767Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "fcfbbb1a4bc164366e08f201581e1eeaaecc80dccaf61acdaf45fbdf144667fc",
    "id": "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"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/template.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:14.820Z",
    "codeReview": {
      "review": "The code has three critical areas of concern.  First, hardcoded colors in the CSS (`#1e1e1e`, etc.) make the theme inflexible.  Second, the template functions (`getCoverageClass`, `getCoverageColor`) use multiple `if` statements for coverage ranges, which is inefficient and could be improved with a lookup table or a more concise conditional.  Finally, the template (`repoReportTemplateHTML`) has numerous removed placeholders (`{{ getFileGrade $node }}`, etc.) that are not used, indicating potential incomplete or unused functionality.\n"
    },
    "gradingDetails": {
      "dependencyInversionScore": "B",
      "interfaceSegregationScore": "A*",
      "liskovSubstitutionScore": "B",
      "openClosedScore": "B",
      "singleResponsibilityScore": "B"
    },
    "hash": "dd84ecc5fc4fc3f005a8a2eb156040cdad41aeaf0e83ea4289aec691bf647369",
    "id": "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"
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/writer.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:17.384Z",
    "codeReview": {
      "review": "Congratulations! Your most recent code changes passed."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "codeDiff": {
      "oldCode": "package report\n\nimport (\n\t\"fmt\"\n\t\"html/template\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\ntype ReportWriter interface {\n\tWrite(data ReportViewData, outputPath string) error\n}\n\ntype HTMLReportWriter struct {\n\ttemplate *template.Template\n}\n\nfunc NewHTMLReportWriter() (*HTMLReportWriter, error) {\n\ttmpl, err := template.New(\"repoReport\").Funcs(templateFuncs).Parse(repoReportTemplateHTML)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to parse HTML template: %w\", err)\n\t}\n\treturn &HTMLReportWriter{template: tmpl}, nil\n}\n\nfunc (w *HTMLReportWriter) Write(data ReportViewData, outputPath string) error {\n\toutputDir := filepath.Dir(outputPath)\n\tif err := os.MkdirAll(outputDir, 0755); err != nil {\n\t\treturn fmt.Errorf(\"failed to create output directory '%s': %w\", outputDir, err)\n\t}\n\n\toutputFile, err := os.Create(outputPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create HTML output file '%s': %w\", outputPath, err)\n\t}\n\tdefer outputFile.Close()\n\n\tif err := w.template.Execute(outputFile, data); err != nil {\n\t\treturn fmt.Errorf(\"failed to execute HTML template: %w\", err)\n\t}\n\treturn nil\n}",
      "newCode": "package report\n\nimport (\n\t\"fmt\"\n\t\"html/template\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\ntype ReportWriter interface {\n\tWrite(data ReportViewData, outputPath string) error\n}\n\n// HTMLReportWriter implements ReportWriter for HTML output.\n// SRP: Focused on HTML rendering and file output.\ntype HTMLReportWriter struct {\n\ttemplate *template.Template\n}\n\nfunc NewHTMLReportWriter() (*HTMLReportWriter, error) {\n\ttmpl, err := template.New(\"repoReport\").Funcs(templateFuncs).Parse(repoReportTemplateHTML)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to parse HTML template: %w\", err)\n\t}\n\treturn &HTMLReportWriter{template: tmpl}, nil\n}\n\nfunc (w *HTMLReportWriter) Write(data ReportViewData, outputPath string) error {\n\toutputDir := filepath.Dir(outputPath)\n\tif err := os.MkdirAll(outputDir, 0755); err != nil {\n\t\treturn fmt.Errorf(\"failed to create output directory '%s': %w\", outputDir, err)\n\t}\n\n\toutputFile, err := os.Create(outputPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create HTML output file '%s': %w\", outputPath, err)\n\t}\n\tdefer outputFile.Close()\n\n\tif err := w.template.Execute(outputFile, data); err != nil {\n\t\treturn fmt.Errorf(\"failed to execute HTML template: %w\", err)\n\t}\n\treturn nil\n}",
      "changes": [
        {
          "newCode": "// HTMLReportWriter implements ReportWriter for HTML output.\n// SRP: Focused on HTML rendering and file output.",
          "reason": "Added",
          "start": 14,
          "end": 14
        }
      ]
    },
    "hash": "3a78cce1ba05417ce12b82536c1781ea8260ee5e75833ee82ce76ba9cfac78d4",
    "id": "eJydlMFu2zAMhl+FE9DVLhy7OxQDPORQJC12WNtgy9aLL5pNJ0JlyZBoeEGQdx8kxU6WLcCQG02LH3/+IrRl3Fq0VqjVUmvJcvbyev9tMVm+LCYfblnCSl3hTCtCRSxnLS/f+ArBYKsNFapQonERRIUqqGB1QwUL4ZoamRE2reSEQ1LbIWo5rbNaSHSBS8aORpsW4auHvxpBaEAoQlPzEmHrCn02qjjx/bEfAvs5J56A7qjtaMFpDZaMUKsY0BhtCrUb0Z+XT1/+wFsyXUmBPYiFmyFKl4P+wKg7VcIz9qeYKIbo5jSZhPbxHt600mcgn8LIf8Y+KphzM1QWLE4fO1XaaDjiv+J0wY3F6HBwEOaaOudI1B7+bgpKyNCyIIPUGeUyCdQNpQ9OUB0VrOZCYgWkoXVg78uoKoervmBerEe70QfU+9Mpt4cqN+Iucd2O7Yp6+MuaGC64xzBU+DsX3sdhf9K5MNGh7tiQfArapk9vlTD3UkZjeQK3H+/u4k/nXTtjWGnQ7UgAQSUMlqTNBq6v7PXg3FGXYxNH+Y9CYnIkb+aZZya4QJy/zr1C59E/xLkuJ1dcYY0GDgrTmdQWozgoP/jZp+P+PvzCshuVh7HcpV7gKwbU/69i2DOWMDehG4flLPtu0dhsjcpsJG9+Zk0nSbQSM/eOSaxpUkqRhecr6/0ypivNdr8B/CfP/A=="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/writer.go",
    "grade": "A+",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:18.095Z",
    "codeReview": {
      "review": "Congratulations! Your most recent code changes passed."
    },
    "gradingDetails": {
      "dependencyInversionScore": "A+",
      "interfaceSegregationScore": "A+",
      "liskovSubstitutionScore": "A+",
      "openClosedScore": "A+",
      "singleResponsibilityScore": "A+"
    },
    "codeDiff": {
      "oldCode": "package report\n\nimport (\n\t\"fmt\"\n\t\"html/template\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\ntype ReportWriter interface {\n\tWrite(data ReportViewData, outputPath string) error\n}\n\ntype HTMLReportWriter struct {\n\ttemplate *template.Template\n}\n\nfunc NewHTMLReportWriter() (*HTMLReportWriter, error) {\n\ttmpl, err := template.New(\"repoReport\").Funcs(templateFuncs).Parse(repoReportTemplateHTML)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to parse HTML template: %w\", err)\n\t}\n\treturn &HTMLReportWriter{template: tmpl}, nil\n}\n\nfunc (w *HTMLReportWriter) Write(data ReportViewData, outputPath string) error {\n\toutputDir := filepath.Dir(outputPath)\n\tif err := os.MkdirAll(outputDir, 0755); err != nil {\n\t\treturn fmt.Errorf(\"failed to create output directory '%s': %w\", outputDir, err)\n\t}\n\n\toutputFile, err := os.Create(outputPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create HTML output file '%s': %w\", outputPath, err)\n\t}\n\tdefer outputFile.Close()\n\n\tif err := w.template.Execute(outputFile, data); err != nil {\n\t\treturn fmt.Errorf(\"failed to execute HTML template: %w\", err)\n\t}\n\treturn nil\n}",
      "newCode": "package report\n\nimport (\n\t\"fmt\"\n\t\"html/template\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\n// ReportWriter defines the interface for writing a report.\n// OCP: Allows different writers (HTML, JSON, etc.)\n// DIP: Higher-level modules depend on this interface.\ntype ReportWriter interface {\n\tWrite(data ReportViewData, outputPath string) error\n}\n\n// HTMLReportWriter implements ReportWriter for HTML output.\n// SRP: Focused on HTML rendering and file output.\ntype HTMLReportWriter struct {\n\ttemplate *template.Template\n}\n\nfunc NewHTMLReportWriter() (*HTMLReportWriter, error) {\n\ttmpl, err := template.New(\"repoReport\").Funcs(templateFuncs).Parse(repoReportTemplateHTML)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to parse HTML template: %w\", err)\n\t}\n\treturn &HTMLReportWriter{template: tmpl}, nil\n}\n\nfunc (w *HTMLReportWriter) Write(data ReportViewData, outputPath string) error {\n\toutputDir := filepath.Dir(outputPath)\n\tif err := os.MkdirAll(outputDir, 0755); err != nil {\n\t\treturn fmt.Errorf(\"failed to create output directory '%s': %w\", outputDir, err)\n\t}\n\n\toutputFile, err := os.Create(outputPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create HTML output file '%s': %w\", outputPath, err)\n\t}\n\tdefer outputFile.Close()\n\n\tif err := w.template.Execute(outputFile, data); err != nil {\n\t\treturn fmt.Errorf(\"failed to execute HTML template: %w\", err)\n\t}\n\treturn nil\n}",
      "changes": [
        {
          "newCode": "// ReportWriter defines the interface for writing a report.\n// OCP: Allows different writers (HTML, JSON, etc.)\n// DIP: Higher-level modules depend on this interface.",
          "reason": "Added",
          "start": 10,
          "end": 10,
          "grade": "A+"
        },
        {
          "newCode": "// HTMLReportWriter implements ReportWriter for HTML output.\n// SRP: Focused on HTML rendering and file output.",
          "reason": "Added",
          "start": 14,
          "end": 14,
          "grade": "A+"
        }
      ]
    },
    "hash": "eb0e1aace3c935d2cddbcda29ae45690673e6aea6e38c90d57647887e4ab67ed",
    "id": "eJydlFFv0zAQx7/KYWnMmULCy4QU1AfUbgJpGxMUePGLSS6tNceO7ItCVfW7I8dNWgqVUN8uF9/v/vf3yVsmvUfvlVktrdWsYF8/P3xasJSVtsK5NYSGWMFaWb7IFYLD1joSRhjVhAi4MIIEqxsSLIZranRO2LRaEo5J68eolbTOa6UxBCGZBBptWoQvA/yHU4QOlCF0tSwRtqFwyPJKktwf+66wX0iSKdiO2o6eJa3Bk1NmlQA6Z50wuwn9cfn48Afek+tKiuxRLNyMUbYc9UdG3ZkSnrA/xfAE+M1pMo3tkz28afWQgWIGE/8Jey5YcDNWCpZk950pPR+PDF9J9iydR344OAoLTYNzpOoB/moGRunYUpBD6pwJmRTqhrK7IKjmgtVSaayALLQBPPgyqSrgqhdsEDugw+gj6vXplNtDVRhxl4Zux3bxHv6yJoEL7jEOFf8u1ODjuD/ZQjl+qDs2pJiB9dnjS6XcB635VJ7C23e3t8n7866dMax0GHYkgqBSDkuybgPXV/56dO6oy7GJk/x7pTE9kjcfmGcmuEDccJ17hcGjf4gLXU6uuMIaHRwUZnNtPfIkKj/42WfT/t79wrKblMexwqVe4CtG1P+vYtwzlrIwYRiHFSz/5tH5fI3GbbRsfuZNp0m1GvPwjmms6U2pVR6fr7wfljFbWbb7DTE/zj8="
  },
  {
    "assessingTool": "Complexity",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/writer.go",
    "grade": "A-",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:19.217Z",
    "codeReview": {
      "review": "Congratulations! Your most recent code changes passed."
    },
    "gradingDetails": {
      "grades": {
        "maintainabilityIndex": "C+",
        "qualityDesign": "B+",
        "readability": "B",
        "testability": "B+"
      },
      "issues": {
        "cyclomaticComplexity": 15,
        "dependenciesModules": 20,
        "functionMethodCounts": 2,
        "linesOfCode": 42,
        "nestingDepth": 20
      }
    },
    "hash": "405275ce2334dd0e21e8cc9e9cbd9fa568760afb1dfbcb2cd5fa3b627393d58b",
    "id": "eJydlFFr2zAQx7/KTdBVLp69lzLIyMNIWvawljLS7UUvmn1ORGXJSGfcEPLdh6TYybIFRt/OZ93v/vfXoR2T3qP3yqxX1mo2YwvbdhpfFW1Zzipb48IaQkNsxjpZvcg1gsPOOhJGGNWGCLgwggRrWhIshRtqdUnYdloSjknrx6iTtCkbpTEEIZkFGm07hO8R/tMpQgfKELpGVgi7UBizvJYkD8d+KByWkmQOtqeupydJG/DklFlngM5ZJ8x+Qn9dPXz7A+/J9RUl9igWbsaoWI36E6PpTQWPOJxjeAb85jyZp/bZAd52OmZgNoeJ/4gDFyy4mSoFy4r73lSej0fiV1Y8SeeRHw+OwkLT4BypJsLfzcEonVoKcki9MyGTQ9NScRcENVywRiqNNZCFLoCjL5OqGVwNgkWxER1GH1Hvz6fcHavCiPs8dDu1iw/wlzUZvOEe01Dp71JFH8f9KZbK8WPdqSGzOVhfPLzUyn3Rmk/lOXz8dHubfb7s2gXDKodhRxIIauWwIuu2cH3lr0fnTrqcmjjJv1ca8xN5i8i8MMEbxMXrPCgMHv1DXOhydsU1NujgqLBYaOuRZ0n50c+hmPb37hWrflKexgqX+gZfMaH+fxXTnrGchQnDOGzGymePzpcbNG6rZfurbHtNqtNYhndMY0MfKq3K9HyVQ1zGYm3Z/jent9Dy"
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/html.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:19.274Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "345efff82797920bc29bc6ffbe61503ee2e0daad6c0a669665a3d82ce4e8f8fc",
    "id": "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"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/html.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:19.329Z",
    "codeReview": {
      "review": "The code has three critical areas of concern:\n\n1.  **Redundant Calculations:** The code recalculates file-level averages multiple times, leading to unnecessary computations.  Lines like `for _, detail := range detailsList` within the `GenerateRepoHTMLReport` function are examples of this.\n\n2.  **Inefficient Data Handling:**  The use of `groupedDetails` and then recalculating averages from the original data in the `GenerateRepoHTMLReport` function is inefficient.  The code should store the necessary data in the `ReportNode` structure to avoid redundant lookups.\n\n3.  **Lack of Clarity in Coverage Calculation:** The `calculateCoverage` function's logic is complex and not immediately obvious.  The use of `thresholdGrade` and the different coverage values based on grade comparisons needs better documentation and potentially a more structured approach.\n"
    },
    "gradingDetails": {
      "dependencyInversionScore": "B",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "A*",
      "openClosedScore": "B",
      "singleResponsibilityScore": "B"
    },
    "hash": "e553efcae4392ad362a73abdc1a73494fa64662dcf59b58291a3cf7ad55ade52",
    "id": "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"
  },
  {
    "assessingTool": "Complexity",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/template.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:19.732Z",
    "codeReview": {
      "detailedReview": {
        "tasks": [
          {
            "done": false,
            "titleTask": "cyclomaticComplexity",
            "violatingCode": "The `getCoverageClass` function (lines 19-25) and `getCoverageColor` function (lines 26-32) both use a series of `if` statements to determine the return value based on the `coverage` input. This structure increases cyclomatic complexity due to the multiple conditional branches.\n",
            "codeResolution": "The `getCoverageClass` function (lines 19-25) and `getCoverageColor` function (lines 26-32) both use a series of `if` statements to determine the return value based on the `coverage` input. This results in a cyclomatic complexity of 5 for each function.\n\nRefactoring Strategy:\nReplace the series of `if` statements with a `switch` statement or a lookup table (map) to reduce complexity and improve readability.\n\nExample:\n```go\nfunc getCoverageClass(coverage float64) string {\n    switch {\n    case coverage >= 100: return \"green\"\n    case coverage >= 70: return \"green-med\"\n    case coverage >= 50: return \"orange\"\n    case coverage >= 30: return \"orange-low\"\n    default: return \"red\"\n    }\n}\n```\n",
            "severity": "Critical",
            "rationale": "The `getCoverageClass` function (lines 19-25) and `getCoverageColor` function (lines 26-32) use a series of `if` statements to determine the class or color based on coverage. This contributes to cyclomatic complexity. High cyclomatic complexity can make the code harder to understand and test, potentially leading to errors. It can also make it more difficult to modify the code without introducing bugs.\n",
            "lineStart": 19,
            "lineEnd": 371,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "nestingDepth",
            "violatingCode": "The `getCoverageClass` function (lines 19-25) and `getCoverageColor` function (lines 26-32) both use a series of `if` statements to determine the return value. This results in a nesting depth of 1.\n",
            "codeResolution": "The `dirLevel` function (lines 78-86) and its usage in the `node` template (lines 293-294) contribute to nesting depth. The function calculates the directory level by splitting the path and counting slashes.\n\nRefactoring could involve pre-calculating the directory level within the data processing stage, avoiding the need for the `dirLevel` function in the template.\n\nExample:\n\nInstead of:\n\n```go\n{{ $displayLevel := dirLevel $nodePath }}\n<td style=\"text-align: left; padding-left: {{ add (multiply $displayLevel 20) 10 }}px;\">\n```\n\nIf the `ReportNode` struct had a `Level int` field, the template could be simplified to:\n\n```go\n<td style=\"text-align: left; padding-left: {{ add (multiply $node.Level 20) 10 }}px;\">\n```\n",
            "severity": "Critical",
            "rationale": "The `nestingDepth` is a concern because deeply nested conditional statements (e.g., in `getCoverageClass`, `getCoverageColor`) and recursive template calls (`nodeList` within `node`) can make the code harder to follow and debug. This can affect maintainability by making it difficult to understand the control flow. It can also potentially impact performance due to the overhead of nested function calls.\n",
            "lineStart": 19,
            "lineEnd": 356,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "functionMethodCounts",
            "violatingCode": "The `templateFuncs` variable (lines 12-86) defines a map of template functions. This is a strength as it encapsulates reusable logic. However, the functionMethodCounts metric is impacted by the number of functions defined within this map.\n",
            "codeResolution": "The `templateFuncs` variable defines a map of template functions. The functionMethodCounts can be improved by reducing the number of functions defined within the `templateFuncs` map.\n\nRefactoring Strategy:\nConsolidate similar functions or move them to separate helper functions to reduce the number of functions in the map.\n\n```go\nvar templateFuncs = template.FuncMap{\n\t\"formatFloat\":    formatFloat,\n\t\"getCoverageClass\": getCoverageClass,\n\t\"getCoverageColor\": getCoverageColor,\n\t\"getToolAverage\":   getToolAverage,\n\t\"getToolCoverage\":  getToolCoverage,\n\t\"hasToolCoverage\":  hasToolCoverage,\n\t\"split\":          strings.Split,\n\t\"dict\":           dict,\n\t\"multiply\":       func(a, b int) int { return a * b },\n\t\"sub\":            func(a, b int) int { return a - b },\n\t\"add\":            func(a, b int) int { return a + b },\n\t\"base\":           filepath.Base,\n\t\"dirLevel\":       dirLevel,\n}\n\nfunc formatFloat(f float64) string {\n\tif !math.IsNaN(f) && !math.IsInf(f, 0) {\n\t\treturn fmt.Sprintf(\"%.2f\", f)\n\t}\n\treturn \"N/a\"\n}\n```",
            "severity": "Critical",
            "rationale": "The `templateFuncs` variable (lines 12-87) defines a map of template functions. The functionMethodCounts metric is affected because each function declared within `templateFuncs` contributes to the total count. A high count can make the template logic harder to understand and maintain. It can also affect performance if many functions are called frequently.\n",
            "lineStart": 12,
            "lineEnd": 74,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "linesOfCode",
            "violatingCode": "The `violatingCode` is in the `dirLevel` function, specifically lines 78-86. This function calculates the directory level by splitting the path by forward slashes and counting the parts. The code could be simplified by using `strings.Count` and `filepath.ToSlash` to determine the directory level.\n",
            "codeResolution": "The `dirLevel` function (lines 78-86) can be simplified. The current implementation splits the path twice and uses `strings.Count`.\n\nRefactoring:\n\n```go\nfunc dirLevel(p string) int {\n    p = filepath.ToSlash(p)\n    return strings.Count(p, \"/\")\n}\n```\nThis change removes unnecessary splitting and directly counts the slashes, making the code more concise.\n",
            "severity": "Critical",
            "rationale": "The `templateFuncs` variable (lines 12-87) defines a map of template functions. The length of this section contributes to the overall lines of code. A large number of functions can make the code harder to read and maintain. Consider refactoring some of these functions into smaller, more focused functions or grouping related functions into a separate package to improve readability and maintainability.\n",
            "lineStart": 13,
            "lineEnd": 360,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "dependenciesModules",
            "violatingCode": "The code imports several modules, including \"fmt\", \"html/template\", \"math\", \"path/filepath\", and \"strings\".\n\n```go\nimport (\n\t\"fmt\"\n\t\"html/template\"\n\t\"math\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n```\n",
            "codeResolution": "The code imports several packages, increasing dependencies. While necessary for functionality, consider if all imports are actively used.\n\nExample:\n```go\nimport (\n\t\"fmt\"\n\t\"html/template\"\n\t\"math\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n```\nIf `math` is only used in a single function, consider moving that function to a separate file to reduce the overall dependencies of the `report` package.\n",
            "severity": "Critical",
            "rationale": "The `dependenciesModules` metric isn't directly applicable to the provided code snippet, which is an HTML template and Go code for template functions. The dependencies are managed by the Go code, which imports packages like `fmt`, `html/template`, and `strings`. The HTML template itself doesn't have explicit module dependencies. Therefore, there is no rationale to provide.\n",
            "lineStart": 1,
            "lineEnd": 57,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "readability",
            "violatingCode": "The `dirLevel` function, used to calculate indentation levels, is inefficient. It uses `filepath.ToSlash` and `strings.Count` which can be slow.\n\n```go\n78: \t\"dirLevel\": func(p string) int {\n79: \t\tp = filepath.ToSlash(p)\n80: \t\tcount := strings.Count(p, \"/\")\n81: \t\tparts := strings.Split(p, \"/\")\n82: \t\tif len(parts) > 0 && parts[len(parts)-1] != \"\" {\n83: \t\t\treturn len(parts) - 1\n84: \t\t}\n85: \t\treturn count\n86: \t},\n```\n",
            "codeResolution": "The `getToolCoverage` and `hasToolCoverage` template functions (lines 40-46 and 48-52) are modified to accept `*ReportNode`. This is a good practice for accessing node-specific data within the template.\n",
            "severity": "Low",
            "rationale": "The use of hardcoded colors in the CSS (lines 96-104, 177-182, 209-210) impacts readability by making it difficult to quickly understand the visual theme and potentially hindering theme customization. This can affect maintainability because any color changes require manual edits in multiple places. Performance is not directly affected, but the lack of variables makes the code less DRY (Don't Repeat Yourself), increasing the chance of errors during updates.\n",
            "lineStart": 13,
            "lineEnd": 360,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "testability",
            "violatingCode": "The code snippet that presents a testability concern is within the `templateFuncs` variable, specifically the functions `getToolCoverage` and `hasToolCoverage`.\n\n```go\n// Modified to accept *ReportNode\n\"getToolCoverage\": func(node *ReportNode, tool string) float64 {\n\tif node == nil { return 0 }\n\tif cov, ok := node.ToolCoverages[tool]; ok && node.ToolCoverageOk[tool] {\n\t\treturn cov\n\t}\n\treturn 0 // Return 0 if not valid or doesn't exist\n},\n// Modified to accept *ReportNode\n\"hasToolCoverage\": func(node *ReportNode, tool string) bool {\n\tif node == nil { return false }\n\texists, ok := node.ToolCoverageOk[tool]\n\treturn ok && exists\n},\n```\n\nThese functions directly access the `ReportNode` struct. The dependency on the `ReportNode` struct makes it difficult to test these functions in isolation. To improve testability, consider passing interfaces instead of concrete types or using dependency injection.\n",
            "codeResolution": "The `getToolCoverage` and `hasToolCoverage` template functions (lines 40-52) directly access `ReportNode` fields. To improve testability, these functions could be refactored to accept an interface that defines the necessary methods for accessing coverage data. This allows for mocking the `ReportNode` in tests.\n\n```go\n// Define an interface for testability\ntype CoverageProvider interface {\n    GetToolCoverage(tool string) (float64, bool)\n}\n\n// Modify getToolCoverage and hasToolCoverage to use the interface\n\"getToolCoverage\": func(cp CoverageProvider, tool string) float64 {\n    if cp == nil { return 0 }\n    if cov, ok := cp.GetToolCoverage(tool); ok {\n        return cov\n    }\n    return 0\n},\n\"hasToolCoverage\": func(cp CoverageProvider, tool string) bool {\n    if cp == nil { return false }\n    _, ok := cp.GetToolCoverage(tool)\n    return ok\n},\n```\n",
            "severity": "Medium",
            "rationale": "The use of `template.FuncMap` to define template functions (lines 12-87) is a strength, but the lack of a clear separation of concerns within these functions could affect testability. Each function performs a specific task, but testing individual functions like `getCoverageClass` or `formatFloat` in isolation becomes more complex if they rely on global state or complex logic. This could affect maintainability if changes to one function inadvertently impact others. Performance is unlikely to be affected significantly.\n",
            "lineStart": 12,
            "lineEnd": 356,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "maintainabilityIndex",
            "violatingCode": "The `templateFuncs` variable, specifically the `getCoverageClass` and `getCoverageColor` functions, contains a series of `if` statements to determine the CSS class and color based on coverage percentages.\n\n```go\n19: \t\"getCoverageClass\": func(coverage float64) string {\n20: \t\tif coverage >= 100 { return \"green\" }\n21: \t\tif coverage >= 70 { return \"green-med\" }\n22: \t\tif coverage >= 50 { return \"orange\" }\n23: \t\tif coverage >= 30 { return \"orange-low\" }\n24: \t\treturn \"red\"\n25: \t},\n26: \t\"getCoverageColor\": func(coverage float64) string {\n27: \t\tif coverage >= 100 { return \"#76C474\" }\n28: \t\tif coverage >= 70 { return \"#a0d080\" }\n29: \t\tif coverage >= 50 { return \"#F0AB86\" }\n30: \t\tif coverage >= 30 { return \"#f5be9f\" }\n31: \t\treturn \"#e04242\"\n32: \t},\n```\n\nThese functions are repetitive and could be refactored to reduce redundancy and improve maintainability.\n",
            "codeResolution": "The `templateFuncs` variable (lines 12-87) defines a map of template functions. To improve maintainability, consider grouping related functions into logical sub-maps or helper structs. This would make the code easier to navigate and understand.\n\nFor example, you could create a `coverageFuncs` sub-map for functions related to coverage:\n\n```go\nvar coverageFuncs = template.FuncMap{\n\t\"getCoverageClass\": func(coverage float64) string { ... },\n\t\"getCoverageColor\": func(coverage float64) string { ... },\n}\n\nvar templateFuncs = template.FuncMap{\n\t\"formatFloat\": func(f float64) string { ... },\n\t\"getToolAverage\": func(averages map[string]float64, tool string) float64 { ... },\n\t// ... and so on, including the coverageFuncs\n}\n```\n",
            "severity": "Critical",
            "rationale": "The use of hardcoded colors in the CSS (lines 96-212) directly impacts the maintainability index. Changing the color scheme requires manual edits across multiple lines, increasing the risk of errors and making future theme adjustments difficult. This approach also reduces flexibility; for example, supporting user-defined themes would be complex.\n",
            "lineStart": 11,
            "lineEnd": 360,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "qualityDesign",
            "violatingCode": "The code uses hardcoded colors in the CSS, specifically within the `<style>` tags, which reduces flexibility and maintainability. For example, lines 101-102, 177-181, and 209 define colors directly. This makes it difficult to change the theme or color scheme without modifying the HTML directly.\n",
            "codeResolution": "The `getCoverageClass` and `getCoverageColor` template functions (lines 19-32) use a series of `if` statements to determine the CSS class and color based on coverage. This approach is functional but can become less maintainable if the number of coverage thresholds increases.\n\nRefactoring Strategy: Consider using a lookup table (map or slice) to store coverage thresholds and their corresponding CSS classes/colors. This makes it easier to add, remove, or modify coverage levels without changing the function's logic.\n\nExample of Improved Code:\n\n```go\nvar coverageClasses = map[float64]string{\n\t100: \"green\",\n\t70:  \"green-med\",\n\t50:  \"orange\",\n\t30:  \"orange-low\",\n\t0:   \"red\",\n}\n\nvar coverageColors = map[float64]string{\n\t100: \"#76C474\",\n\t70:  \"#a0d080\",\n\t50:  \"#F0AB86\",\n\t30:  \"#f5be9f\",\n\t0:   \"#e04242\",\n}\n\n\"getCoverageClass\": func(coverage float64) string {\n    for threshold, class := range coverageClasses {\n        if coverage >= threshold {\n            return class\n        }\n    }\n    return \"red\" // Default\n},\n\"getCoverageColor\": func(coverage float64) string {\n    for threshold, color := range coverageColors {\n        if coverage >= threshold {\n            return color\n        }\n    }\n    return \"#e04242\" // Default\n},\n```\n",
            "severity": "Medium",
            "rationale": "The use of hardcoded colors in the CSS (lines 96-212) impacts design quality by limiting flexibility and maintainability. This approach makes it difficult to change the theme or color scheme without manually editing the CSS. It could affect maintainability by requiring more effort to update the report's appearance. Performance is unlikely to be affected, but correctness could be impacted if the hardcoded colors don't align with the intended visual design.\n",
            "lineStart": 11,
            "lineEnd": 356,
            "status": ""
          }
        ],
        "codeReviewTitle": "Complexity Code Review"
      }
    },
    "gradingDetails": {
      "grades": {
        "maintainabilityIndex": "F",
        "qualityDesign": "B-",
        "readability": "B+",
        "testability": "C+"
      },
      "issues": {
        "cyclomaticComplexity": 60,
        "dependenciesModules": 3,
        "functionMethodCounts": 50,
        "linesOfCode": 360,
        "nestingDepth": 5
      }
    },
    "hash": "8a2b44c9d6dfbe2380d9a2c6907ece67774930d2afbf005ddf51b2283aa1b865",
    "id": "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"
  },
  {
    "assessingTool": "Complexity",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/html.go",
    "grade": "A-",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:20.629Z",
    "codeReview": {
      "review": "Congratulations! Your most recent code changes passed."
    },
    "gradingDetails": {
      "grades": {
        "maintainabilityIndex": "A+",
        "qualityDesign": "B+",
        "readability": "A-",
        "testability": "B"
      },
      "issues": {
        "cyclomaticComplexity": 65,
        "dependenciesModules": 3,
        "functionMethodCounts": 6,
        "linesOfCode": 417,
        "nestingDepth": 50
      }
    },
    "hash": "4279cc84ace17a237147d65c648c3e6b29c516091748e2a13640902f1c281b83",
    "id": "eJy1O2tvGze2f+VUQBMpkSWnbXYBd1UgzaPNReoEcdL9YBkLeoaSWFPkXJJjRzfr/35xDh9DjkZ2EqDJF3mGPDw879d8HjFrubVCrT9oLUcno+d620j+SbjdaDqqdM2fa+W4cqOTUcOqK7bmYHijjVuqpRJb/AXjpVq6Ja2WfOWOKinmKyEdN8sRzOfwzNp2K9Qa3EZYaJjbgLBQaWN45fze1dYtR/7nxm3l3PFtI5nj8aHU6/hT2/gLIeFBHH/EhxZxi7+dEWpN6yeI73wO7wn5U13TPQy3XDkLDBQ+GSMw0AZqgahps5uAUOA28dLgDOezpXK7huegrDNt5eAzHnvKthy6fx4HfPEOL95/Ab1/8zm8aqX0VDJcMieuOTgNRmui1Wv7Qphu/aXWEh+/4I4JaePj8wvPgNlvhtU8vpzP4cxpwy08e/MGilcrbTx7iARjsQJ/ED5h0nKkn3u+EbI2XKVDHmU0yG7wTjctcq8msJGYglsYtyhr0GihHDfWQ9XX3KBg+X8rqZn7x0/7dHnOZBXAvv3z5Xu8QhW3JvSRjznQt1eJTH1Se2JLtgaxAlouZQfxhlmo/ImXkkCihkSwFmDLmnPPw4sMZcQzgmi4AYcHk1w9tP6PdMLb952cPbTAwuOqv33SP/ztVX54drXsPgVlGNiGV2IlKo9Cebd5UIOlui2U5E/Bb14wx2CjZW0BqVPjn4rzmtdwuSPF+P3DH28gqmupGglArh7vtSZ5iaI6IETzOXzQzZHk11ySPNp5Lcyw8DyTEkmTCf6eXqHUa4NiI4V1oFfQKvG/LSdaoOS3qkZQb70IPIscHmAwGrNDbAJWGW29ahHSnm2ORYgHhHs+h3Dyvgj0Qc4JZQK8MdwiY0iLB60JknHDwcWVsKalrQ16GSTACa1sx/vfuOKGOY5MQd565sA6PLYd071JnNGuD+yKoxm1UlQcSZwZl8B+C8yCUE2LW1atqg4cNV7ndmnQkE1Bt65pvUX1N5929/QU8Y8nwI3RxoueWIHkqoA/gcUCjv3rpZN6PXtnhHJSjZejfzOjhFqfwKkOpKsDUo3R1wJ1wOlEmESO0cQDQ742SFwm5Q4qw3ERU8C3jdvNt0KJLZPRr2gDhrvWKFqBKCcgr7QBpW+mILl7SGdXnNfAVA3CwY2QEqS44nLXoRJPARdtF3GXwD2ZwW9Gt01p/i938EpITr5rjL6HLrHGhbyOi04WQE/ynb/ukAklTdNZP8zg11bImmQm03L0okEqWsNhZfSWloTzyPnZWQACAB/QslvHG9Aq0dJL4kZww0y12U1BaZc0x8KOO4Jgkr05WcAlYuMR+WA4H5cX7BD/cdZ5mwwm2fFpZ7WjwtoJGF61xoprLnfTDnFkUqWl5JWDtdSXDJWBOQtjshiKbbmdgm233gHr0g7YCd0Al55xh/hv2RUfZ3bJ0/DzrecWHZA7ijMEPLAtWKEJmcZ2i/p6pzl79frNy7PyCJSW57rF4GngAKHcJHkkNFzg40zk7R3w1dIhGf4z9eHYyQIMUxhxJh4GRY2mi59ShBrINcZdUyiZ2jcMUwj0nMIwwfLn3S0npRadUTC4CaLMZLNhl9yJinR9TN5qJYx1E2Arx0tbi+7Z+1AEhvFqpxp2nO5K3HnWNHIHuAateyZkCZPnWl1zRAZpajn+QDvsHR6ZYxIiFv1k5FZ0lFM4npJZDGSZTCIbCGLiQZTCwIEEbwGsabiqx/HJtAtabuMFZ2c+Ek+LOlX7KVe1GNcFqxj1gG6ge+75DrnG5dcMb+BYztvofov3HykYICn9t3CbFL0J5Xw01yoXIwZywnAj3AaumRR1Upt0ndfOm2C3Mbpdb0hGHmkj1kIx+ShZOAqkyHs4AhqCHXrMqqpFGMRkR/YeNYcwfKVNCCnWd9oDcv6GVVcB5QpvQQIXmIuP0XJPo1N7g7FR4nbP8gemixXqJpOGs3r3LiKGuw5ieR4Puvh5f2MAu3SVVk6olvu/g5p5Hq1IBQdZ2C3wOoyMEspnlA4f/87sn8imxNOThc9m4gEU6yZjAiFM3wvDLhli+widzyPQCoSzoG8UpGgsYxOJNzospMS9PPqdqVpy2LbSiUZy4MpRnoQssuiMSQkLg5FspGdcx7OckYmynmUI5YVWvGBVgem53z3Dhxc/dxsSoI5J5DWuRINo3fDI1Q6uT8QI8SKrjJBuM9yyU+G7BSxHyxE8eBAf+0guPi9QucarJM5FBo/zjX3LP+n294Xq8QKZXb5PMvX4cffiC4gHC4gs/nxbgtyTxwU44wn6BzNX4DbMZVk4EtyIy9Zx26Nd0hCxgkHADx709OKXLsr1uAQL0qfEPCrYuNifaLdnUh97GAgO/VXtg72gSY+CKj3qdMlp7zcRDkY+BeADtrjjwBfYmQH635bOu/M3rB/0+AzTBwAYafrYDT1pu7VzsqI2C1NKF5l8YiC0bbcUMw+GGee49yKEM8SiYmkXeeQLKbHfY2fPM/oNSIaCn1XGx1vg0vL7IRxTdmqg0VgDFESTLXOb2Sk7HU/uIe4KXV5gdCR0CPowyN13qZkz7dxzTJ4zuy9Wd3vujDgFiMV+QNCR5y6IveDv6QzeGd4ww73D9laO51WQpbuOxY+TRa8cElBLhZCTkK+nyG/qF8TSRnyf5Cu879UrTqDHxbAsL0EQqJwmcU1hKE+gHzOX9//HDN4xYzmlN/wTr1oKeHoEcNtGTjGXRQqkN6f8ZrwcYXznibIcTWavWlXZcVxCf01mdMK4W/ghvMZCwSRIAQL/bgFKyMjvkESvtm72ErPo1Xg5WjEhfa7eENZFxeoEvr9ZjgjPnMu+voAF0GAjMSWdvRBm3FUecixOFqDt7I+rWphnUo7T9ikc//Pp08nPX41qqBd4QFnG+fB7+zDinJ0yiP4rylY79J4TzAM3+AbkiJABQ3JY+8j5EDPHztV8xQ10GM6eS235OGQEHT1RfmYvvXSN8wtFzfoGqkZh/RIRQBBUDEIQZ22FfmfVyqzOUlOeYgUxxqcsJ/C9XS5VSQCCGhBTQna1tgPVFP/c1zdWkrlUt4z1J6EoyduyhsDcbLjxCnjFd1ixjx7YdxHGsbIzIYXFl9dMthxXhoodgdErsssDbQHmCFKs2x0qAtV31ewmeT11uD3xOas5DUXOw3Azd1zvBcNRLOZzONVmy6T4v0AViwacOW38JSutrLCOq2rnd6i4vCaW5Gbggz6TzG7G9SxR1u8JuJ+Xey+6HPnAginUnX4EQQlLO2Hp1a4I41BYRZZeMovlfXyTamK+spYkwfpa7WsHtebW18v2qlyAwhQ5fXe97F6OTnrV/c+xIEfZe/HOh2rzOXxEv4KQUV+vOG/AUR6LNSoyO3VmDRUVhXwnQhhYxc5ZgPVS2Ra7XTccaq0eumi46raRosJfHkB04JRxJehkrLCSMyCKGeaTsihEhCaIRdCkTVbxrGOyhMHmWIcqMVy2yBAFGy4bkgcP62DFple9TJrQ3JfHe7hJKunPKTQHajb0elKU55DQUS38QR5kgF/3CsYJgfO48QKo1eBraHVhbIpssWHGC0to5c7OGincOIKZwnI0TxX3UN+nPWVhfyB59QVyQnug6oDBnXKQsTlE6q3BF/HumJfGbYi9mOJOl5MF8e+ycfuGWfcuLBkLRLJD+ehJSrMw0M+OWgykwPlrOifliL3gvr82/+uxJyA8LiHEO/mIfsOrK6pBoA7HdJ9/EhYL2ZVuZQ2XqLS1MElHL3fAoDH8WujW9/zT3WinUOtTqtZS+w2pgap2nuF20SEhVpBR7rPvbAnbc3Ud/j7DPQ015AeZlelW+Eb9SdYvQwjTfAFikS/opC420v3xaHViiS+Zn/if2ugZFKo/FccE3Uhr6li4Tqcwa3UlvO3zL/P9RV/6BA5WRaeHNr29OtnbhF3lfEdWyRCrqB6LEHrFMj8OS8Q5hfjfm/tka+jPKUT+ZDWZfbEl9efKzdLcQWayihfDALuf8zm8IAfA6jpknKEO8RDF7qEPpUo8ciljmc8pBQ0LMCTBBd54XuGkemozhb9a66BtanRCgZqhr71/f1hArjN3kwwV1ns5xW96rjJfVwtzn4J8gYrsK0mmwSTBZGbaxtNb2NK9HlYTrIv1TorMjqt68UNv9TdpxdfrRSFmPl4ojBiQYSNKx/KYpugG3YXU+qptOjt3WLs6aRpQsUNKFg6eFNgOiExp5Sskc9/MCxWxGlOEQgf5qk1oTs2zkEabmptJeQSBfemhZWX4bEWILfz5uQctTEAPc+8q8eUsespwbf/33vISE1+A3V9zaTi76j++LR/0/hQr+C4HvXfylxuzIcb1zrsdNBOZqJHpCiYALnmlt6FjHhbHmFfxT65n0xLsfvk05iYkX11mMtyNzbuV3RJbTib5+Dtrk9uiT54Slq2uxUqEG5BB9XZE7mKqcqAljFjT+sxWTJf7sw33pTLBllkbrBi2f1JbZorzG631mM1edC56cCaFjo/t1IHGkEdvuJm/b8B6q7O+fNmPny7VJI3BEEUWA4WTrP6B8kz38YOAXSJ9dHQEoYfnvT6J3NHRURc+o4sN5clv6d19YzPNp3vAWbWJo3apgQJaVb7OH5KLeBvMN/MkxGLEVSfxwnZfkjmlb7pYf6ADl7O/aMHlba4Yy//3v2WbayjGH+i40cW0CRNJwsJWkNHt6ezf1vl7SxM4xC+acKCW5S6MGZZNvzR0SAE6UTCbgxhINqqsT/uNvT1iQeH7+825vMswuOPtVX9L7iOC4h5u+XV+Xktq8Qd7xl2RVYVQIL7t2ku+z0zy+igJ7DzI8/ZSRxgH2koFXo/3rzvYYso3UbMtaxQO6PEA2AMd02/rl95m+tn1k7K+Ym9QqodNaIoeaH4Sv7MO7IE73tcILcC8vSqkpB9k7a+l8AeoKumnCOakz2EadagSEmhSgu5Z4y5KLE2yH3NosfnhdRZr+F3lLwYkadCtMHK9eMzfZS8aO+B+afPfOZJVCsupvskuVuYb3WCHDQMdYZIj3r9zS7Uw93mvEGlRm7C3Fml1nFZ9zTze4Ka7p+zy6tMXMwvNz3pt+JpaTP3J9xgZ7o055sUpirgzkc68xTD10GYUm4oNh2jZWZKyJtWh33BzVM7V34t/HG6bQu5wPMU8juWof3a3dPWew/ANc0rVUiKFOHh+bFjdmxfrNNyFDzgyYgyPCgxZ3YPi4rfkkytEthh1Ykkjju2kbzUud6GSlidyUHOOTigE8zrLVYfShH2rjbG9jYXeTBfvNeF3adidBn1Y/jp7fgfgv8G6J+s6PDX41XRL8j5MuE62w/RJaIcNGKKsNh7GT+4QpVz3933qYNx1/xjKofDLDcRdt5n2n2pKvEiJkBdT2P88Bmq+Yq106QumMpeNuWtv/LZIWvFd5x58rnpSfM5E3hTdGVe9IeCYlvbHe33CW5SuQlqWTxWHChLQVOgyNWSwVXtGM/0eDjZiVDUWU/gLaOSavgXqhjVp0bm4CCkcdsrpyV8XZVLXdafLDWgxcD5tnH0P5wsJl3yFhWkv6BQh5dNA+/Dow4J/dcfj38SJrnv2vkf5jvB6lRN9eWhKXOUT4uH24SIPHlCbpXCHk1KEhxjVrR0WHoy9PjohhdsRJ/x493jNHcU1r1XNP033Mxn8WmDLwoeF1HOkSM331vO9/rOK9CkLTiSHHrlfIao4B53HBPFKo2ePlqMTeIpNsmf46yf89Sv++hF/PcdfP+CvF/jrCf56hb+O07xP10RFvjfMCItBE349ZvmRUJYrK/ALRSoY+OvqK9/361A8j827D/pj03DjrzW5iFUGncKH9AHOKv/+5qMyvNJrhf3ykPfipMkUu92MBuOZhVcwPp7g3MU6yweDGNIY24tgD5wGqW+4xXpDzT+REWn3TrD9mhctJtaX5aaUnq6H8tLEu/jhV8E//olItc/ySVE8OrByPwP2DHuj16LCMb1qEwpm/3MG/BPDD3vJraS23G8arnny6mIFGWK/QO/8csDmyQ/Hs+MsISk3Lxb37D6+a/cv/d1HT3r7//l123/obX/6ddt/7G3/sdzev1p4SbIymo7iYOroZDT/aLmx8w1XZifZ9nIe577nxbfTfpRojh9Cz9Z6dPv/3T1blA=="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/create.go",
    "grade": "A+",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:21.270Z",
    "codeReview": {
      "review": "Congratulations! Your most recent code changes passed."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "codeDiff": {
      "oldCode": "package report\n\nimport (\n\t\"codeleft-cli/filter\"\n)\n\ntype IReport interface {\n\tGenerateReport(gradeDetails []filter.GradeDetails, threshold string) error\n}\n\ntype HtmlReport struct {\n\tReportType string\n}\n\nfunc NewHtmlReport() IReport {\n\treturn &HtmlReport{\n\t\tReportType: \"HTML\",\n\t}\n}\n\n\nfunc (h *HtmlReport) GenerateReport(gradeDetails []filter.GradeDetails, threshold string) error {\n\treturn GenerateRepoHTMLReport(gradeDetails, \"CodeLeft-Coverage-Report.html\", threshold)\n}",
      "newCode": "package report\n\nimport \"codeleft-cli/filter\"\n\ntype IReport interface {\n\tGenerateReport(gradeDetails []filter.GradeDetails, threshold string) error\n}\n\ntype HtmlReport struct {\n\tReportType string\n}\n\nfunc NewHtmlReport() IReport {\n\treturn &HtmlReport{\n\t\tReportType: \"HTML\",\n\t}\n}\n\n\nfunc (h *HtmlReport) GenerateReport(gradeDetails []filter.GradeDetails, threshold string) error {\n\treturn GenerateRepoHTMLReport(gradeDetails, \"CodeLeft-Coverage-Report.html\", threshold)\n}",
      "changes": [
        {
          "oldCode": "\nimport (\n\t\"codeleft-cli/filter\"\n)\n",
          "newCode": "\nimport \"codeleft-cli/filter\"\n",
          "reason": "Modified",
          "start": 2,
          "end": 6
        },
        {
          "oldCode": "\n",
          "newCode": "\n",
          "reason": "Modified",
          "start": 20,
          "end": 21
        }
      ]
    },
    "hash": "01954ea4b871b97b6f09f1d4df93aec5db6e5bec2febeb03b0de7cbcd09b2e45",
    "id": "eJytkk9Lw0AQxb/KMgdJJGn0mptUaIVqi1Y8uB7WZJIsbnbD7EQpJd9d8oc2BY/elpn3e2+GnSMo79F7bcu9cwZS2L7dvezi/XYX395ABJnLcekso2VIoVHZlypREDaOWFppdd2/RCCtZDmoDRYcZ0YnhTaMJEHasFfyoUHx8DyQQltGKlSG4tiTK7RIinHsBiWpHO+RlTZevH+MRovVrBoJrgh95UwuPJO2ZSiQyJG03SlszbWZ8jxTm/EYNpb2vWJEJ6ZobSae8OeMBeFp4IEk5JasuDorhvLcMhUS1vvHjYSob3WT9+QeVOL6DIfi//a+GHBu2w/zh30kJCxdjpv+t5buG0mVGI/CRcW1kTDLCqXtIIJCG9wpriCF5NUj+aRCSwej6s+kbg3rxmBycQPjoSQZoWJclA66Xy86560="
  },
  {
    "assessingTool": "Complexity",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/create.go",
    "grade": "A",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:23.598Z",
    "codeReview": {
      "review": "Congratulations! Your most recent code changes passed."
    },
    "gradingDetails": {
      "grades": {
        "maintainabilityIndex": "A+",
        "qualityDesign": "B+",
        "readability": "A-",
        "testability": "B+"
      },
      "issues": {
        "cyclomaticComplexity": 1,
        "dependenciesModules": 1,
        "functionMethodCounts": 3,
        "linesOfCode": 24,
        "nestingDepth": 1
      }
    },
    "hash": "506130a52255c535bd485ceab24221f2fe02d2309ea8dbbc8d83fd718a6ede70",
    "id": "eJytkk9LxEAMxb9KyEFa6W7vvVZYhVVE1pPjYWzTdnA6UzKpuiz97tI/7HbBo7cheb/3EiYn1CFQCMbVB+8tZpj7trP0Y+SICRa+pNw7ISeYYaeLT10TMHWeRTnlTDu+IFJOiZrUlirZFNaklbFCrFC5eFTKsSN4eJlIME6IK10QnEZyR45YC83dqGZd0h2JNjbA2/tstN2tqglIwxQab0sIwsbVMRCzZ+WGc9i9tHbJC8J9IXPYXDqMihldmKp3BTzR9wWL4vPAE8kkPTu4uSim8toyA4X3h8e9wmRsDYv34h41cHuBY/i/va8GXNuOw/xhn4DC3Je0H38r91/EuqbNLNw20lqFq6xYuQETrIylZy0NZpi+BuKQNuT4aHX7kba9FdNZSq9uYD6UtGDSQtva4/ALXnnoow=="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/assessment/violations.go",
    "grade": "A",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:24.417Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "dependencyInversionScore": "A*",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "A*",
      "openClosedScore": "A*",
      "singleResponsibilityScore": "A*"
    },
    "hash": "684a602af2d547b5a80fd57c62bfcbee7e2f7baa64bcac00dc61fbb14f885bec",
    "id": "eJyNUt1LwzAQ/1eOgNJJXd8LPm0ogszh14sRie2lC6aXktwmY+x/lzSbm7CKb5fk93WX2wgVAoZgqHlyzopSPN7f3U5FLipX48QRI7EoRaeqT9UgJHSLxJIkmbZzniGTJFn2DIuaLytrCm0so5ciPemWYzmKpKKAF+OsYuPoAaMAejDE6LWqELTz4PtrQw2s9sggidcd/kndRLN0nx2I8PqWwoxvvKpxiqyMDSNJ212aiaPgLJ5QbjuLsddwwlZRDZ038fHIix3wAqFKkrvMgwaB/bLiTR9EL6mCGX4NgbPRiRB9xx556QnOh5hR/2CRVXAxhBzBf6eXnONfveewgvIKvKIGj0fRIyTrlsfzOCedSfHjWMK1sVjCWcihF07lxK3QqyaeailJihxW44icqRZj3WNjsUfGleLUoMiFNhbniheiFMVzQB+KBZJfW9V+FO3SsuksFr/29LDQxSH7uHFi+w3JxCjk"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/report/create.go",
    "grade": "A",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:24.495Z",
    "codeReview": {
      "detailedReview": {
        "tasks": [
          {
            "done": false,
            "titleTask": "singleResponsibility",
            "violatingCode": "The provided code snippet imports a \"filter\" package. Without further context, it's difficult to pinpoint a specific violation of the Single Responsibility Principle (SRP). However, the import itself doesn't inherently violate SRP. A potential SRP violation could arise if the `filter` package or any code using it, attempts to handle multiple, unrelated responsibilities within a single function or class.\n",
            "codeResolution": "```markdown\n**Code Resolution for Single Responsibility**\n\nThe provided code snippet imports a package, but doesn't show any functionality. Without more context, it's impossible to assess SRP violations. However, a general strategy for improving SRP is to identify classes or functions that handle multiple, distinct responsibilities.\n\n**Example:**\n\nIf a function `ProcessData` both validates data and saves it to a database, split it into two functions: `ValidateData` and `SaveData`. This ensures each function has a single, well-defined purpose.\n```\n",
            "severity": "Low",
            "rationale": "The provided code snippet imports a package, but without further context, it's impossible to assess its adherence to the Single Responsibility Principle (SRP). SRP dictates that a module should have one, and only one, reason to change. If the imported package `codeleft-cli/filter` handles multiple unrelated concerns, it violates SRP. This could affect maintainability, as changes in one area might necessitate modifications in others. It could also impact correctness if responsibilities are intertwined, leading to unexpected side effects.\n",
            "lineStart": 6,
            "lineEnd": 6,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "interfaceSegregation",
            "violatingCode": "There is no code snippet provided to analyze for interface segregation. Therefore, I cannot provide any information about violating code.\n",
            "codeResolution": "The provided code snippet imports a package named \"filter\". Without more context, it's difficult to assess interface segregation directly. However, a general strategy for improving interface segregation is to break down large, general-purpose interfaces into smaller, more specific ones.\n\nIf the \"filter\" package contains interfaces, review them to ensure they are focused on specific responsibilities. If an interface has methods that are not all relevant to a particular implementing type, consider creating separate, smaller interfaces.\n\nFor example, if a `Filter` interface has methods for both data validation and data transformation, create separate interfaces like `Validator` and `Transformer`. This allows types to implement only the interfaces relevant to their functionality, adhering to the Interface Segregation Principle.\n",
            "severity": "Critical",
            "rationale": "The provided code snippet imports a package, but doesn't show any interfaces. Therefore, there is no basis to analyze Interface Segregation Principle (ISP) adherence. Without seeing the interfaces and their implementations, it's impossible to determine if the interfaces are minimal and specific to client needs. Thus, no rationale can be provided.\n",
            "lineStart": 19,
            "lineEnd": 5,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "openClosed",
            "violatingCode": "There is no code provided to analyze for the \"violatingCode\" request.\n",
            "codeResolution": "```markdown\n**Code Resolution**\n\nThe provided code snippet imports a package named \"filter\". Without further context, it's difficult to provide a specific fix. However, a general refactoring strategy for the Open/Closed Principle (OCP) would involve:\n\n1.  **Identify areas for extension:** Determine where new filter types might be needed.\n2.  **Define an interface:** Create an interface (e.g., `Filter`) with a method for filtering.\n3.  **Implement concrete filters:** Create concrete filter types (e.g., `NameFilter`, `DateFilter`) that implement the `Filter` interface.\n4.  **Use the interface:**  Use the `Filter` interface in the code that uses filters.\n\nThis approach allows adding new filter types without modifying existing code, adhering to OCP.\n```",
            "severity": "Critical",
            "rationale": "The provided code snippet imports a \"filter\" package. Without further context, it's difficult to assess Open/Closed Principle (OCP) adherence. However, if the \"filter\" package is designed to be extensible without modification, it adheres to OCP. If adding new filter types requires changing existing code within the package, it violates OCP. Violations can hinder maintainability, as changes may introduce bugs. It could also affect performance if the filtering logic isn't optimized for extensibility.\n",
            "lineStart": 0,
            "lineEnd": 5,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "liskovSubstitution",
            "violatingCode": "There is no code snippet provided to analyze for Liskov Substitution Principle (LSP) violations. The provided context only includes import statements and empty lines. Therefore, I cannot identify any code that violates LSP.\n",
            "codeResolution": "```markdown\n**codeResolution:**\n\nThe provided code snippet doesn't offer enough context to assess Liskov Substitution Principle (LSP) adherence. LSP requires a hierarchy of types (interfaces and concrete implementations). Without seeing the `filter` package's structure, it's impossible to determine if subtypes can substitute their base types without altering the correctness of the program.\n\n**To improve LSP adherence (general advice):**\n\n1.  **Ensure Substitutability:** Subtypes must be substitutable for their base types.\n2.  **Avoid Breaking Contracts:** Subtypes should not weaken the contracts defined by the base type (e.g., preconditions, postconditions, invariants).\n3.  **Design Carefully:** Design interfaces and base classes with LSP in mind, considering how subtypes will behave.\n```",
            "severity": "Critical",
            "rationale": "Rationale:\n\nThe provided code snippet imports a \"filter\" package. Without further context, it's difficult to assess Liskov Substitution Principle (LSP) adherence directly. LSP ensures subtypes can replace their base types without altering program correctness. If the \"filter\" package defines interfaces or abstract types, and concrete implementations don't fully adhere to the expected behavior of the base types, it could lead to unexpected results, reduced maintainability, and potential performance issues. For example, if a filter implementation unexpectedly modifies data, it could break LSP.\n",
            "lineStart": 0,
            "lineEnd": 19,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "dependencyInversion",
            "violatingCode": "The provided code snippet imports a specific package \"codeleft-cli/filter\" (line 4). This direct import creates a dependency on a concrete implementation, violating the Dependency Inversion Principle. Instead of depending on a specific implementation, the code should depend on an abstraction (interface) to allow for flexibility and easier testing.\n",
            "codeResolution": "```markdown\n**Dependency Inversion Principle (DIP) - Code Resolution**\n\nThe provided code snippet imports a package \"codeleft-cli/filter\". To improve DIP, consider defining an interface for the filter functionality. This allows the `codeleft-cli` package to depend on an abstraction rather than a concrete implementation.\n\n**Refactoring Strategy:**\n\n1.  Define an interface (e.g., `Filter`) with methods for filtering.\n2.  Have the `codeleft-cli/filter` package implement this interface.\n3.  Use the interface in the dependent code.\n\n**Example:**\n\n```go\n// In a separate package or file\ntype Filter interface {\n    Apply(data string) string\n}\n\n// In codeleft-cli/filter package\ntype MyFilter struct {}\n\nfunc (f *MyFilter) Apply(data string) string {\n    // Filter logic\n    return data\n}\n\n// In the dependent code\nimport (\n    \"your_package\"\n    \"codeleft-cli/filter\"\n)\n\nfunc main() {\n    var f your_package.Filter = &filter.MyFilter{}\n    // Use f.Apply()\n}\n```\n```",
            "severity": "Critical",
            "rationale": "The provided code snippet imports a package, which is a good practice. However, without more context, it's difficult to assess its impact on the Dependency Inversion Principle (DIP). If the `filter` package is an abstraction, and the code depends on its interface rather than a concrete implementation, it adheres to DIP. This promotes maintainability by allowing changes to the implementation without affecting the dependent code. It also enhances testability and could indirectly affect performance if different implementations have varying efficiencies.\n",
            "lineStart": 6,
            "lineEnd": 5,
            "status": ""
          }
        ],
        "codeReviewTitle": "SOLID Code Review"
      }
    },
    "gradingDetails": {
      "dependencyInversionScore": "F",
      "interfaceSegregationScore": "F",
      "liskovSubstitutionScore": "F",
      "openClosedScore": "F",
      "singleResponsibilityScore": "B"
    },
    "codeDiff": {
      "oldCode": "package report\n\nimport (\n\t\"codeleft-cli/filter\"\n)\n\ntype IReport interface {\n\tGenerateReport(gradeDetails []filter.GradeDetails, threshold string) error\n}\n\ntype HtmlReport struct {\n\tReportType string\n}\n\nfunc NewHtmlReport() IReport {\n\treturn &HtmlReport{\n\t\tReportType: \"HTML\",\n\t}\n}\n\n\nfunc (h *HtmlReport) GenerateReport(gradeDetails []filter.GradeDetails, threshold string) error {\n\treturn GenerateRepoHTMLReport(gradeDetails, \"CodeLeft-Coverage-Report.html\", threshold)\n}",
      "newCode": "package report\n\nimport \"codeleft-cli/filter\"\n\ntype IReport interface {\n\tGenerateReport(gradeDetails []filter.GradeDetails, threshold string) error\n}\n\ntype HtmlReport struct {\n\tReportType string\n}\n\nfunc NewHtmlReport() IReport {\n\treturn &HtmlReport{\n\t\tReportType: \"HTML\",\n\t}\n}\n\n\nfunc (h *HtmlReport) GenerateReport(gradeDetails []filter.GradeDetails, threshold string) error {\n\treturn GenerateRepoHTMLReport(gradeDetails, \"CodeLeft-Coverage-Report.html\", threshold)\n}",
      "changes": [
        {
          "oldCode": "\nimport (\n\t\"codeleft-cli/filter\"\n)\n",
          "newCode": "\nimport \"codeleft-cli/filter\"\n",
          "reason": "Modified",
          "start": 2,
          "end": 6,
          "grade": "F"
        },
        {
          "oldCode": "\n",
          "newCode": "\n",
          "reason": "Modified",
          "start": 20,
          "end": 21,
          "grade": "F"
        }
      ]
    },
    "hash": "a81fbf4634491073f059718077617293d873d9c55ae7bd7106704f10c754920a",
    "id": "eJytkstqw0AMRX9l0KLYxYn33iaQBNIHbbrqdDG1ZXvoWGM0cksI/vfiB3lAl90N0j33SoxOYELAECxVB+8dZPD6tN+tIYHcF7jyJEgCGbQm/zIVKsbWs2jSZJvhpSJNWvSodljKInc2La0TZA2a4kEpxxbV7mUklSVBLk2O6jSQGyRkIzh1o4pNgWsUY11Q7x+T0XJzVU2U1Iyh9q5QQdhSFStk9qypP4dtpXFzXhDucpnCptJhUEzozJQd5eoRfy5YFJ8HHklG6ZjU3UUxlq8tM6Vhe3jYa0iGVj97z+5Rre4vcKz+b++bAa9th2H+sE+UhpUvcD/81sp/I5sKF5NwWUvjNFxlxZp6SKC0Dp+N1JBB+haQQ1oj8dGZ5jNtOie2dZje3MB0KGnOaASXlYf+F+M95fA="
  },
  {
    "assessingTool": "Complexity",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/assessment/violations.go",
    "grade": "A",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:25.446Z",
    "codeReview": {
      "review": "Congratulations! Your most recent code changes passed."
    },
    "gradingDetails": {
      "grades": {
        "maintainabilityIndex": "A+",
        "qualityDesign": "A",
        "readability": "A",
        "testability": "A"
      },
      "issues": {
        "cyclomaticComplexity": 1,
        "dependenciesModules": 2,
        "functionMethodCounts": 3,
        "linesOfCode": 25,
        "nestingDepth": 0
      }
    },
    "hash": "9889a7259144abea675db19203c0566555d6210b70298e88b75b343032785274",
    "id": "eJyNUl9LwzAQ/ypHQOmktu8Fnyr6NoaoL0YktpcumF5Kcq2Ose8uaTc3YRXfLsnv311uK1QIGIKh5tE5KwpRuraz+GV4I1JRuRpLR4zEohCdqj5UgzBRWiSWJMm0nfMMiSTJcmRY1HxdWZNrYxm9FNOTbjmWi0jKc3g2zio2jh4wCqAHQ4xeqwpBOw9+vDbUwHBABkm86fBP6jaaTffJkQgvr1OY7N6rGm+RlbFhIWm3T1M6Cs7iGeU4jthrOGOrqIbOm/h44sUOeI1QTZL7zLMGgX1f8XYMonuqYImfc+BkcSbE2LFH7j3B5Rwz6h8tkgqu5pAL+O/0Juf4V28pDFDcgFfU4OkoRoRk3XK2inPSiRQ/jgXcGYsFXIQURuGpLN2AXjXxVEtJUqQwZBG5VC3GesTG4oCMK8VTgyIV2lhcKV6LQuRPAX3I10h+Y1X7nre9ZdNZzH/t6XGh82P2rHFi9w0gLiuX"
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/assessment/coverage.go",
    "grade": "A",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:25.503Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 1,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "8df3566c0ddbbe06b6ba8ac92055b3858b9eadb848039b6edba4c1d8bb4e8422",
    "id": "eJytVMFu2zAM/RVOQAd7S+2uuxnLgKLFdmuDttsO0zCoNpUIUyhDYloURf59kG05TeP1NJ9kUu/x8VHSk1AhYAiGlrfOWVGJqx9nN4vj26vF8YcTMRO1a/DcESOxqESr6j9qidCD1kgsSZJZt84zZJIkyw5hUfNxbU2pjWX0UvQpvea0dCGu8ggvSzh39+jVEs86XnVnEQwxeq1qBO08jCoh0kM97JfEjy2+Dn+KBftM2pfxymNYOdss0NdIHLfPoEFWxgb4+auXXXz1qsGLPprDnXNW0nZScrQCVooai2Ff4p5XE2o7ZGC/qbmXeo3RTfSQvu/GWcXGUcrEXWPw4jXRO7mX+DBRt/aoGAMoIHyYEmYosKIaJekN1dMsmU+KD5TmU6PpuvTIG0/w9pCuS+9sqCDRz2Jiu2tpf6aDz4f2L1VsAhSMQx+ayWoF7w7r5/C/DkvfKTtWFqo5nMS/WhUHo5tPkzxtoSzhGgMy3CdMiCTxRvxOEiK1V7TEUdLgYF/4/XyIF+fjpYlZo1/G4RMctDpQ/Uu3alukJptIJnV5T7AdZtfVtUhZk4yaz+EkldFrLhbeEFvKpLh0oE28T+yG4Uox0A2nRysbMDGTZDU0Us1BW6f442nWmZBDOQaeF+/YWhVCRCTw52fgF3bkfRmj4U2HGmTXqkindVhMOZKPFsQ2v7SxT525UNxwg97PQIqzQUI6vBUcFaf66EhKkmKWFObP7k+UIWkrZiJatVC8EpUovwX0oVwh+Uer1nflemPZtBbLvbd59zCVqWCxdGL7F9coP0Y="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/assessment/coverage.go",
    "grade": "A",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:25.555Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "dependencyInversionScore": "A*",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "B",
      "openClosedScore": "A",
      "singleResponsibilityScore": "B"
    },
    "hash": "64b9de5be844a05fe0244c995d4e322aa3e7740a48aaac26bdd95c8178f35a75",
    "id": "eJytVFFr2zAQ/is3QYe9ZXbp3swyKC0bg9GVdtvLNIZqnxIx5WSkS0sp+e9FtpQ0jden5Um5u++7776T/CBUCBiCocV356xoxPW3r1/OxUy0rsMzR4zEohG9av+qBcJYvUJiSZLMqneeoZAkWQ4Ii5rftdbU2lhGL8WY0ivORxfiqYzwuoYzd4teLfB04FU3FsEQo9eqRdDOw1YeRHpoU70kvu/xZfhDbDhmcl3BS49h6Wx3ib5F4lg+gw5ZGRvg1+9RdvXZqw7Px2gJN85ZSZtJydEKWCrqLIZ9iXteTagdkIH9uuVR6hVGN9FD/v00zio2jnImVm2D5y+J3sm9wLuJvq1HxRhAAeHdlDBDgRW1KEmvqZ1mKXxWfKC0nFrNMKVHXnuC14d0Q3pnQwOZfhYTm91I+ztNPh/av1BxCFCwXXoapmgVvDnsX8L/uizjpOxYWWjmcBz/tao6WN18muRhA3UNVxiQ4TZjQiSJL+JPlhCpvaIFbiUlB8fGb+cpXp1tH03MGv08Dh/gYNRE9S/dqu+RumIimdWVI8Em7W7oa5GKLhs1n8NxbqNXXF16Q2ypkOLCgTbxPbFLy5Ui0aXbo5UNmJlJskqDNHPQ1il+f1IMJpRQbwNPmw9svQohIjL44xPwMzvKsY3R8GpAJdmtqvJtTYcpR8qtBXHMT32cUxcuVNfcofczkOI0SciXt4Gj6kQfHUlJUsyywvLJ+4kyJG3ETESrLhUvRSPqHwF9qJdI/t6q1U29Wls2vcV679u8+zDVuWG1cGLzCDpGPYk="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/assessment/violations.go",
    "grade": "A+",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:25.759Z",
    "codeReview": {
      "detailedReview": {
        "tasks": [
          {
            "done": false,
            "titleTask": "inputValidation",
            "violatingCode": "The `ConsoleViolationReporter`'s `Report` method iterates through a slice of `filter.GradeDetails` and prints violation details to the console.\n\n```go\n19: func (c *ConsoleViolationReporter) Report(violations []filter.GradeDetails) {\n20: \tfor _, v := range violations {\n21: \t\tfmt.Printf(\"Violation: File: %s, Grade: %s, Coverage: %d\\n\", v.FileName, v.Grade, v.Coverage)\n```\n",
            "codeResolution": "```markdown\n**codeResolution:**\n\nThe `inputValidation` issue is not present in the provided code snippet. The code defines a `ViolationReporter` interface and a `ConsoleViolationReporter` implementation. There is no input validation logic in this code.\n```",
            "severity": "Critical",
            "rationale": "The `inputValidation` issue, specifically related to server-side request forgery, is critical because it can lead to security vulnerabilities. Without proper validation, malicious actors could potentially manipulate server requests, leading to unauthorized access or data manipulation. This can severely impact the correctness and reliability of the application.\n",
            "lineStart": 19,
            "lineEnd": 21,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "adminEndpointExposure",
            "violatingCode": "The provided code snippet does not demonstrate any issues related to `adminEndpointExposure`. The code defines a `ViolationReporter` interface and a `ConsoleViolationReporter` implementation, which focuses on reporting violations to the console.\n",
            "codeResolution": "```markdown\n**Code Resolution for `adminEndpointExposure`:**\n\nThe provided code snippet does not directly address `adminEndpointExposure`. This vulnerability typically arises from exposing administrative endpoints without proper authentication or authorization.\n\n**Remedy:**\n\nImplement robust authentication and authorization mechanisms for all administrative endpoints. This may involve:\n\n*   **Authentication:** Using API keys, JWT tokens, or other secure methods to verify the identity of the user or service accessing the endpoint.\n*   **Authorization:** Implementing role-based access control (RBAC) or similar strategies to ensure that only authorized users or services can access specific administrative functions.\n\n```\n",
            "severity": "Critical",
            "rationale": "Rationale:\n\nThe `adminEndpointExposure` issue is critical because exposing admin endpoints can lead to unauthorized access and control of the system. This can severely impact maintainability as it introduces a significant security risk, potentially requiring extensive remediation efforts. It can also affect the correctness of the system by allowing malicious actors to manipulate data or disrupt operations.\n",
            "lineStart": 19,
            "lineEnd": 21,
            "status": ""
          }
        ],
        "codeReviewTitle": "OWASP-TOP-10 Code Review"
      }
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 1,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 1,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "codeDiff": {
      "oldCode": "package assessment\n\nimport (\n\t\"codeleft-cli/filter\"\n\t\"fmt\"\n)\n\n// ViolationReporter interface for reporting violations\ntype ViolationReporter interface {\n\tReport(violations []filter.GradeDetails)\n}\n\n// ConsoleViolationReporter implements ViolationReporter and prints violations to the console\ntype ConsoleViolationReporter struct{}\n\nfunc NewConsoleViolationReporter() ViolationReporter {\n\treturn &ConsoleViolationReporter{}\n}\n\nfunc (c *ConsoleViolationReporter) Report(violations []filter.GradeDetails) {\n\tfor _, v := range violations {\n\t\tfmt.Printf(\"Violation: File: %s, Grade: %s, Coverage: %d\\n\", v.FileName, v.Grade, v.Coverage)\n\t}\n}\n",
      "newCode": "package assessment\n\nimport (\n\t\"codeleft-cli/filter\"\n\t\"fmt\"\n\t\"os\"\n)\n\ntype Violations interface {\n\tPrint()\n\tAddViolation(detail filter.GradeDetails)\n}\n\ntype Violation struct {\n\tListViolations []filter.GradeDetails\n}\n\nfunc NewViolation() Violations {\n\treturn &Violation{}\n}\n\nfunc (v *Violation) AddViolation(detail filter.GradeDetails) {\n\tv.ListViolations = append(v.ListViolations, detail)\n}\n\nfunc (v *Violation) Print() {\n\tfor _, detail := range v.ListViolations {\n\t\t_, err := fmt.Fprintf(os.Stderr, \"File: %s Tool: %s Grade: %s Coverage (Percent): %d \\n\", detail.FileName, detail.Tool, detail.Grade, detail.Coverage)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error printing violation\")\n\t\t\treturn\n\t\t}\n\t}\n}\n",
      "changes": [
        {
          "newCode": "\t\"os\"",
          "reason": "Added",
          "start": 6,
          "end": 6
        },
        {
          "oldCode": "\n// ViolationReporter interface for reporting violations\ntype ViolationReporter interface {\n\tReport(violations []filter.GradeDetails)\n}\n\n// ConsoleViolationReporter implements ViolationReporter and prints violations to the console\ntype ConsoleViolationReporter struct{}\n\nfunc NewConsoleViolationReporter() ViolationReporter {\n\treturn &ConsoleViolationReporter{}\n}\n\nfunc (c *ConsoleViolationReporter) Report(violations []filter.GradeDetails) {\n\tfor _, v := range violations {\n\t\tfmt.Printf(\"Violation: File: %s, Grade: %s, Coverage: %d\\n\", v.FileName, v.Grade, v.Coverage)",
          "newCode": "\ntype Violations interface {\n\tPrint()\n\tAddViolation(detail filter.GradeDetails)\n}\n\ntype Violation struct {\n\tListViolations []filter.GradeDetails\n}\n\nfunc NewViolation() Violations {\n\treturn &Violation{}\n}\n\nfunc (v *Violation) AddViolation(detail filter.GradeDetails) {\n\tv.ListViolations = append(v.ListViolations, detail)\n}\n\nfunc (v *Violation) Print() {\n\tfor _, detail := range v.ListViolations {\n\t\t_, err := fmt.Fprintf(os.Stderr, \"File: %s Tool: %s Grade: %s Coverage (Percent): %d \\n\", detail.FileName, detail.Tool, detail.Grade, detail.Coverage)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error printing violation\")\n\t\t\treturn\n\t\t}",
          "reason": "Modified",
          "start": 7,
          "end": 22
        }
      ]
    },
    "hash": "6a54acc1628bc59a44efd3d7fa8ce8937b6cef9a4560dd0990355ddebac56364",
    "id": "eJyNUl9LwzAQ/ypHQOmka/W14INM9G0rOvXBiMTu0gXTS0lukzH23SXt5iZs4tsl+f27y62FCgFDMFRPnbOiEJOXm8dyOJ2Uw6tLkYrKzXDkiJFYFKJV1aeqEXpSg8SSJJmmdZ4hkSRZdgyLmoeVNbk2ltFL0T/phmM5iKQ8h2fjrGLj6AGjAHowxOi1qhC08+C7a0M1LHfIIIlXLf5JXUez/j7ZE+H1rQ+T3Xs1w1tkZWwYSNps04wcBWfxiHLTWoy9hiO2imbQehMfD7zYAc8Rql5ym/mkQWC/qHjdBdELqmCMX6fAyeBIiK5jj7zwBOenmFF/b5FUcHEKOYD/Tq93jn/1nsISimvwimo8HEWHkKwbzso4J51I8eNYwJ2xWMBZSKET7suRW6JXdTzNpCQpUlhmETlWDca6w8Zih4wrxX2DIhXaWCwVz0Uh8qeAPuRzJL+yqvnIm4Vl01rMf+3pfqHzffasdmLzDUfAKqE="
  },
  {
    "assessingTool": "Complexity",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/assessment/coverage.go",
    "grade": "A-",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:26.697Z",
    "codeReview": {
      "review": "Congratulations! Your most recent code changes passed."
    },
    "gradingDetails": {
      "grades": {
        "maintainabilityIndex": "C+",
        "qualityDesign": "B+",
        "readability": "A-",
        "testability": "A-"
      },
      "issues": {
        "cyclomaticComplexity": 25,
        "dependenciesModules": 3,
        "functionMethodCounts": 30,
        "linesOfCode": 50,
        "nestingDepth": 2
      }
    },
    "hash": "2c42ea67f5344be973b7510709fb5fc948b0467a7dd7f98d6e46cb8945895f5c",
    "id": "eJytVE1v2zAM/SucgA72ltlFdzOWAUWK7VYU3cdlGgbVphNhMmVITLuiyH8fZEtO0ng9zSeZ1Ht8fJT0JJT36L2m9VdrjajEyna9wT+aH8VC1LbBlSVGYlGJXtW/1RphhHRILEmS7nrrGDJJkuWAMNjyu9rostWG0UkxptqO09L6sMoDvCxhZe/RqTVeDrzqziBoYnStqhFa62DSCIEe6rhfEj/2+DL8KRQcM2lfxhuHfmNNc4OuRuKwfQENstLGw4+fo+zis1MNXo3RHO6sNZJ2s5KDFbBR1Bj0xxKPvJpROyA9u23No9RbDG6ig/R919Yo1pZSJuyaglcvid7LvcaHmbq1Q8XoQQHhw5wwTZ4V1Sip3VI9z5K5pPhEaT43mqFLh7x1BK9P6Yb03oYKEv0iJHb7lo5nGn0+tX+tQhOgYBp6bCarFbw5rZ/D/zosY6dsWRmolnAe/mpVnIxuOU/ytIOyhFv0yHCfMD6QhBvxK0kI1E7RGidJ0cGx8NtljBer6dKErG6fx+EDnLQaqf6lW/U9UpPNJJO6fCTYxdkNdQ1S1iSjlks4T2Xajosbp4kNZVJcW2h1uE9s43CliHTx9LTKeEzMJFnFRqoltMYqfn+RDSbkUE6Bw+IDW6+8D4gE/ngAfmZHPpbRLbwaUFF2rYp0WuNizpF8siC0+akPfbaZ9cUXbtC5BUhxGSWkw1vBWXHRnp1JSVIsksL84P4EGZJ2YiGCVTeKN6IS5TePzpcbJPdoVHdXdlvDujdYHr3N+4epTAWLtRW7v4RPQDw="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/assessment/assessor.go",
    "grade": "A+",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:27.533Z",
    "codeReview": {
      "review": "Congratulations! Your most recent code changes passed."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "codeDiff": {
      "oldCode": "package assessment\n\nimport (\n\t\"codeleft-cli/filter\"\n)\n\n// GradeAssessable interface for assessing code grades\ntype GradeAssessable interface {\n\tAssessGrade(threshold string, details []filter.GradeDetails) bool\n}\n\n// GradeAssessment handles grade assessment\ntype GradeAssessment struct {\n\tCalculator       filter.GradeCalculator\n\tReporter         ViolationReporter\n\tViolationDetails []filter.GradeDetails\n}\n\n// NewGradeAssessment creates a new GradeAssessment instance\nfunc NewGradeAssessment(calculator filter.GradeCalculator, reporter ViolationReporter) GradeAssessable {\n\treturn &GradeAssessment{\n\t\tCalculator: calculator,\n\t\tReporter:   reporter,\n\t}\n}\n\n// AssessGrade assesses code grades against a threshold\nfunc (ga *GradeAssessment) AssessGrade(threshold string, details []filter.GradeDetails) bool {\n\tpassed := true\n\tga.ViolationDetails = []filter.GradeDetails{} // Reset violations\n\tfor _, detail := range details {\n\t\tif ga.Calculator.GradeNumericalValue(detail.Grade) < ga.Calculator.GradeNumericalValue(threshold) {\n\t\t\tpassed = false\n\t\t\tga.ViolationDetails = append(ga.ViolationDetails, detail)\n\t\t}\n\t}\n\tif !passed {\n\t\tga.Reporter.Report(ga.ViolationDetails)\n\t}\n\treturn passed\n}",
      "newCode": "package assessment\n\nimport (\n\t\"codeleft-cli/filter\"\n\t\"fmt\"\n\t\"os\"\n)\n\ntype Accessor interface {\n\tAssess(threshold string, details []filter.GradeDetails) bool\n}\n\ntype AccessorGrade struct {\n\tCalculator       filter.GradeCalculator\n\tViolationCounter Violations\n}\n\nfunc NewAccessorGrade(calculator filter.GradeCalculator, violationCounter Violations) Accessor {\n\treturn &AccessorGrade{\n\t\tCalculator:       calculator,\n\t\tViolationCounter: violationCounter,\n\t}\n}\n\nfunc (ag *AccessorGrade) Assess(threshold string, details []filter.GradeDetails) bool {\n\tfailed := true\n\tfor _, detail := range details {\n\t\tif ag.Calculator.GradeNumericalValue(detail.Grade) < ag.Calculator.GradeNumericalValue(threshold) {\n\t\t\tfailed = false\n\t\t\tag.ViolationCounter.AddViolation(detail)\n\t\t}\n\t}\n\tif !failed {\n\t\tag.ViolationCounter.Print()\n\t}\n\treturn failed\n}\n\ntype AccessorCoverage interface {\n\tAssess(thresholdPercent int, details []filter.GradeDetails) bool\n}\n\ntype AccessorAverageCoverage struct {\n\tViolationCounter Violations\n}\n\nfunc NewAccessorAverageCoverage(violationCounter Violations) AccessorCoverage {\n\treturn &AccessorAverageCoverage{\n\t\tViolationCounter: violationCounter,\n\t}\n}\n\nfunc (aac *AccessorAverageCoverage) Assess(thresholdPercent int, details []filter.GradeDetails) bool {\n\ttotal := 0\n\tfor _, detail := range details {\n\t\ttotal += detail.Coverage\n\t\tif detail.Coverage < thresholdPercent {\n\t\t\taac.ViolationCounter.AddViolation(detail)\n\t\t}\n\t}\n\tif (len(details)) == 0 {\n\t\tfmt.Println(\"No files to assess\")\n\t\treturn false\n\t}\n\n\taverage := float32(total) / float32(len(details))\n\tpass := average >= float32(thresholdPercent)\n\n\tif !pass {\n\t\taac.ViolationCounter.Print()\n\t}\n\tfmt.Fprintf(os.Stderr, \"Average coverage: %.2f%%\\n\", average)\n\treturn pass\n}\n",
      "changes": [
        {
          "newCode": "\t\"fmt\"\n\t\"os\"",
          "reason": "Added",
          "start": 5,
          "end": 5
        },
        {
          "oldCode": "// GradeAssessable interface for assessing code grades\ntype GradeAssessable interface {\n\tAssessGrade(threshold string, details []filter.GradeDetails) bool",
          "newCode": "type Accessor interface {\n\tAssess(threshold string, details []filter.GradeDetails) bool",
          "reason": "Modified",
          "start": 7,
          "end": 9
        },
        {
          "oldCode": "// GradeAssessment handles grade assessment\ntype GradeAssessment struct {",
          "newCode": "type AccessorGrade struct {",
          "reason": "Modified",
          "start": 12,
          "end": 13
        },
        {
          "oldCode": "\tReporter         ViolationReporter\n\tViolationDetails []filter.GradeDetails\n}\n\n// NewGradeAssessment creates a new GradeAssessment instance\nfunc NewGradeAssessment(calculator filter.GradeCalculator, reporter ViolationReporter) GradeAssessable {\n\treturn &GradeAssessment{\n\t\tCalculator: calculator,\n\t\tReporter:   reporter,\n\t}\n}\n\n// AssessGrade assesses code grades against a threshold\nfunc (ga *GradeAssessment) AssessGrade(threshold string, details []filter.GradeDetails) bool {\n\tpassed := true\n\tga.ViolationDetails = []filter.GradeDetails{} // Reset violations\n\tfor _, detail := range details {\n\t\tif ga.Calculator.GradeNumericalValue(detail.Grade) < ga.Calculator.GradeNumericalValue(threshold) {\n\t\t\tpassed = false\n\t\t\tga.ViolationDetails = append(ga.ViolationDetails, detail)\n\t\t}\n\t}\n\tif !passed {\n\t\tga.Reporter.Report(ga.ViolationDetails)\n\t}\n\treturn passed\n}",
          "newCode": "\tViolationCounter Violations\n}\n\nfunc NewAccessorGrade(calculator filter.GradeCalculator, violationCounter Violations) Accessor {\n\treturn &AccessorGrade{\n\t\tCalculator:       calculator,\n\t\tViolationCounter: violationCounter,\n\t}\n}\n\nfunc (ag *AccessorGrade) Assess(threshold string, details []filter.GradeDetails) bool {\n\tfailed := true\n\tfor _, detail := range details {\n\t\tif ag.Calculator.GradeNumericalValue(detail.Grade) < ag.Calculator.GradeNumericalValue(threshold) {\n\t\t\tfailed = false\n\t\t\tag.ViolationCounter.AddViolation(detail)\n\t\t}\n\t}\n\tif !failed {\n\t\tag.ViolationCounter.Print()\n\t}\n\treturn failed\n}\n\ntype AccessorCoverage interface {\n\tAssess(thresholdPercent int, details []filter.GradeDetails) bool\n}\n\ntype AccessorAverageCoverage struct {\n\tViolationCounter Violations\n}\n\nfunc NewAccessorAverageCoverage(violationCounter Violations) AccessorCoverage {\n\treturn &AccessorAverageCoverage{\n\t\tViolationCounter: violationCounter,\n\t}\n}\n\nfunc (aac *AccessorAverageCoverage) Assess(thresholdPercent int, details []filter.GradeDetails) bool {\n\ttotal := 0\n\tfor _, detail := range details {\n\t\ttotal += detail.Coverage\n\t\tif detail.Coverage < thresholdPercent {\n\t\t\taac.ViolationCounter.AddViolation(detail)\n\t\t}\n\t}\n\tif (len(details)) == 0 {\n\t\tfmt.Println(\"No files to assess\")\n\t\treturn false\n\t}\n\n\taverage := float32(total) / float32(len(details))\n\tpass := average >= float32(thresholdPercent)\n\n\tif !pass {\n\t\taac.ViolationCounter.Print()\n\t}\n\tfmt.Fprintf(os.Stderr, \"Average coverage: %.2f%%\\n\", average)\n\treturn pass\n}\n",
          "reason": "Modified",
          "start": 15,
          "end": 41
        }
      ]
    },
    "hash": "71f199a63c2d9b31b8eb4c49bf312d71003f9c3ba9a93cb9bf9b01d101c967f2",
    "id": "eJylVEtv2zAM/iucDoM9pPF2NZZD0QK7tUHXdYd5GBiZdoQplCHJK4rA/32Q5UeaGMWA+SSI5PcgaR0FOkfOKa4fjdEiF/ffr79urx7vt1efPoqVkKakG8Oe2ItcNCh/Y00Qiw7EvuCC1aEx1kNScOGLvkJT5a+kVlmltCdbiILTkJll8MViSdd9Pe40gWJPtkJJUBkLkxoIMFCHZFewf2nojcpjYI6RPinxe0tub3QJzlvF9QpK8qi0gx8/o6R1n3gbb1PYGaML7i41Bo+wRy41uSjnlflzYX2687aVPqq6QS1bjd5YiN8p/RwMqQ8U2khjIsCTMhq9MjxGQtZ0efuWo9nLHT2f65OW0JMDBKbnC/WKnUeWVHDVslyoT+TsadnNCuzo5cJDejHHvk+WfGsZ3p9x9bHTLuYws69icETOASbePtTNXThZjmF+5E5XDLDGYBwQpt0ZGpDUCB/OZKXw39sWbTdBTAn5BrxtKdzUuL4Y8WYZ6NhBlsEDOfLwZ6xxAST8Sr9GGQHdItc0yRq6qiqocT33NoLftQeySqJ+Qt1SEmtiKIXP/1AxtSMdiSafG6hQOxpvl71i0xCXyUJwdJRGgG4Ycu/k3UAxUNa4HvdiOCwBphPCsH8RpOBOrESlNG3R70Uusm+OrMv2xPZF42GXHVrtVaMpe/XazS/DcDR2XRvR/QUq+gIp"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/assessment/assessor.go",
    "grade": "A",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:27.583Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "dependencyInversionScore": "A*",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "A*",
      "openClosedScore": "A",
      "singleResponsibilityScore": "B"
    },
    "hash": "8ed61df1c495d61571ce3ce054ec91fcfac4bbcc33948bdcd25aa40e89a65240",
    "id": "eJylVE2L3DAM/SuqDyUp08k9dA9lB0qhbMu23UtTiiZRMqYeOdhKl2XIfy+O8zE7E5ZCczLW09N7kuKTQu/Je83NN2uNytXXz58+7tRGlbaiW8tCLCpXLZa/sSGI6COxFFywPrbWCSQFF1IMGYZqeVsandXaCLlCFZwGZJbBB4cVvR/ycW8INAu5GkuC2jqYZUCggSaAfcHy1NILmadQOUYGUCIHR/5gTQVenOZmAxUJauPhx88oaTsAd/E2hb21puD+WmPwCAfkypCPcp6ZvxQ2wL24rpSo6hZN2RkU6yB+5+WXYIDeU2gjTUCAB20NirY8RQJqvty95GjxckePl/pKRyjkAYHp8Uq9Zi/IJRVcd1yu5Cfl4mndzQbc5OXKQ3o1x6FPjqRzDK8vag2x8y7msFTfxODEnAPMdYdQv3ThbDnG+ZE/XzHABoNxQJh3Z2xA0iC8uZCVwn9vW7TdBjEV5DcgrqNw0+D2asQ360SnHrIM7smTwJ8pxweS8Cv9mmQEdofc0Cxr7KquocHt0ttIftcdyekSzQOajpKYE0MpvPuHjLkd6VRo9nkDNRpP0+26V2xb4ipZCU6O0kjQj0MenLwaS4wlG9xOezEe1gjTmWHcv0hScK82qtaGvqAcVK6y756czw7E7sngcZ8dOyO6NZQ9e+2Wl2E8WrdtrOr/AryOAGw="
  },
  {
    "assessingTool": "Complexity",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/assessment/assessor.go",
    "grade": "A-",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:28.657Z",
    "codeReview": {
      "review": "Congratulations! Your most recent code changes passed."
    },
    "gradingDetails": {
      "grades": {
        "maintainabilityIndex": "B+",
        "qualityDesign": "B+",
        "readability": "A-",
        "testability": "B+"
      },
      "issues": {
        "cyclomaticComplexity": 30,
        "dependenciesModules": 1,
        "functionMethodCounts": 4,
        "linesOfCode": 41,
        "nestingDepth": 2
      }
    },
    "hash": "794d642a0237df0364cd4907ebb8be83cc18df1651a787996c229f7fd299875b",
    "id": "eJylVEuL2zAQ/itTHYpd0vgemkPJQm9LWdq91KXM2mNHVB4ZadxtCP7vRZYf2cQsC/VJaGa+x8xYZ4Xek/ea62/WGrVTB9u0hv5qOamNKmxJB8tCLGqnWix+Y00QSxpiyTln3bTWCSQ555IPFYYq+VgYnVXaCLlc5ZyGzCyDLw5L+jzU45Mh0CzkKiwIKutg1gIBBuqQ7HOWU0uvVJ4Dc4wMSYkcHfmjNSV4cZrrDZQkqI2HHz+jpO2QeBdvU3iy1uTc32oMHuGIXBryUc4L89fChnQvriskqjqgKTqDYh3E75J+CYbUBwptpCkR4FFbg6ItT5GQNV/eveZo8XJPz9f6Ckco5AGB6flGvWYvyAXlXHVcrNQnxeJp3c0G3OTlxkN6M8ehT46kcwzvr7iG2GUXd7Cwb2JwQt4BzLxDqF+6cLEc4/zIX64YYI3BOCDMuzM2IKkRPlzJSuG/ty3aboOYEnZ7ENdRuKlxezPi/TrQuYcsgwfyJPBnqvEBJPxKvyYZAd0h1zTLGruqK6hxu/Q2gt93DTldoHlE01ESa2IohU9vqJjbkU5Es889VGg8TbfrXrFtictkJTg5SiNAPw55cPJupBgpa9xOezEe1gDTGWHcvwiSc682qtKGvqIc1U5l3z05nx2J3clg85Q1nRHdGspevHbLyzAerdvWVvX/ADDeAx8="
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/read/fileReader.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:28.709Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "caab4131348b739c8208ddf19c30eb24622c0729d3d40c75d59e32a0ffa3f4f2",
    "id": "eJydVlFv20YM/iucgBby4Mjbqwc/DG6xpSiSIGmxF71cJJ51i3Qn8Kh4RtH/PvBOZ0uZ0xjLS2SKR378+JG6b5nyHr03dvfFuTZbZ7d//f5wd/Xl9u7q11+yZVa5GrfOMlrO1lmvqie1QyBUdWlLa7reEUNe2pLL4Nui5quqNSttWkYqs/gKbeVqY3erv72zyag7To/Op6decSOHUR7EuJBEqxVsXY2fUfM9qhoJjGUkrSoB0yljPXCD4FWHpeVDj6/7f5NEYv3TeHZ0yBeQR7RFtBj0S0AiR4vSfh/Tj84pmgdC3zvrzWOLoB0FTozdBRhNdC6kWpBiihHUPIpnGipOgHp37xyD/HkmY3di3o6c3ilujuaE6Qb384AVoWL0oMDiHoz1rGyF4PQ8cRFOXzPsVfsUiTumrw1hJa7AhAjsQBtbBx9tyDMUqc2gXRu4YJD2DkKwH0NroBTQeMCu58NSHGvUamjZS1wJWQ1EaBn2jp6EvGP2GOceeSDrQdnYDzB6kt94sE5gDLYGZQ/7BgnB2BBZ8hel1YOt/sOTdHwuj9Tv2IuEPVhhvQHniz+Q93UuYmSjg/2nDVjTxhNyRqCKZQm64+KjxNN5mWllWqyl4B3y6wWv4d2+zELGkCT0uORAQjWQN8/YHmIvjgyIQzURyBGvuCXlHI/nqazLikCiCY4mxH0/o3E8lKSzDtI9chdfTvW7hhnYFD1lbWgpmU/ynsxomC5/frZAk+vCq9r4yj0j4YSjSyR1PuxMXo6gUlZ+P8b1l7SVNwQ/z2hZwIXLJbIex+WEd68meZcwkpPgjq1rqJhths0GyqzM3hRjSPN5MrynCidz403kPDT1nRdZNlTcT+WTZBGrDBiC7uLeLj45Y/MXIJdQZlOWy2xx1Pi2wepJWjFrA/5jPPtQstVuOo0PrDifJH9d0kaL/7W/cfxRwuUyYOnlD5iaAakdxqYERKAY+qDnkZsXOEZZ/yB4VJ6qqvjpnVX9yiIwGoSE4tp/MLLA3ur0GSLhcQhLU822ztkSTtvntkd7fkDEQf5P+yLel/Xlgn3pJPVb1HCNGil+ZLet85ifVPUBRe4B/aeH2xu5AzhQ4Fsz+yiK97OilApezmvMIqFCmYKkuMF9jE4y3jitc72B0buILvn7MfLit/9HRAx3iUrSKo2ep32aLTOBKS3J1tnqq0fyqwYtHVrVPa66oWXTt7iaXeFkzYWr2Hhr2Lns+7/Pd642"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/read/fileReader.go",
    "grade": "B",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:28.763Z",
    "codeReview": {
      "review": "This code has three critical areas of concern.  First, `NewHistoryReader` relies on `os.Getwd()`, which is not ideal for a reusable component.  Second, the error handling for `os.Stat` could be improved by checking for `os.IsNotExist` more explicitly.  Third, the code lacks clear separation of concerns; the `HistoryReader` handles both finding the `.codeleft` folder and reading the file, which blurs responsibilities.\n"
    },
    "gradingDetails": {
      "dependencyInversionScore": "A*",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "A",
      "openClosedScore": "B",
      "singleResponsibilityScore": "B"
    },
    "hash": "22c08cf634b69d6a60e7dfd34f4d76dedbc9100ad275f97840ae8fda38675790",
    "id": "eJydVlFv4zYM/iucgDs4Q+a8Z8hTeth6KNqh3d78otpUrNWRDIpuFhzuvw+UrMTu0muwvtShKfLjx4+0vikdAoZg3e5P7zu1Vk8Pd7c3aqlq3+DWO0bHaq16Xb/oHQKhbipXObvvPTEUlau4ir4dGv6l7uzK2I6RKpVeoat9Y91u9XfwLhvNnvOjD/mp19zKYZQHMS4k0WoFW9/gHRp+RN0ggXWMZHQtYPbaugDcIgS9x8rxscf3/b9JIrH+bgN7OhYLKBLaMlkshiUgkadF5b6P6UfnHC0AYei9C/a5QzCeIifW7SKMNjmXUi1IMeUIah4lMA01Z0C9f/SeQf4Ck3U7MW9HTv/Q3J7MGdM9HuYBa0LNGECDwwNYF1i7GsGbeeIynr5lOOjuJRF3St9YwlpcgQkR2IOxrok+xlJgKHObwfgucsEg7R2E4DCGNkA5oA2A+56PS3Fs0Oih4yBxJWQ9EKFjOHh6EfJO2VOcR+SBXADtUj/Amkl+G8B5gTG4BrQ7HlokBOtiZMlfVs4Mrv4PT9LxuTxyv1MvMvZohfUGfCh/Qz40hYiRrYn2nzbgbJdOyBmBKpYlmD2XXySeKSpltO2wkYJ3yO8XvIZPh0rFjDFJ7HHFkYR6oGBfsTumXpwYEId6IpATXnHLyjkdL3JZ1xWBRBMcbYz7eUbjeChLZx2le+IuvZzqdw0zsDl6ztrSUjKf5T2Z0Thd4fJsgSG/j68aG2r/ioQTjq6R1OWwM3l5glo7+f2c1l/WVtES/DyjZQFXLpfEehqXM96DnuRdwkhOhju2rqVythk2G6hUpT4UY0xzNxnec4WTuQk2cR6b+imILFsqH6fyybJIVUYMUXdpb5dfvXXFG5BLqNSU5UotThrftli/SCtmbcB/bOAQS3bGT6fxiTUXk+TvS9oa8b8N956/SLhCBiy//AFTMyCNx9SUiAg0Qx/1PHLzBsco6x8ET8rTdZ2+ubOq31kE1oCQUN6GGysL7KNOXyASnoe4NPVs61ws4bx9Hnp0lwdEHOT/tC/ifV1frtiXXlJ/RA03aJDSR3bb+YDFWVU3KHKP6L8+PdzLHcCDhtDZ2UdRvF815VTwdl5TFgkVyxQk5T0eUnSS8cZpnesNjN5lcik+j5EXv/4/IlK4a1SSV2nyPO9TtVQCU1qi1mr1V0AKqxYdHTu9f17th45t3+FqdoWTNRevYuOtYefV938BC8OseQ=="
  },
  {
    "assessingTool": "Complexity",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/read/fileReader.go",
    "grade": "A-",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:29.870Z",
    "codeReview": {
      "review": "Congratulations! Your most recent code changes passed."
    },
    "gradingDetails": {
      "grades": {
        "maintainabilityIndex": "C+",
        "qualityDesign": "B+",
        "readability": "A-",
        "testability": "B+"
      },
      "issues": {
        "cyclomaticComplexity": 35,
        "dependenciesModules": 30,
        "functionMethodCounts": 4,
        "linesOfCode": 84,
        "nestingDepth": 35
      }
    },
    "hash": "9ff38bdc7bf5613f6eb7cc7b4f863c2df470e10eec006dec98c12a0d4bfdde20",
    "id": "eJydVlFv2zgM/is8ARucQ855z6FP2bDrMHSH7u7NL6pNxVptyaDoZsGw/36gZCV2l67B9aUOTZEfP36k9V3pEDAE6/b/eN+prdr5fujwm+WjWqvaN7jzjtGx2qpB1496j0Com8pVzvaDJ4aichVX0bdDw3/Und0Y2zFSpdIrdLVvrNtvvgbvstH0nB99yE+D5lYOozyIcSWJNhvY+QY/oeF71A0SWMdIRtcCptfWBeAWIegeK8fHAV/2/y6JxPqXDezpWKygSGjLZLEY1oBEnlaV+zGln5xztACEYfAu2IcOwXiKnFi3jzDa5FxKtSDFlBOoZZTANNacAQ3+3nsG+QtM1u3FvJs4/VtzezJnTHd4WAasCTVjAA0OD2BdYO1qBG+Wict4+pbhoLvHRNwpfWMJa3EFJkRgD8a6JvoYS4GhzG0G47vIBYO0dxSCwxTaAOWANgD2Ax/X4tig0WPHQeJKyHokQsdw8PQo5J2ypzj3yCO5ANqlfoA1s/w2gPMCY3QNaHc8tEgI1sXIkr+snBld/RNP0vGlPHK/Uy8y9miF7Q34UH5APjSFiJGtifbfbsDZLp2QMwJVLGswPZfvJZ4pKmW07bCRgvfILxe8hTeHSsWMMUnsccWRhHqkYJ+wO6ZenBgQh3omkBNeccvKOR0vclnXFYFEMxxtjPt2QeN0KEtnG6V74i69nOt3CwuwOXrO2tJaMp/lPZvROF3h8myBId/HV40NtX9CwhlH10jqctiFvDxBrZ38fkjrL2uraAl+X9CygiuXS2I9jcsZ70HP8q5hIifDnVrXUrnYDDc3UKlKvSrGmObTbHjPFc7mJtjEeWzqmyCybKm8n8snyyJVGTFE3aW9XX701hXPQK6hUnOWK7U6aXzXYv0orVi0Ab/ZwCGW7IyfT+MX1lzMkr8saWvE/zbceX4v4QoZsPzyF0wtgDQeU1MiItAMQ9TzxM0zHJOsfxE8KU/XdfrwLqp+YRFYA0JCeRveWVlgr3X6ApHwMMalqRdb52IJ5+3zeUB3eUDEQf7P+yLe1/Xlin3pJfVr1HCDBil9ZHedD1icVfUORe4R/ccvn+/kDuBBQ+js4qMo3k+acip4Pq8pi4SKZQqS8g4PKTrJeOO8zu0NTN5lcineTpFXf/4/IlK4a1SSV2nyPO9TtVYCU1qitmrzb0AKmxYdHTvdP2z6sWM7dLhZXOFkzcWr2HRr2Hv14z9wuK8s"
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/read/findCodeLeft.go",
    "grade": "A*",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:29.925Z",
    "codeReview": {
      "review": "Congratulations! Your code has passed the code review assessment."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "hash": "64b0a0d1b00b5ba2dcd721f8d219865e7e2c26c5a76896e7e659141c1647b781",
    "id": "eJx1U01v2zAM/SucgHU24FjbNUAOW9oBBQa0WDv0oosqU7EQmQooOVlQ5L8PsuN8bN1JND/fe6TfhI4RY3S0eg7Bi7l4ePn69Dh7fnicffksKmFCg8tACSmJudhos9YrBEbdKFLkuk3gBIUilZSwXVJiNEOcrI1OrbTOYzays8yFUoJ11CxDgx5t+omm5+i2CBE1mxYj8OTye7CBQUPjGE0KvAfSHTagRG2O9UpATw0yKMEhJCVqRbYn8/6QIudATOxoVUIxGhUgc+AS3jLurWaYmj/q1B6zM3SVkBnmC5hI1S/ar4eeFeShxeZcUIEjGyDE+rvzeE82VLDTfn3HPM0bnnGqSs6ewh8WQM5PAZUYU880hUfvYXykhGWLZg3OgumZkRIMIFz8v24/Bt1OYzPO+j7eOi5KuLk5s/umIw6USlgsrovP4K60WgzDp5CU8LR2G2gwGqTG0Qpsz6lFhkAGYYeftgg29NSAhk4n0/5F+QQl97l119yPOeR8/j7k68p08B8Fj4lKKDHsekgfF5pluyKwGNLerbRdqu/yymxxocWFyE3ACBQS4G8XE2ja71pkHA90Dh9j7pKvpbxAcBxxiaIaOR0UiUpkCbJTzIX8FZGjbJF473X3KrveJ7fxKKfqmfFO5l9UTuefIdarIA5/ACNda2o="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/read/findCodeLeft.go",
    "grade": "C",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:29.979Z",
    "codeReview": {
      "review": "1. **Missing Error Handling:** The `filepath.Walk` function's error is not checked within the loop.  This could lead to silent failures if there's an issue during traversal.  Example:  `if walkErr != nil { return walkErr }` should be outside the loop.\n\n\n2. **Inconsistent Naming:**  `.codeLeft` in the code and `.codeleft` in the function signature.  This inconsistency should be fixed for better readability and maintainability.\n\n\n3. **Unnecessary Variable:** The `codeleftPath` variable is assigned within the loop but not used until after the loop.  This is unnecessary and can be simplified.\n"
    },
    "gradingDetails": {
      "dependencyInversionScore": "F",
      "interfaceSegregationScore": "B",
      "liskovSubstitutionScore": "B",
      "openClosedScore": "F",
      "singleResponsibilityScore": "A*"
    },
    "hash": "30d90911e2bba8dd138e0952d0d1d5d992cdfe3fc1c4e6c3f83f7ae2e0c4271a",
    "id": "eJx1U02L2zAQ/StTQbc2uNY94EuTLQQWWrotveiiyqNYRB6ZkZw0LPnvRXacTdrtSeP5fO/N+EXoGDFGR7vvIXixEs9fnrYbUQkTWlwHSkhJrMSgzV7vEBh1q0iR64fACQpFKilh+6TEbIa4WINOnbTOYzays8yFUoJ11K5Dix5t+oZm5OgOCBE1mw4j8OLyJ7CBQUPrGE0KfALSPbagRG0u9UrASC0yKMEhJCVqRXYk8/aQIudATOxoV0IxGxUgc+ASXjLug2ZYmn/VqbtkZ+gqITOsGlhI1T+13089K8hDi+G1oAJHNkCI9WfncUs2VHDUfv/IvMybnnmqSs5ew+8aIOeXgEqMaWRawrP3PD9SwrpDswdnwYzMSAkmEC7+X7enSbfr2Iyz3saN46KEh4dXdp90xIlSCU1zX/wK7k6rZhq+hKSE570boMVokFpHO7Ajpw4ZAhmEI344INgwUgsaep1M9xflK5TcZ+PuuV9yyPn8fc7XlengPwpeEpVQYtr1lD4vNMt2R6CZ0t6stH2qH/PKbHGjxY3IbcAIFBLgbxcTaDodO2ScD3QF72Pukq+lvEFwGXGLopo5nRWJSmQJslOshPwRkaPskPjkdf9L9qNPbvAol+qPxjuZf1G5nH+GWO+COP8BPzxprQ=="
  },
  {
    "assessingTool": "Complexity",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/read/findCodeLeft.go",
    "grade": "A-",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:31.098Z",
    "codeReview": {
      "review": "Congratulations! Your most recent code changes passed."
    },
    "gradingDetails": {
      "grades": {
        "maintainabilityIndex": "B+",
        "qualityDesign": "B",
        "readability": "A-",
        "testability": "B"
      },
      "issues": {
        "cyclomaticComplexity": 25,
        "dependenciesModules": 20,
        "functionMethodCounts": 2,
        "linesOfCode": 35,
        "nestingDepth": 20
      }
    },
    "hash": "84bbb5eaa76e9e9179bc89973b007b931231fe08d39a707eb202aff84275361f",
    "id": "eJx1U0uL2zAQ/itTQbc2uNY94EuzW1joofRBL7qo8sgWkUdmJCcblvz3IjvOo92eNJ7n930zfhU6RozRUfcjBC82YhuG0eOLS0dRCRNa3AZKSElsxKjNTncIjLpVpMgNY+AEhSKVlLBDUmIxQ1ytUadeWucxG9lZ5kIpwTpqt6FFjzZ9QzNxdHuEiJpNjxF4dfkj2MCgoXWMJgU+AukBW1CiNud6JWCiFhmU4BCSErUiO5F5e0iRcyAmdtSVUCxGBcgcuITXjHuvGdbmX3Xqz9kZukrIDJsGVlL1L+13c88K8tBivBZU4MgGCLH+7Dw+kw0VHLTfPTGv8+ZnmaqSs5fwuwbI+TWgEmOamNbw4j0tj5Sw7dHswFkwEzNSghmEi//X7cus22Vsxlk/x0fHRQkPD1d2n3TEmVIJTXNffAV3p1UzD19DUsL3nRuhxWiQWkcd2IlTjwyBDMIBP+wRbJioBQ2DTqb/i/IFSu7z6O65n3PI+fx9yteV6eA/Cp4TlVBi3vWcviw0y3ZHoJnT3qy0Q6qf8spscaPFjchtwAgUEuCLiwk0HQ89Mi4HuoH3MXfJ11LeIDiPuEVRLZxOikQlsgTZKTZC/ozIUfZIfPR6+C2HySc3epRr9Ufjncy/qFzPP0OsuyBOfwDBv2xg"
  },
  {
    "assessingTool": "OWASP-TOP-10",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/read/configReader.go",
    "grade": "A+",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:31.941Z",
    "codeReview": {
      "review": "Congratulations! Your most recent code changes passed."
    },
    "gradingDetails": {
      "brokenAccessControl": {
        "clientServerAccessPolicyEnforcement": 0,
        "idorPrevention": 0,
        "roleBasedAccessControl": 0
      },
      "cryptographicFailures": {
        "dataEncryption": 0,
        "encryptionAlgorithmStrength": 0
      },
      "identificationAuthentication": {
        "multiFactorAuthentication": 0,
        "passwordPolicy": 0,
        "sessionManagement": 0
      },
      "injection": {
        "inputSanitization": 0,
        "preparedStatementsUsage": 0
      },
      "insecureDesign": {
        "secureDesignPattern": 0,
        "sensitiveDataExposure": 0,
        "threatModeling": 0
      },
      "securityLoggingMonitoring": {
        "anomalyMonitoring": 0,
        "criticalEventLogging": 0,
        "secureLogStorage": 0
      },
      "securityMisconfiguration": {
        "adminEndpointExposure": 0,
        "defaultConfiguration": 0,
        "securityHeaders": 0
      },
      "serverSideRequestForgery": {
        "inputValidation": 0,
        "internalSystemExposure": 0,
        "networkLayerProtection": 0
      },
      "softwareDataIntegrity": {
        "versionControl": 0
      },
      "vulnerableOutdatedComponents": {
        "knownVulnerabilities": 0
      }
    },
    "codeDiff": {
      "oldCode": "package read\n\nimport (\n\t\"codeleft-cli/types\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\n// FileSystem abstracts file system operations.\ntype FileSystem interface {\n\tGetwd() (string, error)\n\tOpen(name string) (*os.File, error)\n\tStat(name string) (os.FileInfo, error)\n\tJoin(elem ...string) string\n}\n\n// OSFileSystem implements the FileSystem interface using the os package.\ntype OSFileSystem struct{}\n\nfunc NewOSFileSystem() FileSystem {\n\treturn &OSFileSystem{}\n}\n\nfunc (o *OSFileSystem) Getwd() (string, error) {\n\treturn os.Getwd()\n}\n\nfunc (o *OSFileSystem) Open(name string) (*os.File, error) {\n\treturn os.Open(name)\n}\n\nfunc (o *OSFileSystem) Stat(name string) (os.FileInfo, error) {\n\treturn os.Stat(name)\n}\n\nfunc (o *OSFileSystem) Join(elem ...string) string {\n\treturn filepath.Join(elem...)\n}\n\n// JSONDecoder abstracts JSON decoding.\ntype JSONDecoder interface {\n\tDecode(v interface{}) error\n}\n\n// ConfigSource interface for reading configuration.\ntype ConfigSource interface {\n\tReadConfig() (*types.Config, error)\n}\n\n// ConfigPathResolver resolves the path to the config file.\ntype ConfigPathResolver interface {\n\tResolveConfigPath() (string, error)\n}\n\n// ConfigJSONReader reads the config from a JSON file.\ntype ConfigJSONReader interface {\n\tReadConfigFromJSON(path string) (*types.Config, error)\n}\n\n// ConfigReader is responsible for reading the config.json file.\ntype ConfigReader struct {\n\tRepoRoot     string\n\tCodeleftPath string\n\tFileSystem   FileSystem\n\t//\tJSONDecoder  JSONDecoder // Removed direct dependency on JSONDecoder\n}\n\n// NewConfigReader creates a new ConfigReader.\nfunc NewConfigReader(fs FileSystem) (*ConfigReader, error) {\n\tif fs == nil {\n\t\tfs = &OSFileSystem{} // Use OSFileSystem as default\n\t}\n\trepoRoot, err := fs.Getwd()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get current working directory: %w\", err)\n\t}\n\n\t// Recursively find .codeleft\n\tcodeleftPath, err := findCodeleftRecursive(repoRoot)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcr := &ConfigReader{\n\t\tRepoRoot:     repoRoot,\n\t\tCodeleftPath: codeleftPath,\n\t\tFileSystem:   fs,\n\t}\n\treturn cr, nil\n}\n\n// ResolveConfigPath resolves the path to the config.json file.\nfunc (cr *ConfigReader) ResolveConfigPath() (string, error) {\n\tif cr.CodeleftPath == \"\" {\n\t\treturn \"\", fmt.Errorf(\".codeLeft folder not found in the repository root: %s\", cr.RepoRoot)\n\t}\n\treturn filepath.Join(cr.CodeleftPath, \"config.json\"), nil\n}\n\n// ReadConfig reads the configuration from config.json.\nfunc (cr *ConfigReader) ReadConfig() (*types.Config, error) {\n\tconfigPath, err := cr.ResolveConfigPath()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check if config.json exists\n\tinfo, err := cr.FileSystem.Stat(configPath)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn nil, fmt.Errorf(\"config.json does not exist at path: %s\", configPath)\n\t\t}\n\t\treturn nil, fmt.Errorf(\"error accessing config.json: %w\", err)\n\t}\n\n\tif info.IsDir() {\n\t\treturn nil, fmt.Errorf(\"config.json exists but is a directory: %s\", configPath)\n\t}\n\n\t// Open the config.json file\n\tfile, err := cr.FileSystem.Open(configPath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to open config.json: %w\", err)\n\t}\n\tdefer file.Close()\n\n\t// Decode the JSON into a Config struct\n\tvar config types.Config\n\tdecoder := json.NewDecoder(file)\n\tif err := decoder.Decode(&config); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to decode config.json: %w\", err)\n\t}\n\n\treturn &config, nil\n}",
      "newCode": "package read\n\nimport (\n\t\"codeleft-cli/types\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\n// ConfigReader is responsible for reading the config.json file.\ntype ConfigReader struct {\n\tRepoRoot     string\n\tCodeleftPath string\n}\n\n// NewConfigReader creates a new instance of ConfigReader.\n// It walks the RepoRoot directory tree to find the first .codeleft folder it encounters.\n// If repoRoot is empty, it defaults to the current working directory.\n// Returns an error if .codeleft is not found anywhere in the repo.\nfunc NewConfigReader() (*ConfigReader, error) {\n\trepoRoot, err := os.Getwd()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get current working directory: %w\", err)\n\t}\n\n\t// Recursively find .codeleft\n\tcodeleftPath, err := findCodeleftRecursive(repoRoot)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcr := &ConfigReader{\n\t\tRepoRoot:     repoRoot,\n\t\tCodeleftPath: codeleftPath,\n\t}\n\treturn cr, nil\n}\n\n// ReadConfig reads the config.json file from the .codeleft directory.\n// Returns a Config instance and an error if the config.json file is not found or cannot be read.\nfunc (cr *ConfigReader) ReadConfig() (*types.Config, error) {\n\t// Ensure the .codeleft path is set\n\tif cr.CodeleftPath == \"\" {\n\t\treturn nil, fmt.Errorf(\".codeLeft folder not found in the repository root: %s\", cr.RepoRoot)\n\t}\n\n\tconfigPath := filepath.Join(cr.CodeleftPath, \"config.json\")\n\n\t// Check if config.json exists\n\tinfo, err := os.Stat(configPath)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn nil, fmt.Errorf(\"config.json does not exist at path: %s\", configPath)\n\t\t}\n\t\treturn nil, fmt.Errorf(\"error accessing config.json: %w\", err)\n\t}\n\n\tif info.IsDir() {\n\t\treturn nil, fmt.Errorf(\"config.json exists but is a directory: %s\", configPath)\n\t}\n\n\t// Open the config.json file\n\tfile, err := os.Open(configPath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to open config.json: %w\", err)\n\t}\n\tdefer file.Close()\n\n\t// Decode the JSON into a Config struct\n\tvar config types.Config\n\tdecoder := json.NewDecoder(file)\n\tif err := decoder.Decode(&config); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to decode config.json: %w\", err)\n\t}\n\n\treturn &config, nil\n}\n",
      "changes": [
        {
          "oldCode": "\n// FileSystem abstracts file system operations.\ntype FileSystem interface {\n\tGetwd() (string, error)\n\tOpen(name string) (*os.File, error)\n\tStat(name string) (os.FileInfo, error)\n\tJoin(elem ...string) string\n}\n\n// OSFileSystem implements the FileSystem interface using the os package.\ntype OSFileSystem struct{}\n\nfunc NewOSFileSystem() FileSystem {\n\treturn &OSFileSystem{}\n}\n\nfunc (o *OSFileSystem) Getwd() (string, error) {\n\treturn os.Getwd()\n}\n\nfunc (o *OSFileSystem) Open(name string) (*os.File, error) {\n\treturn os.Open(name)\n}\n\nfunc (o *OSFileSystem) Stat(name string) (os.FileInfo, error) {\n\treturn os.Stat(name)\n}\n\nfunc (o *OSFileSystem) Join(elem ...string) string {\n\treturn filepath.Join(elem...)\n}\n\n// JSONDecoder abstracts JSON decoding.\ntype JSONDecoder interface {\n\tDecode(v interface{}) error\n}\n\n// ConfigSource interface for reading configuration.\ntype ConfigSource interface {\n\tReadConfig() (*types.Config, error)\n}\n\n// ConfigPathResolver resolves the path to the config file.\ntype ConfigPathResolver interface {\n\tResolveConfigPath() (string, error)\n}\n\n// ConfigJSONReader reads the config from a JSON file.\ntype ConfigJSONReader interface {\n\tReadConfigFromJSON(path string) (*types.Config, error)\n}\n",
          "reason": "Modified",
          "start": 10,
          "end": 61
        },
        {
          "oldCode": "// NewConfigReader creates a new ConfigReader.\nfunc NewConfigReader(fs FileSystem) (*ConfigReader, error) {\n\tif fs == nil {\n\t\tfs = &OSFileSystem{} // Use OSFileSystem as default\n\t}\n\trepoRoot, err := fs.Getwd()",
          "newCode": "// NewConfigReader creates a new instance of ConfigReader.\n// It walks the RepoRoot directory tree to find the first .codeleft folder it encounters.\n// If repoRoot is empty, it defaults to the current working directory.\n// Returns an error if .codeleft is not found anywhere in the repo.\nfunc NewConfigReader() (*ConfigReader, error) {\n\trepoRoot, err := os.Getwd()",
          "reason": "Modified",
          "start": 70,
          "end": 75
        },
        {
          "oldCode": "}\n\n// ResolveConfigPath resolves the path to the config.json file.\nfunc (cr *ConfigReader) ResolveConfigPath() (string, error) {\n\tif cr.CodeleftPath == \"\" {\n\t\treturn \"\", fmt.Errorf(\".codeLeft folder not found in the repository root: %s\", cr.RepoRoot)\n\t}\n\treturn filepath.Join(cr.CodeleftPath, \"config.json\"), nil\n}\n\n// ReadConfig reads the configuration from config.json.",
          "newCode": "}\n\n// ReadConfig reads the config.json file from the .codeleft directory.\n// Returns a Config instance and an error if the config.json file is not found or cannot be read.",
          "reason": "Modified",
          "start": 92,
          "end": 102
        },
        {
          "oldCode": "\tconfigPath, err := cr.ResolveConfigPath()\n\tif err != nil {\n\t\treturn nil, err",
          "newCode": "\t// Ensure the .codeleft path is set\n\tif cr.CodeleftPath == \"\" {\n\t\treturn nil, fmt.Errorf(\".codeLeft folder not found in the repository root: %s\", cr.RepoRoot)",
          "reason": "Modified",
          "start": 104,
          "end": 106
        },
        {
          "newCode": "\n\tconfigPath := filepath.Join(cr.CodeleftPath, \"config.json\")\n",
          "reason": "Modified",
          "start": 108,
          "end": 108
        },
        {
          "oldCode": "\tinfo, err := cr.FileSystem.Stat(configPath)",
          "newCode": "\tinfo, err := os.Stat(configPath)",
          "reason": "Modified",
          "start": 110,
          "end": 110
        },
        {
          "oldCode": "\tfile, err := cr.FileSystem.Open(configPath)",
          "newCode": "\tfile, err := os.Open(configPath)",
          "reason": "Modified",
          "start": 123,
          "end": 123
        },
        {
          "reason": "Added",
          "start": 138,
          "end": 138
        }
      ]
    },
    "hash": "7d1acc8047e9355180e0eae34bed6eb98038f008476325050bedbfba484f035c",
    "id": "eJydV0tv4zYQ/itTARtIgSO1Vy98KLK7RRZFEti76EUXhho6bCRSIKm4RpD/XgwpWZQdP7C5RBgOZ755fUO/JcxatFaq9Q+t62SePPzz5+rx5sfD480fvyezhOsKb7VyqFwyT1rGX9gawSCrSlUq2bTaOEhLVbrS69Yo3A2vZeG2LdoyCSeouK6kWhf/Wq0GoWjc8Kl3mi1zz4WQNdIHCTPyUxTwTda42lqHDbAn6wzjzgIpgg1S3aJhTmpl81KR9/iKVA6NYBzhjfz8hW5TpRmk1hmp1jNAY7QhV+6hRZUq1iCEswzSa21zshWrrRxze2q91p0SOtb8rqVKscYG8jwflMP/Ur330T2sYrBNW2ODyllwz0fC6Khk/lhb6MsyxD0xZp3puHvzjkSnONzjJlZIs9iBz45B1xkFV7EaGRhtpBqu49MMjmR0YlDbvFc7beuCEuzb3V05Y/qysu1b3906Y/1EqScmh/7OdxfyPM/Gbvi+erj/gjROJmp2kkKFYZKGWseqe00exOnrKH97z0KEo6tbrYRcr3RnOEYGhDZ+yAk59ypdGK7B75F73vESWRXOqSGuPRPkQTAOxhTAI3PPS7S6fkVy7D9C91OewGn/HZD49E1xTK4foPHyUfGjuZ+ioaRSEBiSYCfOjW6AhWIcAoluHk3KN6Mb0kt9aGOLX5KnwbalJLVaWflUT6s1Qs2JbD/A2NsIxDCAa/VSawf0N3BT6W57Qn8cgZI44guIyIOOiqJ0cUtO+rMoYImNfsUKKmmQO6iwRVWh4lvQKtYd477HzQQ2N8gcWmCgcDOJKB8JLhanwkI8pOl1fDodeSlAWFgsQMk6SEpHgn0upFB+2j2mZRYqFKyrHV18D/Me8uq9wHwBIqJA747kv0389RyhZD0D0bj8K+ETaZkIJmusaBbW6IB3xqBysNHmheoeMqrNdg6fNmXiPWYDEF8ZWCLvjJWvWG9BSFVBPmxsUuBRsUe8UlVDF+yup0NYlwWBxkQ4uLd7FdegvzM04dx34S514TBuxTlMsAaFsRB0X9hZVASPhZsZ4Rk764AYzhHPZKDCCuAGJu2UHVo9thSlAG7yyYgtFlAmZbKXRBLttYIv3N8oHAhd01QoTZ+dqkAqj5jSZyX1Axif00+WrHCTL+PivR/dSnvYZkDvu10WyiQ7yObAbwec2a+OQJ2RkZNZPLtCQpb4Ls+7nvUxHhThF1qVWPcZ+QtQqaIOwP+kddYbHB4Nvd+xCcObYUR33L8U9MS4s/fafSXDKQ3ucHiCDmJElUbre8BDA+Z89+6KPkXRV/2EaZ9gYJyHXwZx8EfYRQqgXOR39os0aXaWyw7TCU+do73GJkz2Ef6xOvTq+3A+6VwMz8XD2vjX4iW1uYCLNWE4kyBXoUATmOO21hZ9O4YYwsLzUfg3hVROA+sXW7+kSfWVmeEJEk9DsB7263wBfqzucdOv0ZRcxuHNF9Br5/3z8CoYzT7/WvjB2gUdMvyo4P0QB/JIZglBpCok86T4adHY4hmV2daseSqarnayrbGY/LQkfil4vPnXOnn/HxoZTrs="
  },
  {
    "assessingTool": "Complexity",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/read/configReader.go",
    "grade": "A-",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:34.064Z",
    "codeReview": {
      "review": "Congratulations! Your most recent code changes passed."
    },
    "gradingDetails": {
      "grades": {
        "maintainabilityIndex": "B-",
        "qualityDesign": "B+",
        "readability": "A-",
        "testability": "B+"
      },
      "issues": {
        "cyclomaticComplexity": 45,
        "dependenciesModules": 30,
        "functionMethodCounts": 30,
        "linesOfCode": 137,
        "nestingDepth": 30
      }
    },
    "hash": "515e67f1c4cc30ad64db38f74d9869d1606fe1519d52528dac5041a5171ed422",
    "id": "eJydV01v2zgQ/SuzAhpIgVe6e+FT2i5SLNIi2d50Yaihw41EGuQorhHkvy+GlCzKjmOjuUQYDmfefL2hXzPhPXqvzfpfa9tsmd3YbtPiL027bJFJ2+CNNYSGsmW2EfJZrBEciqY2tdHdxjqCvDY11UG3RUV/ylZXtNugr7N4gkbaRpt19Z+3ZhSqjsZPu9fcCHqqlG6RP1hYsJ+qgq+6xYedJ+xAPHpyQpIHVgQfpXaDTpC2xpe1Ye/pFW0InRIS4ZX9/I20bfICck9Om/UC0Dnr2BV936DJjegQ4lkB+bX1JdtK1R5I0IHaoHVrlE01v1ltcmyxg7IsR+X4vzZvQ3TfH1KwnP8ODXmgpxNh9FywcGw9DGUZ454Z8+R6Sa/BkeqNhDvcpgp5kToI2XFIvTNwlaqxgclGbuE6PS3gREZnBq0vB7WPbV1QgkO7+ytnTF9WtkPr+1tnrH9Q6pnJsb/L/YWyLIupG749fL/7jDxOLml2lkKDcZLGWqeqB00exfnLJH99K2KEk6sba5ReP9jeSUwMKOvCkDNyGVT6OFyj3xP3guN7FE0854a4DkxQRsE0GHMAPwQ93aO37Quy4/ARu5/zBGTDd0QS0jfHMbt+hCbIJ8X35n6OhpPKQWBMgp85d7YDEYtxDCS5eTIpX53tWC8PoU0tfkmeRtuek7SxxuvHdl6tCWrJZPsOxsFGJIYR3MbeW0vAfyM31XQzEPqPCSiLE76AhDz4qKpqSlty1p9VBffY2RdsoNEOJUGDGzQNGrkDa1LdKe473M5gS4eC0IMAg9tZROVEcKk4Vx7SIc2v09P5yGsFysNqBUa3UVITCw65kEP56Q+YVnhoUIm+Jb74Fuc95jV4geUKVEKBwR3L/5j5GzjC6HYBqqPyC+NTeZ0poVtseBbWSCB759AQbK175rrHjFq3W8KnbZ0Fj8UIJFQG7lH2zusXbHegtGmgHDc2K8ik2BNebZqxC/bX8zGsy4JA5xIcMti9Smsw3BmbcBm6cJ+6eJi24hJmWKPCVAi+r/wiKULAIt2C8UyddUQM54hnNlBxBUgHs3Yqjq2eWopagXTlbMRWK6izOjtIIosOWiEU7h9UBMq2PBXG8mdvGtAmIOb0ec39AC7k9JNnK9KV92nx3k5upQNsC+D33T4LdVYcZXPktyPOHFZHpM7EyIdZPLtCYpbkPs/7ng0xHhXhN1qVWfcJ5TNwqZIOwF/akw8Gx0fD4HdqwvhmmNCd9q8VPzFu/Z2lL2w458EdDz+ggxRRY9GHHgjQQFDo3n3R5yiGqn9gOiQYhJTxd0Ea/Al20Qo4F+Wt/6xdXpzlsuN0wmNPvNfEjMnewz9Vh199784nn6vxuXhcm/BavKQ2F3CxZQxnEkQNKnSROW5a6zG0Y4whLrwQRXhTaEMWxLDYhiXNqi/CjU+QdBqi9bhflysIY3WH22GN5uwyDW+5gkG7HJ6HV9Fo8dfvhR+tXdAh448KOQxxJI9skTFErkK2zKqfHp2vntC4XSu6x6rrW9KbFqvZT0vml0qmm39ts7f/ASeST7E="
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/read/configReader.go",
    "grade": "C",
    "username": "Hlamb",
    "timestamp": "2025-05-24T18:06:34.896Z",
    "codeReview": {
      "detailedReview": {
        "tasks": [
          {
            "done": false,
            "titleTask": "liskovSubstitution",
            "violatingCode": "The provided code snippet does not demonstrate a violation of the Liskov Substitution Principle (LSP). The `NewOSFileSystem` function simply returns a concrete implementation (`OSFileSystem`) of the `FileSystem` interface. This is a standard factory pattern and does not inherently violate LSP.\n",
            "codeResolution": "```markdown\n**Code Resolution for Liskov Substitution Principle (LSP)**\n\nThe provided code snippet demonstrates good adherence to LSP. The `OSFileSystem` likely implements the `FileSystem` interface, allowing it to be substituted for other `FileSystem` implementations without altering the program's correctness.\n\n**No specific fix or refactoring is needed** based on the provided snippet. The `NewOSFileSystem` function correctly returns a concrete implementation (`OSFileSystem`) that adheres to the `FileSystem` interface. This design allows for interchangeable use of different file system implementations.\n```\n",
            "severity": "Low",
            "rationale": "Rationale:\n\nThe `NewOSFileSystem` function adheres to LSP because it returns a concrete implementation (`OSFileSystem`) that can substitute the `FileSystem` interface. This design choice ensures that any code expecting a `FileSystem` can use the `OSFileSystem` without unexpected behavior. This substitution principle is crucial for maintainability, as it allows for easy swapping of file system implementations (e.g., a mock file system for testing) without altering the core logic. It also helps with correctness by ensuring that the behavior of the file system is consistent across different implementations.\n",
            "lineStart": 19,
            "lineEnd": 20,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "openClosed",
            "violatingCode": "The provided code snippet demonstrates a violation of the Open/Closed Principle (OCP).\n\n```go\nfunc NewOSFileSystem() FileSystem {\n\treturn &OSFileSystem{}\n}\n```\n\nThis code is closed for modification. If you need to add a new file system type, you would need to modify this function.\n",
            "codeResolution": "```markdown\n**Code Resolution**\n\nThe provided code snippet demonstrates the creation of an `OSFileSystem` struct and its instantiation.\n\n*   **Open/Closed Principle (OCP) Fix/Refactoring Strategy:**\n\n    The current code adheres to OCP by allowing extension without modification. To further enhance OCP, consider defining an interface for `FileSystem` and implementing `OSFileSystem` to that interface. This allows for easy substitution of different file system implementations (e.g., a mock file system for testing) without changing the code that uses the `FileSystem`.\n\n    ```go\n    type FileSystem interface {\n        // Define file system operations here (e.g., ReadFile, WriteFile)\n    }\n\n    type OSFileSystem struct{}\n\n    func (o *OSFileSystem) ReadFile(filename string) ([]byte, error) {\n        // Implementation\n    }\n\n    func NewOSFileSystem() FileSystem {\n        return &OSFileSystem{}\n    }\n    ```\n```",
            "severity": "Low",
            "rationale": "Rationale:\n\nThe `NewOSFileSystem` function's direct return of a concrete `OSFileSystem` type violates the Open/Closed Principle. This design makes it difficult to extend the system with alternative file system implementations (e.g., a mock file system for testing) without modifying the existing code. This lack of flexibility can hinder maintainability, as changes to support new file system types require direct edits to the `NewOSFileSystem` function, potentially introducing errors and increasing the risk of breaking existing functionality.\n",
            "lineStart": 19,
            "lineEnd": 22,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "dependencyInversion",
            "violatingCode": "The `NewOSFileSystem` function directly returns a concrete `OSFileSystem` struct. This violates the Dependency Inversion Principle because the code is dependent on a specific implementation rather than an abstraction.\n\n```go\n20: \treturn &OSFileSystem{}\n```\n",
            "codeResolution": "```markdown\n**Code Resolution for Dependency Inversion**\n\nThe `NewOSFileSystem` function directly returns a concrete `OSFileSystem` struct. To improve dependency inversion, introduce an interface for `FileSystem`.\n\n**Refactoring Strategy:**\n\n1.  Define a `FileSystem` interface with methods like `ReadFile` and `WriteFile`.\n2.  Make `OSFileSystem` implement this interface.\n3.  The `NewOSFileSystem` function should return the interface, not the concrete struct.\n\n**Example:**\n\n```go\ntype FileSystem interface {\n    ReadFile(filename string) ([]byte, error)\n    WriteFile(filename string, data []byte) error\n}\n\ntype OSFileSystem struct{}\n\nfunc (o *OSFileSystem) ReadFile(filename string) ([]byte, error) {\n    // Implementation\n}\n\nfunc (o *OSFileSystem) WriteFile(filename string, data []byte) error {\n    // Implementation\n}\n\nfunc NewOSFileSystem() FileSystem {\n    return &OSFileSystem{}\n}\n```\n```",
            "severity": "Low",
            "rationale": "Rationale:\n\nThe `NewOSFileSystem` function directly returns a concrete `OSFileSystem` struct. This violates the Dependency Inversion Principle (DIP) because it couples the code to a specific implementation. This matters because it reduces flexibility and testability. If you need to swap out the file system (e.g., for a mock in testing or a different storage backend), you'd have to change the code directly. This can affect maintainability by making the code harder to change and test, and it could potentially affect correctness if the file system implementation has bugs.\n",
            "lineStart": 19,
            "lineEnd": 21,
            "status": ""
          }
        ],
        "codeReviewTitle": "SOLID Code Review"
      }
    },
    "gradingDetails": {
      "dependencyInversionScore": "B+",
      "interfaceSegregationScore": "A-",
      "liskovSubstitutionScore": "B+",
      "openClosedScore": "B+",
      "singleResponsibilityScore": "A-"
    },
    "codeDiff": {
      "oldCode": "package read\n\nimport (\n\t\"codeleft-cli/types\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\n// FileSystem abstracts file system operations.\ntype FileSystem interface {\n\tGetwd() (string, error)\n\tOpen(name string) (*os.File, error)\n\tStat(name string) (os.FileInfo, error)\n\tJoin(elem ...string) string\n}\n\n// OSFileSystem implements the FileSystem interface using the os package.\ntype OSFileSystem struct{}\n\nfunc NewOSFileSystem() FileSystem {\n\treturn &OSFileSystem{}\n}\n\nfunc (o *OSFileSystem) Getwd() (string, error) {\n\treturn os.Getwd()\n}\n\nfunc (o *OSFileSystem) Open(name string) (*os.File, error) {\n\treturn os.Open(name)\n}\n\nfunc (o *OSFileSystem) Stat(name string) (os.FileInfo, error) {\n\treturn os.Stat(name)\n}\n\nfunc (o *OSFileSystem) Join(elem ...string) string {\n\treturn filepath.Join(elem...)\n}\n\n// JSONDecoder abstracts JSON decoding.\ntype JSONDecoder interface {\n\tDecode(v interface{}) error\n}\n\n// ConfigSource interface for reading configuration.\ntype ConfigSource interface {\n\tReadConfig() (*types.Config, error)\n}\n\n// ConfigPathResolver resolves the path to the config file.\ntype ConfigPathResolver interface {\n\tResolveConfigPath() (string, error)\n}\n\n// ConfigJSONReader reads the config from a JSON file.\ntype ConfigJSONReader interface {\n\tReadConfigFromJSON(path string) (*types.Config, error)\n}\n\n// ConfigReader is responsible for reading the config.json file.\ntype ConfigReader struct {\n\tRepoRoot     string\n\tCodeleftPath string\n\tFileSystem   FileSystem\n\t//\tJSONDecoder  JSONDecoder // Removed direct dependency on JSONDecoder\n}\n\n// NewConfigReader creates a new ConfigReader.\nfunc NewConfigReader(fs FileSystem) (*ConfigReader, error) {\n\tif fs == nil {\n\t\tfs = &OSFileSystem{} // Use OSFileSystem as default\n\t}\n\trepoRoot, err := fs.Getwd()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get current working directory: %w\", err)\n\t}\n\n\t// Recursively find .codeleft\n\tcodeleftPath, err := findCodeleftRecursive(repoRoot)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcr := &ConfigReader{\n\t\tRepoRoot:     repoRoot,\n\t\tCodeleftPath: codeleftPath,\n\t\tFileSystem:   fs,\n\t}\n\treturn cr, nil\n}\n\n// ResolveConfigPath resolves the path to the config.json file.\nfunc (cr *ConfigReader) ResolveConfigPath() (string, error) {\n\tif cr.CodeleftPath == \"\" {\n\t\treturn \"\", fmt.Errorf(\".codeLeft folder not found in the repository root: %s\", cr.RepoRoot)\n\t}\n\treturn filepath.Join(cr.CodeleftPath, \"config.json\"), nil\n}\n\n// ReadConfig reads the configuration from config.json.\nfunc (cr *ConfigReader) ReadConfig() (*types.Config, error) {\n\tconfigPath, err := cr.ResolveConfigPath()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check if config.json exists\n\tinfo, err := cr.FileSystem.Stat(configPath)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn nil, fmt.Errorf(\"config.json does not exist at path: %s\", configPath)\n\t\t}\n\t\treturn nil, fmt.Errorf(\"error accessing config.json: %w\", err)\n\t}\n\n\tif info.IsDir() {\n\t\treturn nil, fmt.Errorf(\"config.json exists but is a directory: %s\", configPath)\n\t}\n\n\t// Open the config.json file\n\tfile, err := cr.FileSystem.Open(configPath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to open config.json: %w\", err)\n\t}\n\tdefer file.Close()\n\n\t// Decode the JSON into a Config struct\n\tvar config types.Config\n\tdecoder := json.NewDecoder(file)\n\tif err := decoder.Decode(&config); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to decode config.json: %w\", err)\n\t}\n\n\treturn &config, nil\n}",
      "newCode": "package read\n\nimport (\n\t\"codeleft-cli/types\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\n// FileSystem abstracts file system operations.\ntype FileSystem interface {\n\tGetwd() (string, error)\n\tOpen(name string) (*os.File, error)\n\tStat(name string) (os.FileInfo, error)\n\tJoin(elem ...string) string\n}\n\n// OSFileSystem implements the FileSystem interface using the os package.\ntype OSFileSystem struct{}\n\nfunc (o *OSFileSystem) Getwd() (string, error) {\n\treturn os.Getwd()\n}\n\nfunc (o *OSFileSystem) Open(name string) (*os.File, error) {\n\treturn os.Open(name)\n}\n\nfunc (o *OSFileSystem) Stat(name string) (os.FileInfo, error) {\n\treturn os.Stat(name)\n}\n\nfunc (o *OSFileSystem) Join(elem ...string) string {\n\treturn filepath.Join(elem...)\n}\n\n// JSONDecoder abstracts JSON decoding.\ntype JSONDecoder interface {\n\tDecode(v interface{}) error\n}\n\n// ConfigSource interface for reading configuration.\ntype ConfigSource interface {\n\tReadConfig() (*types.Config, error)\n}\n\n// ConfigPathResolver resolves the path to the config file.\ntype ConfigPathResolver interface {\n\tResolveConfigPath() (string, error)\n}\n\n// ConfigJSONReader reads the config from a JSON file.\ntype ConfigJSONReader interface {\n\tReadConfigFromJSON(path string) (*types.Config, error)\n}\n\n// ConfigReader is responsible for reading the config.json file.\ntype ConfigReader struct {\n\tRepoRoot     string\n\tCodeleftPath string\n\tFileSystem   FileSystem\n\t//\tJSONDecoder  JSONDecoder // Removed direct dependency on JSONDecoder\n}\n\n// NewConfigReader creates a new ConfigReader.\nfunc NewConfigReader(fs FileSystem) (*ConfigReader, error) {\n\tif fs == nil {\n\t\tfs = &OSFileSystem{} // Use OSFileSystem as default\n\t}\n\trepoRoot, err := fs.Getwd()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get current working directory: %w\", err)\n\t}\n\n\t// Recursively find .codeleft\n\tcodeleftPath, err := findCodeleftRecursive(repoRoot)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcr := &ConfigReader{\n\t\tRepoRoot:     repoRoot,\n\t\tCodeleftPath: codeleftPath,\n\t\tFileSystem:   fs,\n\t}\n\treturn cr, nil\n}\n\n// ResolveConfigPath resolves the path to the config.json file.\nfunc (cr *ConfigReader) ResolveConfigPath() (string, error) {\n\tif cr.CodeleftPath == \"\" {\n\t\treturn \"\", fmt.Errorf(\".codeLeft folder not found in the repository root: %s\", cr.RepoRoot)\n\t}\n\treturn filepath.Join(cr.CodeleftPath, \"config.json\"), nil\n}\n\n// ReadConfig reads the configuration from config.json.\nfunc (cr *ConfigReader) ReadConfig() (*types.Config, error) {\n\tconfigPath, err := cr.ResolveConfigPath()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check if config.json exists\n\tinfo, err := cr.FileSystem.Stat(configPath)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn nil, fmt.Errorf(\"config.json does not exist at path: %s\", configPath)\n\t\t}\n\t\treturn nil, fmt.Errorf(\"error accessing config.json: %w\", err)\n\t}\n\n\tif info.IsDir() {\n\t\treturn nil, fmt.Errorf(\"config.json exists but is a directory: %s\", configPath)\n\t}\n\n\t// Open the config.json file\n\tfile, err := cr.FileSystem.Open(configPath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to open config.json: %w\", err)\n\t}\n\tdefer file.Close()\n\n\t// Decode the JSON into a Config struct\n\tvar config types.Config\n\tdecoder := json.NewDecoder(file)\n\tif err := decoder.Decode(&config); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to decode config.json: %w\", err)\n\t}\n\n\treturn &config, nil\n}",
      "changes": [
        {
          "oldCode": "\nfunc NewOSFileSystem() FileSystem {\n\treturn &OSFileSystem{}\n}\n",
          "reason": "Modified",
          "start": 21,
          "end": 25,
          "grade": "B+"
        }
      ]
    },
    "hash": "d226182ca6872103808d5062c8366e3e75a340c5966a917f08106661a3ce46bb",
    "id": "eJydV0tv4zgM/itcA1PYRda+Z5FTO7PoYJAOkp2bL6pMJdrakiHJzQZF//uCkh3LSfPA9FKDosiPr4/Ke8KsRWul2vyjdZ3Mk/Xzj6fHZJZwXeGDVg6VS+ZJy/gr2yAYZFWpSiWbVhsHaalKV3rdGoX7k9eycPsWbZmEE1RcV1Jtin+tVoNQNG741AfNlrltIWSN9EHCjPwUBXyTNa731mED7MU6w7izQIpgg1S3aJiTWtm8VOQ9viKVQyMYR3gnP3+j21VpBql1RqrNDNAYbciVe25RpYo1COEsg/Re25xsxWprx9yRWq/1pISONb9rqVKssYE8zwfl8L9UH310z+sYbNPW2KByFtz2TBgd1cofawt9WYa4J8asMx13796R6BSHJe5ihTSLHfjsGHSdUXAXq5GB0Uaq4T4+zeBMRicGtc17tcu2bijBsd3DlSumbyvbsfXDrSvWL5R6YnLo7/xwIc/zbOyG7+vn5SPSOJmo2UkKFYZJGmodqx41eRCnb6P8/SMLEY6uHrQScrPWneEYGRDa+CEn5NyrdGG4Br9n7nnHK2RVOKeGuPdMkAfBOBhTAD+Z267Q6voNybH/CN1PeQKn/XdA4tM3xTG5foLGy0fFz+Z+ioaSSkFgSIKdODe6ARaKcQokunk2Kd+Mbkgv9aGNLX5LngbblpLUamXlSz2t1gg1J7L9BGNvIxDDAK7VK60d0N/ATaV76An95wiUxBFfQEQedFQUpYtbctKfRQErbPQbVlBJg9xBhS2qChXfg1ax7hj3EncT2Nwgc2iBgcLdJKJ8JLhYnAoL8ZCm9/HpdOSlAGFhsQAl6yApHQmOuZBC+WWPmJZZqFCwrnZ08SPMe8ir9wLzBYiIAr07kv8x8ddzhJL1DETj8q+ET6RlIpissaJZ2KAD3hmDysFOm1eqe8ioNvs5fNmVifeYDUB8ZWCFvDNWvmG9ByFVBfmwsUmBR8Ue8UpVDV1wuJ4OYd0WBBoT4eDe7l1cg/7O0IRz34WH1IXDuBXnMMEaFMZC0H1hZ1ERPBZuZoRn7KwTYrhGPJOBCiuAG5i0U3Zq9dxSlAK4yScjtlhAmZTJURJJdNQKvnA/UDgQuqapUJo+O1WBVB4xpc9K6gcwPqdfLFnhJl/Fxfs4u5WOsM2A3neHLJRJdpLNgd9OOLNfHYE6IyMXs3h1hYQs8UOeDz3rYzwpwm+0KrHuFvkrUKmiDsD/pHXWGxweDb3fsQnDm2FEd96/FPTEeLJL7b6S4ZQGdzi8QAcxokqj9T3goQFzvnsPRZ+i6Kt+wbRPMDDOw0+COPgz7CIFUC7yJ/soTZpd5bLTdMJL52ivsQmTfYZ/rA69+j6dTzoXw3PxtDb+tXhLbW7gYk0YriTIVSjQBOZ4qLVF344hhrDwfBT+TSGV08D6xdYvaVJ9Y2Z4gsTTEKyH/TpfgB+rJe76NZqSyzi8+QJ67bx/Ht4Fo9lfvxd+sHZDhww/Kng/xIE8kllCEKkKyTwpflk0ttiiMvuaNS9F09VOtjUWk5+WxC8Fjzf/Ricf/wNWLEz+"
  },
  {
    "assessingTool": "SOLID",
    "filePath": "/Users/henrylamb/multiple/codeleft-cli/read/configReader.go",
    "grade": "C",
    "username": "Hlamb",
    "timestamp": "2025-05-24T20:45:45.937Z",
    "codeReview": {
      "detailedReview": {
        "tasks": [
          {
            "done": false,
            "titleTask": "liskovSubstitution",
            "violatingCode": "The provided code snippet does not demonstrate a violation of the Liskov Substitution Principle (LSP). The `NewOSFileSystem` function simply returns a concrete implementation (`OSFileSystem`) of the `FileSystem` interface. This is a standard factory pattern and does not inherently violate LSP.\n",
            "codeResolution": "```markdown\n**Code Resolution for Liskov Substitution Principle (LSP)**\n\nThe provided code snippet demonstrates good adherence to LSP. The `OSFileSystem` likely implements the `FileSystem` interface, allowing it to be substituted for other `FileSystem` implementations without altering the program's correctness.\n\n**No specific fix or refactoring is needed** based on the provided snippet. The `NewOSFileSystem` function correctly returns a concrete implementation (`OSFileSystem`) that adheres to the `FileSystem` interface. This design allows for interchangeable use of different file system implementations.\n```\n",
            "severity": "Low",
            "rationale": "Rationale:\n\nThe `NewOSFileSystem` function adheres to LSP because it returns a concrete implementation (`OSFileSystem`) that can substitute the `FileSystem` interface. This design choice ensures that any code expecting a `FileSystem` can use the `OSFileSystem` without unexpected behavior. This substitution principle is crucial for maintainability, as it allows for easy swapping of file system implementations (e.g., a mock file system for testing) without altering the core logic. It also helps with correctness by ensuring that the behavior of the file system is consistent across different implementations.\n",
            "lineStart": 19,
            "lineEnd": 20,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "openClosed",
            "violatingCode": "The provided code snippet demonstrates a violation of the Open/Closed Principle (OCP).\n\n```go\nfunc NewOSFileSystem() FileSystem {\n\treturn &OSFileSystem{}\n}\n```\n\nThis code is closed for modification. If you need to add a new file system type, you would need to modify this function.\n",
            "codeResolution": "```markdown\n**Code Resolution**\n\nThe provided code snippet demonstrates the creation of an `OSFileSystem` struct and its instantiation.\n\n*   **Open/Closed Principle (OCP) Fix/Refactoring Strategy:**\n\n    The current code adheres to OCP by allowing extension without modification. To further enhance OCP, consider defining an interface for `FileSystem` and implementing `OSFileSystem` to that interface. This allows for easy substitution of different file system implementations (e.g., a mock file system for testing) without changing the code that uses the `FileSystem`.\n\n    ```go\n    type FileSystem interface {\n        // Define file system operations here (e.g., ReadFile, WriteFile)\n    }\n\n    type OSFileSystem struct{}\n\n    func (o *OSFileSystem) ReadFile(filename string) ([]byte, error) {\n        // Implementation\n    }\n\n    func NewOSFileSystem() FileSystem {\n        return &OSFileSystem{}\n    }\n    ```\n```",
            "severity": "Low",
            "rationale": "Rationale:\n\nThe `NewOSFileSystem` function's direct return of a concrete `OSFileSystem` type violates the Open/Closed Principle. This design makes it difficult to extend the system with alternative file system implementations (e.g., a mock file system for testing) without modifying the existing code. This lack of flexibility can hinder maintainability, as changes to support new file system types require direct edits to the `NewOSFileSystem` function, potentially introducing errors and increasing the risk of breaking existing functionality.\n",
            "lineStart": 19,
            "lineEnd": 22,
            "status": ""
          },
          {
            "done": false,
            "titleTask": "dependencyInversion",
            "violatingCode": "The `NewOSFileSystem` function directly returns a concrete `OSFileSystem` struct. This violates the Dependency Inversion Principle because the code is dependent on a specific implementation rather than an abstraction.\n\n```go\n20: \treturn &OSFileSystem{}\n```\n",
            "codeResolution": "```markdown\n**Code Resolution for Dependency Inversion**\n\nThe `NewOSFileSystem` function directly returns a concrete `OSFileSystem` struct. To improve dependency inversion, introduce an interface for `FileSystem`.\n\n**Refactoring Strategy:**\n\n1.  Define a `FileSystem` interface with methods like `ReadFile` and `WriteFile`.\n2.  Make `OSFileSystem` implement this interface.\n3.  The `NewOSFileSystem` function should return the interface, not the concrete struct.\n\n**Example:**\n\n```go\ntype FileSystem interface {\n    ReadFile(filename string) ([]byte, error)\n    WriteFile(filename string, data []byte) error\n}\n\ntype OSFileSystem struct{}\n\nfunc (o *OSFileSystem) ReadFile(filename string) ([]byte, error) {\n    // Implementation\n}\n\nfunc (o *OSFileSystem) WriteFile(filename string, data []byte) error {\n    // Implementation\n}\n\nfunc NewOSFileSystem() FileSystem {\n    return &OSFileSystem{}\n}\n```\n```",
            "severity": "Low",
            "rationale": "Rationale:\n\nThe `NewOSFileSystem` function directly returns a concrete `OSFileSystem` struct. This violates the Dependency Inversion Principle (DIP) because it couples the code to a specific implementation. This matters because it reduces flexibility and testability. If you need to swap out the file system (e.g., for a mock in testing or a different storage backend), you'd have to change the code directly. This can affect maintainability by making the code harder to change and test, and it could potentially affect correctness if the file system implementation has bugs.\n",
            "lineStart": 19,
            "lineEnd": 21,
            "status": ""
          }
        ],
        "codeReviewTitle": "SOLID Code Review"
      }
    },
    "gradingDetails": {
      "dependencyInversionScore": "B+",
      "interfaceSegregationScore": "A-",
      "liskovSubstitutionScore": "B+",
      "openClosedScore": "B+",
      "singleResponsibilityScore": "A-"
    },
    "codeDiff": {
      "oldCode": "package read\n\nimport (\n\t\"codeleft-cli/types\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\n// FileSystem abstracts file system operations.\ntype FileSystem interface {\n\tGetwd() (string, error)\n\tOpen(name string) (*os.File, error)\n\tStat(name string) (os.FileInfo, error)\n\tJoin(elem ...string) string\n}\n\n// OSFileSystem implements the FileSystem interface using the os package.\ntype OSFileSystem struct{}\n\nfunc NewOSFileSystem() FileSystem {\n\treturn &OSFileSystem{}\n}\n\nfunc (o *OSFileSystem) Getwd() (string, error) {\n\treturn os.Getwd()\n}\n\nfunc (o *OSFileSystem) Open(name string) (*os.File, error) {\n\treturn os.Open(name)\n}\n\nfunc (o *OSFileSystem) Stat(name string) (os.FileInfo, error) {\n\treturn os.Stat(name)\n}\n\nfunc (o *OSFileSystem) Join(elem ...string) string {\n\treturn filepath.Join(elem...)\n}\n\n// JSONDecoder abstracts JSON decoding.\ntype JSONDecoder interface {\n\tDecode(v interface{}) error\n}\n\n// ConfigSource interface for reading configuration.\ntype ConfigSource interface {\n\tReadConfig() (*types.Config, error)\n}\n\n// ConfigPathResolver resolves the path to the config file.\ntype ConfigPathResolver interface {\n\tResolveConfigPath() (string, error)\n}\n\n// ConfigJSONReader reads the config from a JSON file.\ntype ConfigJSONReader interface {\n\tReadConfigFromJSON(path string) (*types.Config, error)\n}\n\n// ConfigReader is responsible for reading the config.json file.\ntype ConfigReader struct {\n\tRepoRoot     string\n\tCodeleftPath string\n\tFileSystem   FileSystem\n\t//\tJSONDecoder  JSONDecoder // Removed direct dependency on JSONDecoder\n}\n\n// NewConfigReader creates a new ConfigReader.\nfunc NewConfigReader(fs FileSystem) (*ConfigReader, error) {\n\tif fs == nil {\n\t\tfs = &OSFileSystem{} // Use OSFileSystem as default\n\t}\n\trepoRoot, err := fs.Getwd()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get current working directory: %w\", err)\n\t}\n\n\t// Recursively find .codeleft\n\tcodeleftPath, err := findCodeleftRecursive(repoRoot)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcr := &ConfigReader{\n\t\tRepoRoot:     repoRoot,\n\t\tCodeleftPath: codeleftPath,\n\t\tFileSystem:   fs,\n\t}\n\treturn cr, nil\n}\n\n// ResolveConfigPath resolves the path to the config.json file.\nfunc (cr *ConfigReader) ResolveConfigPath() (string, error) {\n\tif cr.CodeleftPath == \"\" {\n\t\treturn \"\", fmt.Errorf(\".codeLeft folder not found in the repository root: %s\", cr.RepoRoot)\n\t}\n\treturn filepath.Join(cr.CodeleftPath, \"config.json\"), nil\n}\n\n// ReadConfig reads the configuration from config.json.\nfunc (cr *ConfigReader) ReadConfig() (*types.Config, error) {\n\tconfigPath, err := cr.ResolveConfigPath()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check if config.json exists\n\tinfo, err := cr.FileSystem.Stat(configPath)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn nil, fmt.Errorf(\"config.json does not exist at path: %s\", configPath)\n\t\t}\n\t\treturn nil, fmt.Errorf(\"error accessing config.json: %w\", err)\n\t}\n\n\tif info.IsDir() {\n\t\treturn nil, fmt.Errorf(\"config.json exists but is a directory: %s\", configPath)\n\t}\n\n\t// Open the config.json file\n\tfile, err := cr.FileSystem.Open(configPath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to open config.json: %w\", err)\n\t}\n\tdefer file.Close()\n\n\t// Decode the JSON into a Config struct\n\tvar config types.Config\n\tdecoder := json.NewDecoder(file)\n\tif err := decoder.Decode(&config); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to decode config.json: %w\", err)\n\t}\n\n\treturn &config, nil\n}",
      "newCode": "package read\n\nimport (\n\t\"codeleft-cli/types\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\n// FileSystem abstracts file system operations.\ntype FileSystem interface {\n\tGetwd() (string, error)\n\tOpen(name string) (*os.File, error)\n\tStat(name string) (os.FileInfo, error)\n\tJoin(elem ...string) string\n}\n\n// OSFileSystem implements the FileSystem interface using the os package.\ntype OSFileSystem struct{}\n\nfunc (o *OSFileSystem) Getwd() (string, error) {\n\treturn os.Getwd()\n}\n\nfunc (o *OSFileSystem) Open(name string) (*os.File, error) {\n\treturn os.Open(name)\n}\n\nfunc (o *OSFileSystem) Stat(name string) (os.FileInfo, error) {\n\treturn os.Stat(name)\n}\n\nfunc (o *OSFileSystem) Join(elem ...string) string {\n\treturn filepath.Join(elem...)\n}\n\n// JSONDecoder abstracts JSON decoding.\ntype JSONDecoder interface {\n\tDecode(v interface{}) error\n}\n\n// ConfigSource interface for reading configuration.\ntype ConfigSource interface {\n\tReadConfig() (*types.Config, error)\n}\n\n// ConfigPathResolver resolves the path to the config file.\ntype ConfigPathResolver interface {\n\tResolveConfigPath() (string, error)\n}\n\n// ConfigJSONReader reads the config from a JSON file.\ntype ConfigJSONReader interface {\n\tReadConfigFromJSON(path string) (*types.Config, error)\n}\n\n// ConfigReader is responsible for reading the config.json file.\ntype ConfigReader struct {\n\tRepoRoot     string\n\tCodeleftPath string\n\tFileSystem   FileSystem\n\t//\tJSONDecoder  JSONDecoder // Removed direct dependency on JSONDecoder\n}\n\n// NewConfigReader creates a new ConfigReader.\nfunc NewConfigReader(fs FileSystem) (*ConfigReader, error) {\n\tif fs == nil {\n\t\tfs = &OSFileSystem{} // Use OSFileSystem as default\n\t}\n\trepoRoot, err := fs.Getwd()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get current working directory: %w\", err)\n\t}\n\n\t// Recursively find .codeleft\n\tcodeleftPath, err := findCodeleftRecursive(repoRoot)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcr := &ConfigReader{\n\t\tRepoRoot:     repoRoot,\n\t\tCodeleftPath: codeleftPath,\n\t\tFileSystem:   fs,\n\t}\n\treturn cr, nil\n}\n\n// ResolveConfigPath resolves the path to the config.json file.\nfunc (cr *ConfigReader) ResolveConfigPath() (string, error) {\n\tif cr.CodeleftPath == \"\" {\n\t\treturn \"\", fmt.Errorf(\".codeLeft folder not found in the repository root: %s\", cr.RepoRoot)\n\t}\n\treturn filepath.Join(cr.CodeleftPath, \"config.json\"), nil\n}\n\n// ReadConfig reads the configuration from config.json.\nfunc (cr *ConfigReader) ReadConfig() (*types.Config, error) {\n\tconfigPath, err := cr.ResolveConfigPath()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check if config.json exists\n\tinfo, err := cr.FileSystem.Stat(configPath)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn nil, fmt.Errorf(\"config.json does not exist at path: %s\", configPath)\n\t\t}\n\t\treturn nil, fmt.Errorf(\"error accessing config.json: %w\", err)\n\t}\n\n\tif info.IsDir() {\n\t\treturn nil, fmt.Errorf(\"config.json exists but is a directory: %s\", configPath)\n\t}\n\n\t// Open the config.json file\n\tfile, err := cr.FileSystem.Open(configPath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to open config.json: %w\", err)\n\t}\n\tdefer file.Close()\n\n\t// Decode the JSON into a Config struct\n\tvar config types.Config\n\tdecoder := json.NewDecoder(file)\n\tif err := decoder.Decode(&config); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to decode config.json: %w\", err)\n\t}\n\n\treturn &config, nil\n}",
      "changes": [
        {
          "oldCode": "\nfunc NewOSFileSystem() FileSystem {\n\treturn &OSFileSystem{}\n}\n",
          "reason": "Modified",
          "start": 21,
          "end": 25,
          "grade": "B+"
        }
      ]
    },
    "hash": "9a5b7d8075989e0fdb0848e7ad3612474e28d1892d68acf1fccb0ba3c902072f",
    "id": "eJydV0tv4zgM/itcA1PYRda+Z5FTO7PoYJAOkp2bL6pMJdrakiHJzQZF//uCkh3LSfPA9FKDosiPr4/Ke8KsRWul2vyjdZ3Mk/Xzj6fHZJZwXeGDVg6VS+ZJy/gr2yAYZFWpSiWbVhsHaalKV3rdGoX7k9eycPsWbZmEE1RcV1Jtin+tVoNQNG741AfNlrltIWSN9EHCjPwUBXyTNa731mED7MU6w7izQIpgg1S3aJiTWtm8VOQ9viKVQyMYR3gnP3+j21VpBql1RqrNDNAYbciVe25RpYo1COEsg/Re25xsxWprx9yRWq/1pISONb9rqVKssYE8zwfl8L9UH310z+sYbNPW2KByFtz2TBgd1cofawt9WYa4J8asMx13796R6BSHJe5ihTSLHfjsGHSdUXAXq5GB0Uaq4T4+zeBMRicGtc17tcu2bijBsd3DlSumbyvbsfXDrSvWL5R6YnLo7/xwIc/zbOyG7+vn5SPSOJmo2UkKFYZJGmodqx41eRCnb6P8/SMLEY6uHrQScrPWneEYGRDa+CEn5NyrdGG4Br9n7nnHK2RVOKeGuPdMkAfBOBhTAD+Z267Q6voNybH/CN1PeQKn/XdA4tM3xTG5foLGy0fFz+Z+ioaSSkFgSIKdODe6ARaKcQokunk2Kd+Mbkgv9aGNLX5LngbblpLUamXlSz2t1gg1J7L9BGNvIxDDAK7VK60d0N/ATaV76An95wiUxBFfQEQedFQUpYtbctKfRQErbPQbVlBJg9xBhS2qChXfg1ax7hj3EncT2Nwgc2iBgcLdJKJ8JLhYnAoL8ZCm9/HpdOSlAGFhsQAl6yApHQmOuZBC+WWPmJZZqFCwrnZ08SPMe8ir9wLzBYiIAr07kv8x8ddzhJL1DETj8q+ET6RlIpissaJZ2KAD3hmDysFOm1eqe8ioNvs5fNmVifeYDUB8ZWCFvDNWvmG9ByFVBfmwsUmBR8Ue8UpVDV1wuJ4OYd0WBBoT4eDe7l1cg/7O0IRz34WH1IXDuBXnMMEaFMZC0H1hZ1ERPBZuZoRn7KwTYrhGPJOBCiuAG5i0U3Zq9dxSlAK4yScjtlhAmZTJURJJdNQKvnA/UDgQuqapUJo+O1WBVB4xpc9K6gcwPqdfLFnhJl/Fxfs4u5WOsM2A3neHLJRJdpLNgd9OOLNfHYE6IyMXs3h1hYQs8UOeDz3rYzwpwm+0KrHuFvkrUKmiDsD/pHXWGxweDb3fsQnDm2FEd96/FPTEeLJL7b6S4ZQGdzi8QAcxokqj9T3goQFzvnsPRZ+i6Kt+wbRPMDDOw0+COPgz7CIFUC7yJ/soTZpd5bLTdMJL52ivsQmTfYZ/rA69+j6dTzoXw3PxtDb+tXhLbW7gYk0YriTIVSjQBOZ4qLVF344hhrDwfBT+TSGV08D6xdYvaVJ9Y2Z4gsTTEKyH/TpfgB+rJe76NZqSyzi8+QJ67bx/Ht4Fo9lfvxd+sHZDhww/Kng/xIE8kllCEKkKyTwpflk0ttiiMvuaNS9F09VOtjUWk5+WxC8Fjzf/Ricf/wNWLEz+"
  }
]